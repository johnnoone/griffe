{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Griffe","text":"<p>  [![ci](https://github.com/mkdocstrings/griffe/workflows/ci/badge.svg)](https://github.com/mkdocstrings/griffe/actions?query=workflow%3Aci) [![documentation](https://img.shields.io/badge/docs-mkdocs%20material-blue.svg?style=flat)](https://mkdocstrings.github.io/griffe/) [![pypi version](https://img.shields.io/pypi/v/griffe.svg)](https://pypi.org/project/griffe/) [![gitpod](https://img.shields.io/badge/gitpod-workspace-blue.svg?style=flat)](https://gitpod.io/#https://github.com/mkdocstrings/griffe) [![gitter](https://badges.gitter.im/join%20chat.svg)](https://gitter.im/mkdocstrings/griffe)  </p> <p></p> <p>Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API.</p> <p>Griffe, pronounced \"grif\" (<code>/\u0261\u0281if/</code>), is a french word that means \"claw\", but also \"signature\" in a familiar way. \"On reconna\u00eet bien l\u00e0 sa griffe.\"</p>"},{"location":"#installation","title":"Installation","text":"<p>With <code>pip</code>: <pre><code>pip install griffe\n</code></pre></p> <p>With <code>pipx</code>: <pre><code>python3.8 -m pip install --user pipx\npipx install griffe\n</code></pre></p>"},{"location":"#usage","title":"Usage","text":"<p>On the command line, pass the names of packages to the <code>griffe dump</code> command:</p> <pre><code>$ griffe dump httpx fastapi\n{\n  \"httpx\": {\n    \"name\": \"httpx\",\n    ...\n  },\n  \"fastapi\": {\n    \"name\": \"fastapi\",\n    ...\n  }\n}\n</code></pre> <p>See the Dumping data section for more examples.</p> <p>Or pass a relative path to the <code>griffe check</code> command:</p> <pre><code>$ griffe check mypackage --verbose\nmypackage/mymodule.py:10: MyClass.mymethod(myparam):\nParameter kind was changed:\n  Old: positional or keyword\n  New: keyword-only\n</code></pre> <p>For <code>src</code> layouts:</p> <pre><code>$ griffe check --search src mypackage --verbose\nsrc/mypackage/mymodule.py:10: MyClass.mymethod(myparam):\nParameter kind was changed:\n  Old: positional or keyword\n  New: keyword-only\n</code></pre> <p>See the API breakage section for more examples.</p> <p>With Python, loading a package:</p> <pre><code>import griffe\n\nfastapi = griffe.load(\"fastapi\")\n</code></pre> <p>Finding breaking changes:</p> <pre><code>import griffe\n\nprevious = griffe.load_git(\"mypackage\", ref=\"0.2.0\")\ncurrent = griffe.load(\"mypackage\")\n\nfor breakage in griffe.find_breaking_changes(previous, current):\n    ...\n</code></pre> <p>See the Loading data section for more examples.</p>"},{"location":"#todo","title":"Todo","text":"<ul> <li>Extensions<ul> <li>Post-processing extensions</li> <li>Third-party libraries we could provide support for:<ul> <li>Django support</li> <li>Marshmallow support</li> <li>Pydantic support</li> </ul> </li> </ul> </li> <li>Docstrings parsers<ul> <li>epydoc</li> <li>New Markdown-based format? For graceful degradation</li> </ul> </li> <li>Serializer:<ul> <li>Flat JSON</li> </ul> </li> <li>API diff:<ul> <li> Mechanism to cache APIs? Should users version them, or store them somewhere (docs)?</li> <li> Ability to return warnings (things that are not backward-compatibility-friendly)</li> <li>List of things to consider for warnings<ul> <li>Multiple positional-or-keyword parameters</li> <li>Public imports in public modules</li> <li>Private things made public through imports/assignments</li> <li>Too many public things? Generally annoying. Configuration?</li> </ul> </li> <li> Ability to compare two APIs to return breaking changes</li> <li>List of things to consider for breaking changes<ul> <li> Changed position of positional only parameter</li> <li> Changed position of positional or keyword parameter</li> <li> Changed type of parameter</li> <li> Changed type of public module attribute</li> <li> Changed return type of a public function/method</li> <li> Added parameter without a default value</li> <li> Removed keyword-only parameter without a default value, without **kwargs to swallow it</li> <li> Removed positional-only parameter without a default value, without *args to swallow it</li> <li> Removed positional-or_keyword argument without a default value, without args and *kwargs to swallow it</li> <li> Removed public module/class/function/method/attribute</li> <li> All of the previous even when parent is private (could be publicly imported or assigned somewhere),     and later be smarter: public assign/import makes private things public!</li> <li> Inheritance: removed, added or changed base that changes MRO</li> </ul> </li> </ul> </li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#0360-2023-09-01","title":"0.36.0 - 2023-09-01","text":"<p>Compare with 0.35.2</p>"},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Add option to read return type of properties in their summary (Google-style) (096970f by Timoth\u00e9e Mazzucotelli). Issue #137, PR #206</li> <li>Add option to make parentheses around the type of returned values optional (Google-style) (b0620f8 by Timoth\u00e9e Mazzucotelli). Issue #137</li> <li>Get class parameters from parent's <code>__init__</code> method (e8a9fdc by Timoth\u00e9e Mazzucotelli). Issue #205</li> </ul>"},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Use all members (declared and inherited) when checking for breakages, avoid false-positives when a member of a class is moved into a parent class (1c4340b by Timoth\u00e9e Mazzucotelli). Issue #203</li> <li>Skip early submodules with dots in their path (5e81b8a by Timoth\u00e9e Mazzucotelli). Issue #185</li> </ul>"},{"location":"changelog/#code-refactoring","title":"Code Refactoring","text":"<ul> <li>Allow iterating on expressions in both flat and nested ways (3957fa7 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0352-2023-08-27","title":"0.35.2 - 2023-08-27","text":"<p>Compare with 0.35.1</p>"},{"location":"changelog/#code-refactoring_1","title":"Code Refactoring","text":"<ul> <li>Be more strict when parsing sections in Google docstrings (6a8a228 by Timoth\u00e9e Mazzucotelli). Issue #204</li> </ul>"},{"location":"changelog/#0351-2023-08-26","title":"0.35.1 - 2023-08-26","text":"<p>Compare with 0.35.0</p>"},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>Preserve inherited attribute on alias inherited members (1e19e7b by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/python#102</li> </ul>"},{"location":"changelog/#0350-2023-08-24","title":"0.35.0 - 2023-08-24","text":"<p>Compare with 0.34.0</p>"},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>Add an <code>is_public</code> helper method to guess if an object is public (b823639 by Timoth\u00e9e Mazzucotelli).</li> <li>Add option to Google parser allowing to parse Returns sections with or without multiple items (65fee70 by Antoine Dechaume). PR #196</li> </ul>"},{"location":"changelog/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>Allow passing <code>warn_unknown_params</code> option to Google and Numpy parsers (5bf0746 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_2","title":"Code Refactoring","text":"<ul> <li>Preserve alias members path by re-aliasing members instead of returning target's members (d400cb1 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0340-2023-08-20","title":"0.34.0 - 2023-08-20","text":"<p>Compare with 0.33.0</p>"},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li>Allow checking if docstring section is empty or not with <code>if section</code> (f6cf559 by Timoth\u00e9e Mazzucotelli).</li> <li>Implement Functions (or Methods), Classes and Modules docstring sections (929e615 by Timoth\u00e9e Mazzucotelli).</li> <li>Allow passing a docstring parser name instead of its enumeration value (ce59b7d by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_3","title":"Code Refactoring","text":"<ul> <li>Explicit checks for subprocess runs (cc3ca2e by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0330-2023-08-16","title":"0.33.0 - 2023-08-16","text":"<p>Compare with 0.32.3</p>"},{"location":"changelog/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>Removed <code>griffe.expressions.Expression</code> in favor of <code>griffe.expressions.Expr</code> and subclasses</li> <li>Removed <code>griffe.expressions.Name</code> in favor of <code>griffe.expressions.ExprName</code></li> </ul>"},{"location":"changelog/#features_3","title":"Features","text":"<ul> <li>Add <code>-V</code>, <code>--version</code> CLI flag to show version (a41515f by jgart). Issue #186, PR #187, Co-authored-by: Timoth\u00e9e Mazzucotelli pawamoy@pm.me</li> </ul>"},{"location":"changelog/#code-refactoring_4","title":"Code Refactoring","text":"<ul> <li>Improve expressions (66c8ad5 and 0fe8f91 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0323-2023-07-17","title":"0.32.3 - 2023-07-17","text":"<p>Compare with 0.32.2</p>"},{"location":"changelog/#bug-fixes_3","title":"Bug Fixes","text":"<ul> <li>Fix detecting whether an object should be an alias during inspection (6a63b37 by Timoth\u00e9e Mazzucotelli). Issue #180</li> </ul>"},{"location":"changelog/#code-refactoring_5","title":"Code Refactoring","text":"<ul> <li>Improve log message when trying to stubs-merge objects of different kinds (d34a3ba by Timoth\u00e9e Mazzucotelli).</li> <li>De-duplicate stubs merging log message (cedc062 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0322-2023-07-17","title":"0.32.2 - 2023-07-17","text":"<p>Compare with 0.32.1</p>"},{"location":"changelog/#bug-fixes_4","title":"Bug Fixes","text":"<ul> <li>Keep parentheses around tuples, except within subscripts (df6e636 by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/python#88</li> </ul>"},{"location":"changelog/#0321-2023-07-15","title":"0.32.1 - 2023-07-15","text":"<p>Compare with 0.32.0</p>"},{"location":"changelog/#bug-fixes_5","title":"Bug Fixes","text":"<ul> <li>Fix aliases for direct nested imports (e9867f7 by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/python#32</li> </ul>"},{"location":"changelog/#code-refactoring_6","title":"Code Refactoring","text":"<ul> <li>Simplify AST imports, stop using deprecated code from <code>ast</code> (21d5832 by Timoth\u00e9e Mazzucotelli). Issue #179</li> </ul>"},{"location":"changelog/#0320-2023-07-13","title":"0.32.0 - 2023-07-13","text":"<p>Compare with 0.31.0</p>"},{"location":"changelog/#deprecations","title":"Deprecations","text":"<ul> <li>Classes <code>InspectorExtension</code>     and <code>VisitorExtension</code>     are deprecated in favor of <code>Extension</code>.     As a side-effect, the <code>hybrid</code> extension     is also deprecated. See how to use and write extensions.</li> </ul>"},{"location":"changelog/#breaking-changes_1","title":"Breaking Changes","text":"<ul> <li>Module <code>griffe.agents.base</code> was removed</li> <li>Module <code>griffe.docstrings.markdown</code> was removed</li> <li>Class <code>ASTNode</code> was removed</li> <li>Class <code>BaseInspector</code> was removed</li> <li>Class <code>BaseVisitor</code> was removed</li> <li>Fucntion <code>get_parameter_default</code> was removed</li> <li>Function <code>load_extension</code> was removed (made private)</li> <li>Function <code>patch_ast</code> was removed</li> <li>Function <code>tmp_worktree</code> was removed (made private)</li> <li>Type <code>Extension</code> is now a class</li> </ul>"},{"location":"changelog/#features_4","title":"Features","text":"<ul> <li>Numpy parser: handle return section items with just type, or no name and no type (bdec37d by Michael Chow). Issue #173, PR #174, Co-authored-by: Timoth\u00e9e Mazzucotelli pawamoy@pm.me</li> <li>Rework extension system (dea4c83 by Timoth\u00e9e Mazzucotelli).</li> <li>Parse attribute values, parameter defaults and decorators as expressions (7b653b3 by Timoth\u00e9e Mazzucotelli).</li> <li>Add loader option to avoid storing source code, reducing memory footprint (d592edf by Timoth\u00e9e Mazzucotelli).</li> <li>Add <code>extra</code> attribute to objects (707a348 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#bug-fixes_6","title":"Bug Fixes","text":"<ul> <li>Numpy-style: don't strip spaces from the left of indented lines (f13fc0a by Timoth\u00e9e Mazzucotelli). Discussion #587</li> <li>Fix relative paths for old versions when checking API (96fd45b by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#performance-improvements","title":"Performance Improvements","text":"<ul> <li>Don't store source when dumping as JSON (d7f314a by Timoth\u00e9e Mazzucotelli).</li> <li>Stop caching properties on Object methods (15bdd74 by Timoth\u00e9e Mazzucotelli).</li> <li>Stop patching AST, use functions instead (7302f17 by Timoth\u00e9e Mazzucotelli). Issue #171</li> </ul>"},{"location":"changelog/#code-refactoring_7","title":"Code Refactoring","text":"<ul> <li>Privatize/remove objects (fdeb16f by Timoth\u00e9e Mazzucotelli).</li> <li>Document public objects with <code>__all__</code> (db0e0e3 by Timoth\u00e9e Mazzucotelli).</li> <li>Remove base visitor and inspector (bc446e4 by Timoth\u00e9e Mazzucotelli).</li> <li>Auto-register module in collection within loading helpers (591bacc by Timoth\u00e9e Mazzucotelli). Issue #177</li> </ul>"},{"location":"changelog/#0310-2023-07-04","title":"0.31.0 - 2023-07-04","text":"<p>Compare with 0.30.1</p>"},{"location":"changelog/#breaking-changes_2","title":"Breaking Changes","text":"<ul> <li>Drop support for Python 3.7</li> <li>API changes:<ul> <li><code>GriffeLoader.resolve_aliases(only_exported)</code>: Deprecated parameter was removed and replaced by <code>implicit</code> (inverse semantics)</li> <li><code>GriffeLoader.resolve_aliases(only_known_modules)</code>: Deprecated parameter was removed and replaced by <code>external</code> (inverse semantics)</li> <li><code>LinesCollection.tokens</code>: Public object was removed (Python 3.7)</li> <li><code>ASTNode.end_lineno</code>: Public object was removed (Python 3.7)</li> <li><code>griffe.agents.extensions</code> Deprecated module was removed and replaced by <code>griffe.extensions</code></li> </ul> </li> </ul>"},{"location":"changelog/#features_5","title":"Features","text":"<ul> <li>Add <code>--color</code>, <code>--no-color</code> options to check subcommand (eac783c by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#bug-fixes_7","title":"Bug Fixes","text":"<ul> <li>Report removed public modules (68906cb by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_8","title":"Code Refactoring","text":"<ul> <li>Improve check output (6b0a1f0 by Timoth\u00e9e Mazzucotelli).</li> <li>Remove deprecated <code>griffe.agents.extensions</code> module (b555c78 by Timoth\u00e9e Mazzucotelli).</li> <li>Remove deprecated parameters from loader's <code>resolve_aliases</code> method (dd98acd by Timoth\u00e9e Mazzucotelli).</li> <li>Drop Python 3.7 support (e4be30a by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0301-2023-07-02","title":"0.30.1 - 2023-07-02","text":"<p>Compare with 0.30.0</p>"},{"location":"changelog/#bug-fixes_8","title":"Bug Fixes","text":"<ul> <li>Prevent duplicate yields of breaking changes (9edef90 by Timoth\u00e9e Mazzucotelli). Issue #162</li> <li>Prevent alias resolution errors when checking for API breaking changes (93c964a by Timoth\u00e9e Mazzucotelli). Issue #145</li> <li>Handle Git errors when checking for API breaking changes (f9e8ba3 by Timoth\u00e9e Mazzucotelli). Issue #144</li> </ul>"},{"location":"changelog/#code-refactoring_9","title":"Code Refactoring","text":"<ul> <li>Force remove worktree branch when done checking (45332ba by Timoth\u00e9e Mazzucotelli).</li> <li>Change command to obtain latest tag (f70f630 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0300-2023-06-30","title":"0.30.0 - 2023-06-30","text":"<p>Compare with 0.29.1</p>"},{"location":"changelog/#features_6","title":"Features","text":"<ul> <li>Add <code>allow_section_blank_line</code> option to the Numpy parser (245845e by Michael Chow). Issue #167, PR #168</li> <li>Support inheritance (08bbe09 by Timoth\u00e9e Mazzucotelli). PR #170</li> </ul>"},{"location":"changelog/#bug-fixes_9","title":"Bug Fixes","text":"<ul> <li>Handle semi-colons in pth files (e2ec661 by Michael Chow). Issue #172, PR #175</li> </ul>"},{"location":"changelog/#code-refactoring_10","title":"Code Refactoring","text":"<ul> <li>Split members API in two parts: producer and consumer (2269449 by Timoth\u00e9e Mazzucotelli). PR #170</li> </ul>"},{"location":"changelog/#0291-2023-06-19","title":"0.29.1 - 2023-06-19","text":"<p>Compare with 0.29.0</p>"},{"location":"changelog/#bug-fixes_10","title":"Bug Fixes","text":"<ul> <li>Fix detection of optional and default in Numpydoc-style parameters (3509106 by Timoth\u00e9e Mazzucotelli). Issue #165</li> <li>Fallback to string literal when parsing fails with syntax error (53827c8 by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/python#80</li> <li>Don't mutate finder's import paths (a9e025a by Timoth\u00e9e Mazzucotelli).</li> <li>Respect <code>external</code> when expanding wildcards (8ef92c8 by Timoth\u00e9e Mazzucotelli).</li> <li>Extract actual type for yielded/received values (3ea37ba by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/python#75</li> </ul>"},{"location":"changelog/#code-refactoring_11","title":"Code Refactoring","text":"<ul> <li>Improve error handling when importing a module (a732e21 by Timoth\u00e9e Mazzucotelli).</li> <li>Improve tests helpers (accept all visit/inspection parameters) (6da5869 by Timoth\u00e9e Mazzucotelli).</li> <li>Allow passing a modules collection to the inspector, for consistency with the visitor (5f73a28 by Timoth\u00e9e Mazzucotelli).</li> <li>Always add import path of module to inspect when it has a file path (4021e6f by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0290-2023-05-26","title":"0.29.0 - 2023-05-26","text":"<p>Compare with 0.28.2</p>"},{"location":"changelog/#features_7","title":"Features","text":"<ul> <li>Provide test helpers and pytest fixtures (611ed58 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0282-2023-05-24","title":"0.28.2 - 2023-05-24","text":"<p>Compare with 0.28.1</p>"},{"location":"changelog/#bug-fixes_11","title":"Bug Fixes","text":"<ul> <li>Correctly resolve full expressions (fa57f4f by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/autorefs#23</li> <li>Use <code>full</code> attribute instead of <code>canonical</code> for expressions (4338ccc by Michael Chow). Issue #163, PR #164</li> </ul>"},{"location":"changelog/#0281-2023-05-22","title":"0.28.1 - 2023-05-22","text":"<p>Compare with 0.28.0</p>"},{"location":"changelog/#bug-fixes_12","title":"Bug Fixes","text":"<ul> <li>Return docstring warnings as warnings, not attributes (7bd51ba by Matthew Anderson). PR #161</li> </ul>"},{"location":"changelog/#code-refactoring_12","title":"Code Refactoring","text":"<ul> <li>Refactor AST nodes parsers (7e53127 by Timoth\u00e9e Mazzucotelli). Issue #160</li> <li>Full expressions use canonical names (65c7184 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0280-2023-05-17","title":"0.28.0 - 2023-05-17","text":"<p>Compare with 0.27.5</p>"},{"location":"changelog/#features_8","title":"Features","text":"<ul> <li>Support scikit-build-core editable modules (partially) (eb64779 by Timoth\u00e9e Mazzucotelli). Issue #154</li> </ul>"},{"location":"changelog/#bug-fixes_13","title":"Bug Fixes","text":"<ul> <li>Parse complex, stringified annotations (f743616 by Timoth\u00e9e Mazzucotelli). Issue #159</li> </ul>"},{"location":"changelog/#0275-2023-05-12","title":"0.27.5 - 2023-05-12","text":"<p>Compare with 0.27.4</p>"},{"location":"changelog/#code-refactoring_13","title":"Code Refactoring","text":"<ul> <li>Represent function using their names when inspecting default values (9116c1f by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#180</li> </ul>"},{"location":"changelog/#0274-2023-05-10","title":"0.27.4 - 2023-05-10","text":"<p>Compare with 0.27.3</p>"},{"location":"changelog/#bug-fixes_14","title":"Bug Fixes","text":"<ul> <li>Don't recurse through targets, get directly to final target and handle alias-related errors (c5bc197 by Timoth\u00e9e Mazzucotelli). Issue #155</li> </ul>"},{"location":"changelog/#code-refactoring_14","title":"Code Refactoring","text":"<ul> <li>Follow <code>.pth</code> files to extend search paths with editable modules (79bf724 by Timoth\u00e9e Mazzucotelli). Issue #154</li> <li>Add default values to <code>_load_packages</code> helper (f104c20 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0273-2023-05-05","title":"0.27.3 - 2023-05-05","text":"<p>Compare with 0.27.2</p>"},{"location":"changelog/#bug-fixes_15","title":"Bug Fixes","text":"<ul> <li>Allow setting doctring through alias (2e0f553 by Timoth\u00e9e Mazzucotelli).</li> <li>Prevent infinite recursion (0e98546 by Timoth\u00e9e Mazzucotelli). Issue #155</li> </ul>"},{"location":"changelog/#0272-2023-05-03","title":"0.27.2 - 2023-05-03","text":"<p>Compare with 0.27.1</p>"},{"location":"changelog/#dependencies","title":"Dependencies","text":"<ul> <li>Remove async extra (aiofiles) (70d9b93 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#bug-fixes_16","title":"Bug Fixes","text":"<ul> <li>Support walrus operator (bf721f4 by Timoth\u00e9e Mazzucotelli). Issue #152</li> <li>Respect <code>ClassVar</code> annotation (60e01c1 by Victor Westerhuis). PR #150, Co-authored-by: Timoth\u00e9e Mazzucotelli pawamoy@pm.me</li> <li>Add missing \"other args\" section aliases (f5c0a0e by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_15","title":"Code Refactoring","text":"<ul> <li>Move utils from cli to respective modules (c6ce49e by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0271-2023-04-16","title":"0.27.1 - 2023-04-16","text":"<p>Compare with 0.27.0</p>"},{"location":"changelog/#bug-fixes_17","title":"Bug Fixes","text":"<ul> <li>Actually parse warnings sections (bc00da5 by Timoth\u00e9e Mazzucotelli).</li> <li>Allow Raises and Warns items to start with a newline (f3b088c by Victor Westerhuis). PR #149, Co-authored-by: Timoth\u00e9e Mazzucotelli pawamoy@pm.me</li> </ul>"},{"location":"changelog/#0270-2023-04-10","title":"0.27.0 - 2023-04-10","text":"<p>Compare with 0.26.0</p>"},{"location":"changelog/#features_9","title":"Features","text":"<ul> <li>Implement basic handling of Alias for breaking changes (aa8ce00 by Yurii). PR #140, Co-authored-by: Timoth\u00e9e Mazzucotelli pawamoy@pm.me</li> </ul>"},{"location":"changelog/#bug-fixes_18","title":"Bug Fixes","text":"<ul> <li>Support <code>Literal</code> imported from <code>typing_extensions</code> (3a16e58 by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#545</li> <li>Fix parameter default checking logic and diff tests (1b940fd by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0260-2023-04-03","title":"0.26.0 - 2023-04-03","text":"<p>Compare with 0.25.5</p>"},{"location":"changelog/#breaking-changes_3","title":"Breaking changes","text":"<ul> <li><code>AliasResolutionError</code> instances don't have a <code>target_path</code> attribute anymore.     It is instead replaced by an <code>alias</code> attribute which is a reference to an <code>Alias</code> instance.</li> <li>Lots of positional-or-keyword parameters were changed to keyword-only parameters.</li> </ul>"},{"location":"changelog/#deprecations_1","title":"Deprecations","text":"<ul> <li>The <code>griffe.agents.extensions</code> module was moved to <code>griffe.extensions</code>.     The old path is deprecated.</li> </ul>"},{"location":"changelog/#features_10","title":"Features","text":"<ul> <li>Support newer versions of <code>editables</code> (ab7a3be by Timoth\u00e9e Mazzucotelli): the names of editable modules have changed from <code>__editables_*</code> to <code>_editable_impl_*</code>.</li> <li>Provide a JSON schema (7dfed39 by Timoth\u00e9e Mazzucotelli).</li> <li>Allow hybrid extension to filter objects and run multiple inspectors (f8ff53a by Timoth\u00e9e Mazzucotelli).</li> <li>Allow loading extension from file path (131454e by Timoth\u00e9e Mazzucotelli).</li> <li>Add back <code>relative_filepath</code> which now really returns the filepath relative to the current working directory (40fe0c5 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#bug-fixes_19","title":"Bug Fixes","text":"<ul> <li>Fix JSON schema for ending line numbers (and add test) (318c6b4 by Timoth\u00e9e Mazzucotelli).</li> <li>Prevent cyclic aliases by not overwriting a module member with an indirect alias to itself (c188a95 by Timoth\u00e9e Mazzucotelli). Issue #122</li> <li>Prevent alias resolution errors when copying docstring or labels from previously existing attribute (48747b6 by Timoth\u00e9e Mazzucotelli).</li> <li>Fix Google admonition regular expression (ef0be5f by Timoth\u00e9e Mazzucotelli).</li> <li>Add back <code>griffe.agents.extensions</code> module (deprecated) (7129477 by Timoth\u00e9e Mazzucotelli).</li> <li>Forward class attribute docstrings to instances (7bf4952 by Rodrigo Gir\u00e3o Serr\u00e3o). Issue #128, PR #135</li> <li>Prevent errors related to getting attributes in the inspector (5d15d27 by Timoth\u00e9e Mazzucotelli).</li> <li>Catch \"member does not exist\" errors while expanding wildcards (a966022 by Timoth\u00e9e Mazzucotelli).</li> <li>Catch more inspection errors (4f6eef9 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_16","title":"Code Refactoring","text":"<ul> <li>Log final path after resolving alias (c7ec7f7 by Timoth\u00e9e Mazzucotelli).</li> <li>Move extensions one level up (67ebd71 by Timoth\u00e9e Mazzucotelli).</li> <li>Set default <code>when</code> value on extension base classes (e8ad889 by Timoth\u00e9e Mazzucotelli).</li> <li>Rename <code>relative_filepath</code> to <code>relative_package_filepath</code> to better express what it does (6148f85 by Timoth\u00e9e Mazzucotelli).</li> <li>Show file name and line number in alias resolution error messages (c48928d by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0255-2023-02-16","title":"0.25.5 - 2023-02-16","text":"<p>Compare with 0.25.4</p>"},{"location":"changelog/#bug-fixes_20","title":"Bug Fixes","text":"<ul> <li>Fix parsing empty lines with indentation in Google docstrings (705edff by Timoth\u00e9e Mazzucotelli). Issue #129</li> </ul>"},{"location":"changelog/#0254-2023-01-19","title":"0.25.4 - 2023-01-19","text":"<p>Compare with 0.25.3</p>"},{"location":"changelog/#bug-fixes_21","title":"Bug Fixes","text":"<ul> <li>Fix creation of aliases to modules when inspecting (54242cb by Timoth\u00e9e Mazzucotelli).</li> <li>Support (setuptools) editable packages with multiple roots (bd37dfb by Gilad). PR #126</li> </ul>"},{"location":"changelog/#0253-2023-01-04","title":"0.25.3 - 2023-01-04","text":"<p>Compare with 0.25.2</p>"},{"location":"changelog/#bug-fixes_22","title":"Bug Fixes","text":"<ul> <li>Fix parsing of annotations in Numpy attributes sections (18fa396 by Timoth\u00e9e Mazzucotelli). Issue #72</li> </ul>"},{"location":"changelog/#0252-2022-12-24","title":"0.25.2 - 2022-12-24","text":"<p>Compare with 0.25.1</p>"},{"location":"changelog/#bug-fixes_23","title":"Bug Fixes","text":"<ul> <li>Make sure passage through aliases is reset (79733f4 by Timoth\u00e9e Mazzucotelli). Issue #123</li> <li>Ignore cyclic alias errors when updating target aliases (bb62b2f by Timoth\u00e9e Mazzucotelli). Issue #123</li> </ul>"},{"location":"changelog/#0251-2022-12-20","title":"0.25.1 - 2022-12-20","text":"<p>Compare with 0.25.0</p>"},{"location":"changelog/#bug-fixes_24","title":"Bug Fixes","text":"<ul> <li>Pass through aliases earlier to prevent infinite recursion (e533f29 by Timoth\u00e9e Mazzucotelli). Issue #83, #122</li> </ul>"},{"location":"changelog/#0250-2022-12-11","title":"0.25.0 - 2022-12-11","text":"<p>Compare with 0.24.1</p>"},{"location":"changelog/#breaking-changes_4","title":"Breaking changes","text":"<ul> <li>Parameter <code>only_known_modules</code> was renamed <code>external</code> in the <code>expand_wildcards()</code> method of the loader.</li> <li>Exception <code>UnhandledEditablesModuleError</code> was renamed <code>UnhandledEditableModuleError</code> since we now support editable installation from other packages than <code>editables</code>.</li> </ul>"},{"location":"changelog/#highlights","title":"Highlights","text":"<ul> <li>Properties are now fetched as attributes rather than functions, since that is how they are used. This was asked by users, and since Griffe generates signatures for Python APIs (emphasis on APIs), it makes sense to return data that matches the interface provided to users. Such property objects in Griffe's output will still have the associated <code>property</code> labels of course.</li> <li>Lots of bug fixes. These bugs were discovered by running Griffe on many major packages as well as the standard library (again). Particularly, alias resolution should be more robust now, and should generate less issues like cyclic aliases, meaning indirect/wildcard imports should be better understood. We still highly discourage the use of wilcard imports </li> </ul>"},{"location":"changelog/#features_11","title":"Features","text":"<ul> <li>Support <code>setuptools</code> editable modules (abc18f7 by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#463</li> <li>Support merging stubs on wildcard imported objects (0ed9c36 by Timoth\u00e9e Mazzucotelli). Issue #116</li> </ul>"},{"location":"changelog/#bug-fixes_25","title":"Bug Fixes","text":"<ul> <li>Prevent cyclic alias creation when expanding wildcards (a77e4e8 by Timoth\u00e9e Mazzucotelli).</li> <li>Don't crash and show hint when wildcard expansion fails (336faf6 by Timoth\u00e9e Mazzucotelli).</li> <li>Register top module after inspection (86454ec by Timoth\u00e9e Mazzucotelli).</li> <li>Set alias attributes early (2ac1a9b by Timoth\u00e9e Mazzucotelli).</li> <li>Allow writing attributes on aliases (c8f736e by Timoth\u00e9e Mazzucotelli).</li> <li>Don't crash on inspection of functions signatures (051e337 by Timoth\u00e9e Mazzucotelli).</li> <li>Don't crash on inspection of method descriptors' docstrings (09571bb by Timoth\u00e9e Mazzucotelli).</li> <li>Fix stats computing (handle stubs and namespace packages) (a81f8dc by Timoth\u00e9e Mazzucotelli).</li> <li>Support documenting multiple items for optional tuples (727456d by Timoth\u00e9e Mazzucotelli). Issue #117</li> <li>Fix comparing names with strings (37ae0a2 by Timoth\u00e9e Mazzucotelli). Issue #114</li> <li>Fix deepcopy crashing because of <code>__getattr__</code> (11b023b by Timoth\u00e9e Mazzucotelli). Issue #73, PR #119</li> </ul>"},{"location":"changelog/#code-refactoring_17","title":"Code Refactoring","text":"<ul> <li>Prevent reloading of failed modules (8ef14ab by Timoth\u00e9e Mazzucotelli).</li> <li>Rename <code>only_known_modules</code> parameter to <code>external</code> (5f816c6 by Timoth\u00e9e Mazzucotelli).</li> <li>Rework alias creation decision in the inspector (f434943 by Timoth\u00e9e Mazzucotelli).</li> <li>Resolve alias chain recursively (6cdd3b2 by Timoth\u00e9e Mazzucotelli).</li> <li>Don't try to stubs-merge identical modules (7099971 by Timoth\u00e9e Mazzucotelli).</li> <li>Load properties as attributes (5c97a45 by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/python#9</li> <li>Use a cyclic relationship map for inspection (9a2a711 by Timoth\u00e9e Mazzucotelli). PR #115</li> </ul>"},{"location":"changelog/#0241-2022-11-18","title":"0.24.1 - 2022-11-18","text":"<p>Compare with 0.24.0</p>"},{"location":"changelog/#bug-fixes_26","title":"Bug Fixes","text":"<ul> <li>Support nested namespace packages (d571f8f by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0240-2022-11-13","title":"0.24.0 - 2022-11-13","text":"<p>Compare with 0.23.0</p> <p>The \"Breaking Changes\" and \"Deprecations\" sections are proudly written with the help of our new API breakage detection feature ! Many thanks to Talley Lambert (@tlambert03) for the initial code allowing to compare two Griffe trees.</p>"},{"location":"changelog/#breaking-changes_5","title":"Breaking changes","text":"<ul> <li>All parameters of the <code>load_git</code> function, except <code>module</code>, are now keyword-only.</li> <li>Parameter <code>try_relative_path</code> of the <code>load_git</code> function was removed.</li> <li>Parameter <code>commit</code> was renamed <code>ref</code> in the <code>load_git</code> function.</li> <li>Parameter <code>commit</code> was renamed <code>ref</code> in the <code>tmp_worktree</code> helper, which will probably become private later.</li> <li>Parameters <code>ref</code> and <code>repo</code> switched positions in the <code>tmp_worktree</code> helper.</li> <li>All parameters of the <code>resolve_aliases</code> method are now keyword-only.</li> <li>Parameters <code>only_exported</code> and <code>only_known_modules</code> of the <code>resolve_module_aliases</code>     method were removed. This method is most probably not used by anyone, and will probably be made private in the future.</li> </ul>"},{"location":"changelog/#deprecations_2","title":"Deprecations","text":"<ul> <li> <p>Parameters <code>only_exported</code> and <code>only_known_modules</code> of the <code>resolve_aliases</code>     method are deprecated in favor of their inverted counter-part <code>implicit</code> and <code>external</code> parameters.</p> <ul> <li>Example before: <code>loader.resolve_aliases(only_exported=True, only_known_modules=True)</code></li> <li>Example after: <code>loader.resolve_aliases(implicit=False, external=False)</code></li> </ul> </li> </ul>"},{"location":"changelog/#features_12","title":"Features","text":"<ul> <li>Add CLI command to check for API breakages (90bded4 by Timoth\u00e9e Mazzucotelli). Issue #75, PR #105</li> <li>Add function to find API breaking changes (a4f1280 by Talley Lambert and Timoth\u00e9e Mazzucotelli). Issue #75, PR #105</li> </ul>"},{"location":"changelog/#bug-fixes_27","title":"Bug Fixes","text":"<ul> <li>Fix labels mismatch staticmethod-classmethod in inspector (25060f6 by Timoth\u00e9e Mazzucotelli). Issue #111</li> <li>Prevent infinite loop while looking for package's parent folder (f297f1a by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#72</li> <li>Fix comparing names and expressions (07bffff by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_18","title":"Code Refactoring","text":"<ul> <li>Rename some parameters in Git module (9ad7a2c by Timoth\u00e9e Mazzucotelli).</li> <li>Set parameters as keyword-only (44c01be by Timoth\u00e9e Mazzucotelli).</li> <li>Remove stars from parameters names (91dce14 by Timoth\u00e9e Mazzucotelli).</li> <li>Refactor CLI to use subcommands (760b091 by Timoth\u00e9e Mazzucotelli). PR #110</li> <li>Rename parameters used when resolving aliases (3d3a4eb by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0230-2022-10-26","title":"0.23.0 - 2022-10-26","text":"<p>Compare with 0.22.2</p>"},{"location":"changelog/#features_13","title":"Features","text":"<ul> <li>Support <code>typing_extensions.overload</code> (c29fad5 by Nyuan Zhang). PR #108</li> </ul>"},{"location":"changelog/#bug-fixes_28","title":"Bug Fixes","text":"<ul> <li>Log debug instead of errors when failing to parse NumPy annotations for additional sections (568ff60 by Sigurd Spieckermann). Issue #93, PR #109</li> <li>Don't strip too many parentheses around a call node (bb5c5e7 by Timoth\u00e9e Mazzucotelli). PR #107</li> <li>Guard against more alias resolution errors (2be135d by Timoth\u00e9e Mazzucotelli). Issue #83, PR #103</li> </ul>"},{"location":"changelog/#0222-2022-09-24","title":"0.22.2 - 2022-09-24","text":"<p>Compare with 0.22.1</p>"},{"location":"changelog/#bug-fixes_29","title":"Bug Fixes","text":"<ul> <li>Log debug instead of errors when failing to parse Numpy annotations (75eeeda by Timoth\u00e9e Mazzucotelli). Issue #93</li> <li>Don't crash on unsupported module names (containing dots) (6a57194 by Timoth\u00e9e Mazzucotelli). Issue #94</li> <li>Show correct docstring line numbers on Python 3.7 (edd4b6d by Timoth\u00e9e Mazzucotelli). Issue #98</li> <li>Fix parsing of Numpy docstring with an Examples section at the end (3114727 by Timoth\u00e9e Mazzucotelli). Issue #97</li> <li>Don't crash on unsupported item in <code>__all__</code> (log a warning instead) (9e5df0a by Timoth\u00e9e Mazzucotelli). Issue #92</li> <li>Prevent infinite recursion while expanding exports (68446f7 by Timoth\u00e9e Mazzucotelli).</li> <li>Add missing check while expanding wildcards (7e816ed by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0221-2022-09-10","title":"0.22.1 - 2022-09-10","text":"<p>Compare with 0.22.0</p>"},{"location":"changelog/#bug-fixes_30","title":"Bug Fixes","text":"<ul> <li>Always use <code>encoding=\"utf8\"</code> when reading text files (3b279bf by Rudolf Byker). Issue #99, PR #100</li> </ul>"},{"location":"changelog/#0220-2022-06-28","title":"0.22.0 - 2022-06-28","text":"<p>Compare with 0.21.0</p>"},{"location":"changelog/#features_14","title":"Features","text":"<ul> <li>Support forward references (245daea by Timoth\u00e9e Mazzucotelli). Issue #86</li> </ul>"},{"location":"changelog/#code-refactoring_19","title":"Code Refactoring","text":"<ul> <li>Safely parse annotations and values (b023e2b by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0210-2022-06-25","title":"0.21.0 - 2022-06-25","text":"<p>Compare with 0.20.0</p>"},{"location":"changelog/#features_15","title":"Features","text":"<ul> <li>Add <code>load_git</code> function allowing to load data from a specific git ref (b2c3946 by Talley Lambert). Issue #75, PR #76</li> </ul>"},{"location":"changelog/#bug-fixes_31","title":"Bug Fixes","text":"<ul> <li>Fix detecting and merging stubs for single-file packages (6a82542 by Talley Lambert). Issue #77, PR #78</li> <li>Fix parsing ExtSlice nodes when getting values (b2fe968 by Timoth\u00e9e Mazzucotelli). Issue #87</li> <li>Don't trigger alias resolution when merging stubs (2b88627 by Timoth\u00e9e Mazzucotelli). Issue #89</li> <li>Fix handling of .pth files (f212dd3 by Gabriel Dugny). Issue #84, PR #85</li> </ul>"},{"location":"changelog/#0200-2022-06-03","title":"0.20.0 - 2022-06-03","text":"<p>Compare with 0.19.3</p>"},{"location":"changelog/#features_16","title":"Features","text":"<ul> <li>Add <code>as_json</code> and <code>from_json</code> convenience methods on objects (5c3d751 by Talley Lambert). PR #74</li> </ul>"},{"location":"changelog/#bug-fixes_32","title":"Bug Fixes","text":"<ul> <li>Fix unparsing of f-strings (9ca74bd by Timoth\u00e9e Mazzucotelli). Issue #80</li> <li>Don't crash when overwriting a submodule with a wildcard imported attribute (bfad1cc by Timoth\u00e9e Mazzucotelli). Issue #72, #79, mkdocstrings/mkdocstrings#438</li> </ul>"},{"location":"changelog/#0193-2022-05-26","title":"0.19.3 - 2022-05-26","text":"<p>Compare with 0.19.2</p>"},{"location":"changelog/#bug-fixes_33","title":"Bug Fixes","text":"<ul> <li>Support USub and UAdd nodes in annotations (1169c51 by Timoth\u00e9e Mazzucotelli). Issue #71</li> </ul>"},{"location":"changelog/#0192-2022-05-18","title":"0.19.2 - 2022-05-18","text":"<p>Compare with 0.19.1</p>"},{"location":"changelog/#bug-fixes_34","title":"Bug Fixes","text":"<ul> <li>Don't crash on single line docstrings with trailing whitespace (Google) (8d9ccd5 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0191-2022-05-07","title":"0.19.1 - 2022-05-07","text":"<p>Compare with 0.19.0</p>"},{"location":"changelog/#bug-fixes_35","title":"Bug Fixes","text":"<ul> <li>Don't crash on nested functions in <code>__init__</code> methods (cd5af43 by Timoth\u00e9e Mazzucotelli). Issue #68</li> </ul>"},{"location":"changelog/#0190-2022-05-06","title":"0.19.0 - 2022-05-06","text":"<p>Compare with 0.18.0</p>"},{"location":"changelog/#features_17","title":"Features","text":"<ul> <li>Add <code>load</code> shortcut function for convenience (f38a42d by Timoth\u00e9e Mazzucotelli).</li> <li>Support loading (and merging) <code>*.pyi</code> files (41518f4 by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#404</li> <li>Improve support for call nodes in annotations (45e5bf5 by Timoth\u00e9e Mazzucotelli). Issue #66</li> <li>Support <code>dataclass</code> decorators on classes (f579431 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_20","title":"Code Refactoring","text":"<ul> <li>Handle absence of values (190585d by Timoth\u00e9e Mazzucotelli).</li> <li>Simplify decorators to labels function (04e768f by Timoth\u00e9e Mazzucotelli).</li> <li>Always sort labels when serializing (bd2504b by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0180-2022-04-19","title":"0.18.0 - 2022-04-19","text":"<p>Compare with 0.17.0</p>"},{"location":"changelog/#features_18","title":"Features","text":"<ul> <li>Add CLI option to disallow inspection (8f71a07 by Timoth\u00e9e Mazzucotelli).</li> <li>Support complex <code>__all__</code> assignments (9a2128b by Timoth\u00e9e Mazzucotelli). Issue #40</li> <li>Inherit class parameters from <code>__init__</code> method (e195593 by Fran\u00e7ois Rozet). Issue mkdocstrings/python#19, PR #65.   It allows to write \"Parameters\" sections in the docstring of the class itself.</li> </ul>"},{"location":"changelog/#performance-improvements_1","title":"Performance Improvements","text":"<ul> <li>Avoid using <code>__len__</code> as boolean method (d465493 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#bug-fixes_36","title":"Bug Fixes","text":"<ul> <li>Don't crash on unhandle <code>__all__</code> assignments (cbc103c by Timoth\u00e9e Mazzucotelli).</li> <li>Handle empty packages names in CLI (52b51c4 by Timoth\u00e9e Mazzucotelli).</li> <li>Don't crash on Google parameters sections found in non-function docstrings (4a417bc by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/python#19</li> </ul>"},{"location":"changelog/#code-refactoring_21","title":"Code Refactoring","text":"<ul> <li>Improve \"unknown parameter\" messages (7191799 by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#423</li> <li>Set property label on <code>@cached_property</code>-decoratored methods (bc068f8 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0170-2022-04-15","title":"0.17.0 - 2022-04-15","text":"<p>Compare with 0.16.0</p>"},{"location":"changelog/#features_19","title":"Features","text":"<ul> <li>Handle properties setters and deleters (50a4490 by Timoth\u00e9e Mazzucotelli).</li> <li>Handle <code>typing.overload</code> decorator (927bbd9 by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#308</li> <li>Set labels on functions using decorators (1c1feb2 by Timoth\u00e9e Mazzucotelli). Issue #47</li> <li>Add <code>runtime</code> attribute to objects/aliases and handle type guarded objects (2f2a04e by Timoth\u00e9e Mazzucotelli). Issue #42</li> <li>Support pkg-style namespace packages (efba0c6 by Timoth\u00e9e Mazzucotelli). Issue #58</li> </ul>"},{"location":"changelog/#code-refactoring_22","title":"Code Refactoring","text":"<ul> <li>Remove useless attribute (c4a92b7 by Timoth\u00e9e Mazzucotelli).</li> <li>Improve Google warnings (641089a by Timoth\u00e9e Mazzucotelli).</li> <li>Remove useless import nodes generic visits (f83fc8e by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0160-2022-04-09","title":"0.16.0 - 2022-04-09","text":"<p>Compare with 0.15.1</p>"},{"location":"changelog/#features_20","title":"Features","text":"<ul> <li>Warn about unknown parameters in Numpy docstrings (23f63f2 by Timoth\u00e9e Mazzucotelli).</li> <li>Warn about unknown parameters in Google docstrings (72be993 by Kevin Musgrave). Issue mkdocstrings/mkdocstrings#408, PR #63</li> </ul>"},{"location":"changelog/#bug-fixes_37","title":"Bug Fixes","text":"<ul> <li>Don't crash on unhandled AST nodes while parsing text annotations (f3be3a6 by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#416</li> </ul>"},{"location":"changelog/#0151-2022-04-08","title":"0.15.1 - 2022-04-08","text":"<p>Compare with 0.15.0</p>"},{"location":"changelog/#bug-fixes_38","title":"Bug Fixes","text":"<ul> <li>Don't overwrite existing (lower) members when expanding wildcards (9ff86e3 by Timoth\u00e9e Mazzucotelli).</li> <li>Don't insert admonition before current section (Google parser) (8d8a46f by Timoth\u00e9e Mazzucotelli).</li> <li>Handle aliases chains in <code>has_docstrings</code> method (77c6943 by Timoth\u00e9e Mazzucotelli).</li> <li>Actually check for docstrings recursively (15f4193 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0150-2022-04-03","title":"0.15.0 - 2022-04-03","text":"<p>Compare with 0.14.1</p>"},{"location":"changelog/#features_21","title":"Features","text":"<ul> <li>Support <code>ignore_init_summary</code> in Numpy parser (f8cd147 by Timoth\u00e9e Mazzucotelli). Issue #44</li> <li>Enable cross-references for Numpy docstrings annotations (e32a73c by Timoth\u00e9e Mazzucotelli). Issues #11, #12, #13, #14, #15, #16, #17, #18</li> <li>Retrieve annotations from parent in Numpy parser (8d4eae3 by Timoth\u00e9e Mazzucotelli). Issues #29, #30, #31, #32</li> <li>Parse annotations in Iterator/Generator for Google docstrings (f0129ef by Timoth\u00e9e Mazzucotelli). Issue #28</li> </ul>"},{"location":"changelog/#bug-fixes_39","title":"Bug Fixes","text":"<ul> <li>Fix missing \"receives\" entry in Google parser (35d63fb by Timoth\u00e9e Mazzucotelli).</li> <li>Fix serialization of Windows paths (b7e8da8 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_23","title":"Code Refactoring","text":"<ul> <li>Be less strict on spacing around \":\" in Numpy docstrings (aa592b5 by Timoth\u00e9e Mazzucotelli).</li> <li>Be less strict in Numpy regular expressions (603dc0e by Timoth\u00e9e Mazzucotelli).</li> <li>Rename variables in Numpy module (4407244 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0141-2022-04-01","title":"0.14.1 - 2022-04-01","text":"<p>Compare with 0.14.0</p>"},{"location":"changelog/#bug-fixes_40","title":"Bug Fixes","text":"<ul> <li>Retrieve default value for non-string parameters (15952ed by ThomasPJ). Issue #59, issue mkdocstrings/python#8, PR #60</li> <li>Prevent infinite recursion while expanding wildcards (428628f by Timoth\u00e9e Mazzucotelli). Issue #57</li> </ul>"},{"location":"changelog/#0140-2022-03-06","title":"0.14.0 - 2022-03-06","text":"<p>Compare with 0.13.2</p>"},{"location":"changelog/#features_22","title":"Features","text":"<ul> <li>Ignore <code>__doc__</code> from parent classes (10aa59e by Will Da Silva). Issue #55, PR #56</li> </ul>"},{"location":"changelog/#0132-2022-03-01","title":"0.13.2 - 2022-03-01","text":"<p>Compare with 0.13.1</p>"},{"location":"changelog/#bug-fixes_41","title":"Bug Fixes","text":"<ul> <li>Fix type regex in Numpy parser (3a10fda by Timoth\u00e9e Mazzucotelli).</li> <li>Current module must not be available in its members' scope (54f9688 by Timoth\u00e9e Mazzucotelli).</li> <li>Allow named sections after numpydoc examples (a44d9c6 by Lucina). PR #54</li> </ul>"},{"location":"changelog/#0131-2022-02-24","title":"0.13.1 - 2022-02-24","text":"<p>Compare with 0.13.0</p>"},{"location":"changelog/#bug-fixes_42","title":"Bug Fixes","text":"<ul> <li>Don't cut through wildcard-expanded aliases chains (65dafa4 by Timoth\u00e9e Mazzucotelli).</li> <li>Fix docstrings warnings when there's no parent module (e080549 by Timoth\u00e9e Mazzucotelli). Issue #51</li> </ul>"},{"location":"changelog/#code-refactoring_24","title":"Code Refactoring","text":"<ul> <li>Use proper classes for docstrings sections (46eddac by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/python#3, PR #52</li> </ul>"},{"location":"changelog/#0130-2022-02-23","title":"0.13.0 - 2022-02-23","text":"<p>Compare with 0.12.6</p>"},{"location":"changelog/#features_23","title":"Features","text":"<ul> <li>Implement <code>trim_doctest_flags</code> for Google and Numpy (8057153 by Jeremy Goh). Issue mkdocstrings/mkdocstrings#386, PR #48</li> </ul>"},{"location":"changelog/#bug-fixes_43","title":"Bug Fixes","text":"<ul> <li>Rename keyword parameters to keyword arguments (ce3eb6b by Jeremy Goh).</li> </ul>"},{"location":"changelog/#0126-2022-02-18","title":"0.12.6 - 2022-02-18","text":"<p>Compare with 0.12.5</p>"},{"location":"changelog/#bug-fixes_44","title":"Bug Fixes","text":"<ul> <li>Support starred parameters in Numpy docstrings (27f0fc2 by Timoth\u00e9e Mazzucotelli). Issue #43</li> </ul>"},{"location":"changelog/#0125-2022-02-17","title":"0.12.5 - 2022-02-17","text":"<p>Compare with 0.12.4</p>"},{"location":"changelog/#bug-fixes_45","title":"Bug Fixes","text":"<ul> <li>Fix getting line numbers on aliases (351750e by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0124-2022-02-16","title":"0.12.4 - 2022-02-16","text":"<p>Compare with 0.12.3</p>"},{"location":"changelog/#bug-fixes_46","title":"Bug Fixes","text":"<ul> <li>Update target path when changing alias target (5eda646 by Timoth\u00e9e Mazzucotelli).</li> <li>Fix relative imports to absolute with wildcards (69500dd by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#382</li> <li>Fix accessing members using tuples (87ff1df by Timoth\u00e9e Mazzucotelli).</li> <li>Fix recursive wildcard expansion (60e6edf by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#382</li> <li>Only export submodules if they were imported (98c72db by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#382</li> </ul>"},{"location":"changelog/#0123-2022-02-15","title":"0.12.3 - 2022-02-15","text":"<p>Compare with 0.12.2</p>"},{"location":"changelog/#bug-fixes_47","title":"Bug Fixes","text":"<ul> <li>Always decode source as UTF8 (563469b by Timoth\u00e9e Mazzucotelli).</li> <li>Fix JSON encoder and decoder (3e768d6 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_25","title":"Code Refactoring","text":"<ul> <li>Improve error handling (7b15a51 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0122-2022-02-13","title":"0.12.2 - 2022-02-13","text":"<p>Compare with 0.12.1</p>"},{"location":"changelog/#bug-fixes_48","title":"Bug Fixes","text":"<ul> <li>Fix JSON unable to serialize docstring kind values (91e6719 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_26","title":"Code Refactoring","text":"<ul> <li>Make attribute labels more explicit (19eac2e by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0121-2022-02-12","title":"0.12.1 - 2022-02-12","text":"<p>Compare with 0.11.7</p>"},{"location":"changelog/#features_24","title":"Features","text":"<ul> <li>Add <code>ignore_init_summary</code> option to the Google parser (81f0333 by Timoth\u00e9e Mazzucotelli).</li> <li>Add <code>is_KIND</code> properties on objects (17a08cd by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0117-2022-02-12","title":"0.11.7 - 2022-02-12","text":"<p>Compare with 0.11.6</p>"},{"location":"changelog/#bug-fixes_49","title":"Bug Fixes","text":"<ul> <li>Keep only first assignment in conditions (0104440 by Timoth\u00e9e Mazzucotelli).</li> <li>Support invert unary op in annotations (734ef55 by Timoth\u00e9e Mazzucotelli).</li> <li>Fix handling of missing modules during dynamic imports (7a3b383 by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#380</li> <li>Fix getting lines of compiled modules (899461b by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_27","title":"Code Refactoring","text":"<ul> <li>Get annotation with the same property on functions (ecc7bba by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0116-2022-02-10","title":"0.11.6 - 2022-02-10","text":"<p>Compare with 0.11.5</p>"},{"location":"changelog/#bug-fixes_50","title":"Bug Fixes","text":"<ul> <li>Fix infinite loop in Google parser (8b7b97b by Timoth\u00e9e Mazzucotelli). Issue #38</li> </ul>"},{"location":"changelog/#0115-2022-02-08","title":"0.11.5 - 2022-02-08","text":"<p>Compare with 0.11.4</p>"},{"location":"changelog/#bug-fixes_51","title":"Bug Fixes","text":"<ul> <li>Fix building title and kind of Google admonitions (87ab56c by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings#379</li> </ul>"},{"location":"changelog/#0114-2022-02-07","title":"0.11.4 - 2022-02-07","text":"<p>Compare with 0.11.3</p>"},{"location":"changelog/#bug-fixes_52","title":"Bug Fixes","text":"<ul> <li>Don't trigger alias resolution while checking docstrings presence (dda72ea by Timoth\u00e9e Mazzucotelli). Issue #37</li> </ul>"},{"location":"changelog/#0113-2022-02-05","title":"0.11.3 - 2022-02-05","text":"<p>Compare with 0.11.2</p>"},{"location":"changelog/#bug-fixes_53","title":"Bug Fixes","text":"<ul> <li>Fix getting params defaults on Python 3.7 (0afd867 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0112-2022-02-03","title":"0.11.2 - 2022-02-03","text":"<p>Compare with 0.11.1</p>"},{"location":"changelog/#code-refactoring_28","title":"Code Refactoring","text":"<ul> <li>Factorize docstring annotation parser (19609be by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0111-2022-02-01","title":"0.11.1 - 2022-02-01","text":"<p>Compare with 0.11.0</p>"},{"location":"changelog/#code-refactoring_29","title":"Code Refactoring","text":"<ul> <li>Rename RST parser to Sphinx (a612cb1 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0110-2022-01-31","title":"0.11.0 - 2022-01-31","text":"<p>Compare with 0.10.0</p>"},{"location":"changelog/#features_25","title":"Features","text":"<ul> <li>Support matrix multiplication operator in visitor (6129e17 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#bug-fixes_54","title":"Bug Fixes","text":"<ul> <li>Fix name resolution for inspected data (ed3e7e5 by Timoth\u00e9e Mazzucotelli).</li> <li>Make importer actually able to import any nested object (d007219 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_30","title":"Code Refactoring","text":"<ul> <li>Always use search paths to import modules (a9a378f by Timoth\u00e9e Mazzucotelli).</li> <li>Split out module finder (7290642 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0100-2022-01-14","title":"0.10.0 - 2022-01-14","text":"<p>Compare with 0.9.0</p>"},{"location":"changelog/#bug-fixes_55","title":"Bug Fixes","text":"<ul> <li>Fix infinite recursion errors in alias resolver (133b4e4 by Timoth\u00e9e Mazzucotelli).</li> <li>Fix inspection of nodes children (aliases or not) (bb354f2 by Timoth\u00e9e Mazzucotelli).</li> <li>Fix relative to absolute import conversion (464c39e by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_31","title":"Code Refactoring","text":"<ul> <li>Rename some CLI options (1323268 by Timoth\u00e9e Mazzucotelli).</li> <li>Return the loader the to main function (9c6317e by Timoth\u00e9e Mazzucotelli).</li> <li>Improve logging messages (b8eb16e by Timoth\u00e9e Mazzucotelli).</li> <li>Skip inspection of some debug packages (4ee8968 by Timoth\u00e9e Mazzucotelli).</li> <li>Return ... instead of Ellipsis (f9ae31d by Timoth\u00e9e Mazzucotelli).</li> <li>Catch attribute errors when cross-referencing docstring annotations (288803a by Timoth\u00e9e Mazzucotelli).</li> <li>Support dict methods in lines collection (1b0cb94 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#features_26","title":"Features","text":"<ul> <li>Compute and show some stats (1b8d0a1 by Timoth\u00e9e Mazzucotelli).</li> <li>Add CLI options for alias resolution (87a59cb by Timoth\u00e9e Mazzucotelli).</li> <li>Support Google raises annotations cross-refs (8006ae1 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#090-2022-01-04","title":"0.9.0 - 2022-01-04","text":"<p>Compare with 0.8.0</p>"},{"location":"changelog/#features_27","title":"Features","text":"<ul> <li>Loader option to only follow aliases in known modules (879d91b by Timoth\u00e9e Mazzucotelli).</li> <li>Use aliases when inspecting too (60439ee by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#bug-fixes_56","title":"Bug Fixes","text":"<ul> <li>Handle more errors when loading modules (1aa571a by Timoth\u00e9e Mazzucotelli).</li> <li>Handle more errors when getting signature (2db85e7 by Timoth\u00e9e Mazzucotelli).</li> <li>Fix checking parent truthfulness (6129e50 by Timoth\u00e9e Mazzucotelli).</li> <li>Fix getting subscript value (1699f12 by Timoth\u00e9e Mazzucotelli).</li> <li>Support yield nodes (7d536d5 by Timoth\u00e9e Mazzucotelli).</li> <li>Exclude some special low-level members that cause cyclic issues (b54ab34 by Timoth\u00e9e Mazzucotelli).</li> <li>Fix transforming elements of signatures to annotations (e278c11 by Timoth\u00e9e Mazzucotelli).</li> <li>Detect cyclic aliases and prevent resolution errors (de5dd12 by Timoth\u00e9e Mazzucotelli).</li> <li>Don't crash while trying to get the representation of an attribute value (77ac55d by Timoth\u00e9e Mazzucotelli).</li> <li>Fix building value for joined strings (6154b69 by Timoth\u00e9e Mazzucotelli).</li> <li>Fix prevention of cycles while building objects nodes (48062ac by Timoth\u00e9e Mazzucotelli).</li> <li>Better handle relative imports (91b42de by Timoth\u00e9e Mazzucotelli).</li> <li>Fix Google parser missing lines ending with colon (2f7969c by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_32","title":"Code Refactoring","text":"<ul> <li>Improve alias resolution robustness (e708139 by Timoth\u00e9e Mazzucotelli).</li> <li>Remove async loader for now (acc5ecf by Timoth\u00e9e Mazzucotelli).</li> <li>Improve handling of Google admonitions (8aa5ed0 by Timoth\u00e9e Mazzucotelli).</li> <li>Better handling of import errors and system exits while inspecting modules (7ba1589 by Timoth\u00e9e Mazzucotelli).</li> <li>Empty generic visit/inspect methods in base classes (338760e by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#080-2022-01-02","title":"0.8.0 - 2022-01-02","text":"<p>Compare with 0.7.1</p>"},{"location":"changelog/#features_28","title":"Features","text":"<ul> <li>Support getting attribute annotation from parent in RST docstring parser (25db61a by Timoth\u00e9e Mazzucotelli).</li> <li>Handle relative imports (62b0927 by Timoth\u00e9e Mazzucotelli).</li> <li>Support wildcard imports (77a3cb7 by Timoth\u00e9e Mazzucotelli).</li> <li>Support configuring log level (CLI/env var) (839d78e by Timoth\u00e9e Mazzucotelli).</li> <li>Support loading <code>*.py[cod]</code> and <code>*.so</code> modules (cd98a6f by Timoth\u00e9e Mazzucotelli).</li> <li>Support inspecting builtin functions/methods (aa1fce3 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_33","title":"Code Refactoring","text":"<ul> <li>Handle extensions errors (11278ca by Timoth\u00e9e Mazzucotelli).</li> <li>Don't always try to find a module as a relative  path (e6df277 by Timoth\u00e9e Mazzucotelli).</li> <li>Improve loggers patching (f4b262a by Timoth\u00e9e Mazzucotelli).</li> <li>Improve dynamic imports (2998195 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#071-2021-12-28","title":"0.7.1 - 2021-12-28","text":"<p>Compare with 0.7.0</p>"},{"location":"changelog/#code-refactoring_34","title":"Code Refactoring","text":"<ul> <li>Only log warning if async mode is used (356e848 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#070-2021-12-28","title":"0.7.0 - 2021-12-28","text":"<p>Compare with 0.6.0</p>"},{"location":"changelog/#features_29","title":"Features","text":"<ul> <li>Support more nodes on Python 3.7 (7f2c4ec by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_35","title":"Code Refactoring","text":"<ul> <li>Don't crash on syntax errors and log an error (10bb6b1 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#060-2021-12-27","title":"0.6.0 - 2021-12-27","text":"<p>Compare with 0.5.0</p>"},{"location":"changelog/#features_30","title":"Features","text":"<ul> <li>Support more AST nodes (cd1b305 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_36","title":"Code Refactoring","text":"<ul> <li>Use annotation getter for base classes (8b1a7ed by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#050-2021-12-20","title":"0.5.0 - 2021-12-20","text":"<p>Compare with 0.4.0</p>"},{"location":"changelog/#features_31","title":"Features","text":"<ul> <li>Add support for Python 3.7 (4535adc by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#bug-fixes_57","title":"Bug Fixes","text":"<ul> <li>Don't propagate aliases of an alias (8af48f8 by Timoth\u00e9e Mazzucotelli).</li> <li>Don't reassign members defined in except clauses (d918b4e by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#040-2021-11-28","title":"0.4.0 - 2021-11-28","text":"<p>Compare with 0.3.0</p>"},{"location":"changelog/#features_32","title":"Features","text":"<ul> <li>Add a prototype 'hybrid' extension (8cb3c16 by Timoth\u00e9e Mazzucotelli).</li> <li>Allow passing extensions config as JSON on the CLI (9a7fa8b by Timoth\u00e9e Mazzucotelli).</li> <li>Support names for returns, yields and receives sections items (1c5a4c9 by Timoth\u00e9e Mazzucotelli).</li> <li>Store aliases on each object (91ba643 by Timoth\u00e9e Mazzucotelli).</li> <li>Support in[tro]spection (3a0587d by Timoth\u00e9e Mazzucotelli).</li> <li>Support multiple return, yield and receive items (0fc70cb by Timoth\u00e9e Mazzucotelli).</li> <li>Support namespace packages (2414c8e by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#bug-fixes_58","title":"Bug Fixes","text":"<ul> <li>Fix extensions loader (78fb70b by Timoth\u00e9e Mazzucotelli).</li> <li>Avoid visiting/inspecting multiple times (75a8a8b by Timoth\u00e9e Mazzucotelli).</li> <li>Set modules collection attribute earlier (592c0bd by Timoth\u00e9e Mazzucotelli).</li> <li>Support inequality nodes (b0ed247 by Timoth\u00e9e Mazzucotelli).</li> <li>Handle Div nodes for values (272e4d6 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_37","title":"Code Refactoring","text":"<ul> <li>Set log level to INFO (718e73e by Timoth\u00e9e Mazzucotelli).</li> <li>Add target setter (7f0064c by Timoth\u00e9e Mazzucotelli).</li> <li>Reorganize conditions (15ab876 by Timoth\u00e9e Mazzucotelli).</li> <li>Avoid recursion loops (ea6acec by Timoth\u00e9e Mazzucotelli).</li> <li>Update aliases when replacing a member (99a0f8b by Timoth\u00e9e Mazzucotelli).</li> <li>Reorganize code (31fcdb1 by Timoth\u00e9e Mazzucotelli).</li> <li>Replace DocstringException with DocstringRaise (d5ed87a by Timoth\u00e9e Mazzucotelli).</li> <li>Refactor loaders (d9b94bb by Timoth\u00e9e Mazzucotelli).</li> <li>Improve typing (e08bcfa by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#030-2021-11-21","title":"0.3.0 - 2021-11-21","text":"<p>Compare with 0.2.0</p>"},{"location":"changelog/#features_33","title":"Features","text":"<ul> <li>Handle aliases and their resolution (67ae903 by Timoth\u00e9e Mazzucotelli).</li> <li>Resolve annotations in docstrings (847384a by Timoth\u00e9e Mazzucotelli).</li> <li>Resolve annotations (6451eff by Timoth\u00e9e Mazzucotelli).</li> <li>Add lines property to objects (7daf7db by Timoth\u00e9e Mazzucotelli).</li> <li>Allow setting docstring parser and options on each object (07a1d2e by Timoth\u00e9e Mazzucotelli).</li> <li>Get attributes annotations from parent (003b990 by Timoth\u00e9e Mazzucotelli).</li> <li>Draft extensions loader (17ccd03 by Timoth\u00e9e Mazzucotelli).</li> <li>Add properties to objects (0ec301a by Timoth\u00e9e Mazzucotelli).</li> <li>Handle .pth files when searching modules (2a2e182 by Timoth\u00e9e Mazzucotelli).</li> <li>Add <code>default</code> property to docstring parameters (6298ba3 by Timoth\u00e9e Mazzucotelli).</li> <li>Accept RST and Numpy parsers (1cf147d by Timoth\u00e9e Mazzucotelli).</li> <li>Support data (attributes/variables) (dce84d1 by Timoth\u00e9e Mazzucotelli).</li> <li>Add Numpy-style parser (ad5b72d by Timoth\u00e9e Mazzucotelli).</li> <li>Support more section kinds in Google-style (9d3d047 by Timoth\u00e9e Mazzucotelli).</li> <li>Add docstring section kinds (b270483 by Timoth\u00e9e Mazzucotelli).</li> <li>Accept initial arguments when creating container (90c5956 by Timoth\u00e9e Mazzucotelli).</li> <li>Add an RST-style docstring parser (742e7b2 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#performance-improvements_2","title":"Performance Improvements","text":"<ul> <li>Improve JSON encoder perfs (6a78eb0 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#bug-fixes_59","title":"Bug Fixes","text":"<ul> <li>Handle serialization of Posix paths (3a66b95 by Timoth\u00e9e Mazzucotelli).</li> <li>Fix list annotation getter (5ae800a by Timoth\u00e9e Mazzucotelli).</li> <li>Show accurate line number in Google warnings (2953590 by Timoth\u00e9e Mazzucotelli).</li> <li>Fix assignment names getters (6990846 by Timoth\u00e9e Mazzucotelli).</li> <li>Fix async loader (passing parent) (57e866e by Timoth\u00e9e Mazzucotelli).</li> <li>Fix exception name (4b8b85d by Timoth\u00e9e Mazzucotelli).</li> <li>Fix Google sections titles logic (87dd329 by Timoth\u00e9e Mazzucotelli).</li> <li>Prepend current module to base classes (still needs resolution) (a4b1dee by Timoth\u00e9e Mazzucotelli).</li> <li>Fix Google admonition regex (3902e74 by Timoth\u00e9e Mazzucotelli).</li> <li>Fix docstring getter (1442eba by Timoth\u00e9e Mazzucotelli).</li> <li>Fix getting arguments defaults in the Google-style parser (67adbaf by Timoth\u00e9e Mazzucotelli).</li> <li>Fix getting arguments annotations in the Google-style parser (8bcbfba by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_38","title":"Code Refactoring","text":"<ul> <li>Export parsers and main function in docstrings module (96469da by Timoth\u00e9e Mazzucotelli).</li> <li>Remove top exports (cd76694 by Timoth\u00e9e Mazzucotelli).</li> <li>Reorganize exceptions (7f9b805 by Timoth\u00e9e Mazzucotelli).</li> <li>Avoid circular import (ef27dcd by Timoth\u00e9e Mazzucotelli).</li> <li>Rename index to [new] offset (c07cc7d by Timoth\u00e9e Mazzucotelli).</li> <li>Reorganize code (5f4fff2 by Timoth\u00e9e Mazzucotelli).</li> <li>Use keyword only parameters (d34edd6 by Timoth\u00e9e Mazzucotelli).</li> <li>Default to no parsing for serialization (8fecd9e by Timoth\u00e9e Mazzucotelli).</li> <li>Always extend AST (c227ae6 by Timoth\u00e9e Mazzucotelli).</li> <li>Set default for kwargs parameters (7a0b85e by Timoth\u00e9e Mazzucotelli).</li> <li>Rename visitor method (3e0c43c by Timoth\u00e9e Mazzucotelli).</li> <li>Improve typing (ac86f17 by Timoth\u00e9e Mazzucotelli).</li> <li>Fix typo (a9ed6e9 by Timoth\u00e9e Mazzucotelli).</li> <li>Rewrite ParameterKind (90249df by Timoth\u00e9e Mazzucotelli).</li> <li>Add bool methods to docstrings and objects (548f72e by Timoth\u00e9e Mazzucotelli).</li> <li>Allow setting docstring parser and options on each docstring (752e084 by Timoth\u00e9e Mazzucotelli).</li> <li>Skip attribute assignments (e9cc2cd by Timoth\u00e9e Mazzucotelli).</li> <li>Improve visitor getters (2ea88c0 by Timoth\u00e9e Mazzucotelli).</li> <li>Use relative filepath in docstring warnings (e894df7 by Timoth\u00e9e Mazzucotelli).</li> <li>Set submodules parent earlier (53767c0 by Timoth\u00e9e Mazzucotelli).</li> <li>Rename Data to Attribute (febc12e by Timoth\u00e9e Mazzucotelli).</li> <li>Rename arguments to parameters (957856c by Timoth\u00e9e Mazzucotelli).</li> <li>Improve annotation support (5b2262f by Timoth\u00e9e Mazzucotelli).</li> <li>Always set parent (cae85de by Timoth\u00e9e Mazzucotelli).</li> <li>Factorize function handling (dfece1c by Timoth\u00e9e Mazzucotelli).</li> <li>Privatize stuff, fix loggers (5513ed5 by Timoth\u00e9e Mazzucotelli).</li> <li>Use keyword only arguments (e853fe9 by Timoth\u00e9e Mazzucotelli).</li> <li>Set default values for Argument arguments (d5cccaa by Timoth\u00e9e Mazzucotelli).</li> <li>Swallow extra parsing options (3d9ebe7 by Timoth\u00e9e Mazzucotelli).</li> <li>Rename <code>start_index</code> argument to <code>offset</code> (dd88358 by Timoth\u00e9e Mazzucotelli).</li> <li>Reuse parsers warn function (03dfdd3 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#020-2021-09-25","title":"0.2.0 - 2021-09-25","text":"<p>Compare with 0.1.0</p>"},{"location":"changelog/#features_34","title":"Features","text":"<ul> <li>Add Google-style docstring parser (cdefccc by Timoth\u00e9e Mazzucotelli).</li> <li>Support all kinds of functions arguments (c177562 by Timoth\u00e9e Mazzucotelli).</li> <li>Initial support for class decorators and bases (8e229aa by Timoth\u00e9e Mazzucotelli).</li> <li>Add functions decorators support (fee304d by Timoth\u00e9e Mazzucotelli).</li> <li>Add async loader (3218bd0 by Timoth\u00e9e Mazzucotelli).</li> <li>Add relative file path and package properties (d26ee1f by Timoth\u00e9e Mazzucotelli).</li> <li>Add search and output option to the CLI (3b37692 by Timoth\u00e9e Mazzucotelli).</li> <li>Load docstrings and functions arguments (cdf29a3 by Timoth\u00e9e Mazzucotelli).</li> <li>Support paths in loader (8f4df75 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#performance-improvements_3","title":"Performance Improvements","text":"<ul> <li>Avoid name lookups in visitor (00de148 by Timoth\u00e9e Mazzucotelli).</li> <li>Factorize and improve main and extensions visitors (9b27b56 by Timoth\u00e9e Mazzucotelli).</li> <li>Delegate children computation at runtime (8d54c87 by Timoth\u00e9e Mazzucotelli).</li> <li>Cache dataclasses properties (2d7447d by Timoth\u00e9e Mazzucotelli).</li> <li>Optimize node linker (03f955e by Timoth\u00e9e Mazzucotelli).</li> <li>Optimize docstring getter (4a05516 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#010-2021-09-09","title":"0.1.0 - 2021-09-09","text":"<p>Compare with first commit</p>"},{"location":"changelog/#features_35","title":"Features","text":"<ul> <li>Add initial code (8cbdf7a by Timoth\u00e9e Mazzucotelli).</li> <li>Generate project from copier-pdm template (7ea73ad by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"checking/","title":"Checking for API breakages","text":"<p>Griffe is able to compare two snapshots of your project to detect API breakages between the old and the new snapshot. By snapshot we mean a specific point in your Git history. For example, you can ask Griffe to compare your current code against a specific tag.</p> <p>By default, Griffe will compare the current code to the latest tag:</p> <pre><code>$ griffe check mypackage\n</code></pre> <p>To specify another Git reference to check against, use the <code>--against</code> or <code>-a</code> option:</p> <pre><code>$ griffe check mypackage -a 0.2.0\n</code></pre> <p>You can specify a Git tag, commit (hash), or even a branch: Griffe will create a worktree at this reference in a temporary directory, and clean it up after finishing.</p> <p>If you want to also specify the base reference to use (instead of the current code), use the <code>--base</code> or <code>-b</code> option. Some examples:</p> <pre><code>$ griffe check mypackage -b HEAD -a 2.0.0\n$ griffe check mypackage -b 2.0.0 -a 1.0.0\n$ griffe check mypackage -b fix-issue-90 -a 1.2.3 $ griffe check mypackage -b 8afcfd6e </code></pre> <p>Important:</p> <p>Remember that the base is the most recent reference, and the one we compare it against is the oldest one.</p> <p>The package name you pass to <code>griffe check</code> must be found relatively to the repository root. For Griffe to find packages in subfolders, pass the parent subfolder to the  <code>--search</code> or <code>-s</code> option. Example for <code>src</code>-layouts:</p> <pre><code>$ griffe check -s src griffe\n</code></pre> <p>Example in a monorepo, within a deeper file tree:</p> <pre><code>$ griffe check -s back/services/identity-provider/src identity_provider\n</code></pre>"},{"location":"checking/#detected-breakages","title":"Detected breakages","text":"<p>In this section, we will describe the breakages that Griffe detects, giving some code examples and hints on how to properly communicate breakages with deprecation messages before actually releasing them.</p> <p>Obviously, these explanations and the value of the hints we provide depend on your definition of what is a public Python API. There is no clear and generally agreed upon definition of \"public Python API\". A public Python API might vary from one project to another.  In essence, your public API is what you say it is.</p> <p>However, we do have conventions like prefixing objects with an underscore to tell users these objects are part of the private API, or internals, and therefore should not be used. For the rest, Griffe can detect changes that will trigger immediate errors in your users code', and changes that might cause issues in your users' code. Although the latter sound less impactful, they do have a serious impact, because they can silently change the behavior of your users' code, leading to issues that are hard to detect, understand and fix.</p> <p>Knowing that every change is a breaking change, the more we detect and document (potentially) breaking changes in our changelogs, the better.</p>"},{"location":"checking/#parameter-moved","title":"Parameter moved","text":"<p>Positional parameter was moved.</p> <p>Moving the order of positional parameters can silently break your users' code.</p> before<pre><code># your code\ndef greet(prefix, name):\n    print(prefix + \" \" + name)\n\n# user's code\ngreet(\"hello\", \"world\")\n</code></pre> after<pre><code># your code\ndef greet(name, prefix):\n    print(prefix + \" \" + name)\n\n# user's code: no immediate error, broken behavior\ngreet(\"hello\", \"world\")\n</code></pre> <p>Note</p> <p>Moving required parameters around is not really an API breakage, depending on our definition of API, since this won't raise immediate errors like <code>TypeError</code>. The function expects a number of arguments, and the developer pass it this same number of arguments: the contract is fulfilled. But parameters very often have specific meaning, and changing their order will silently lead (no immediate error) to incorrect behavior, potentially making it difficult to detect, understand and fix the issue. That is why it is important to warn developers about such changes.</p> <p>Hint</p> <p>If you often add, move or remove parameters, consider making them keyword-only, so that their order doesn't matter.</p> before<pre><code>def greet(*, prefix, name):\n    print(prefix + \" \" + name)\n\ngreet(prefix=\"hello\", name=\"world\")\n</code></pre> after<pre><code>def greet(*, name, prefix):\n    print(prefix + \" \" + name)\n\n# still working as expected\ngreet(prefix=\"hello\", name=\"world\")\n</code></pre>"},{"location":"checking/#parameter-removed","title":"Parameter removed","text":"<p>Parameter was removed.</p> <p>Removing a parameter can immediately break your users' code.</p> before<pre><code># your code\ndef greet(prefix, name):\n    print(prefix + \" \" + name)\n\n# user's code\ngreet(\"hello\", \"world\")\n</code></pre> after<pre><code># your code\ndef greet(name):\n    print(\"hello \" + name)\n\n# user's code: immediate error\ngreet(\"hello\", \"world\")\n\n# even with keyword parameters: immediate error\ngreet(prefix=\"hello\", name=\"world\")\n</code></pre> <p>Hint</p> <p>Allow a deprecation period for the removed parameter by swallowing it in a variadic positional parameter, a variadic keyword parameter, or both.</p> positional-onlykeyword-onlypositional or keyword before<pre><code># your parameters are positional-only parameters (difficult deprecation)\ndef greet(prefix, name, /):\n    print(prefix + \" \" + name)\n\ngreet(\"hello\", \"world\")\n</code></pre> after<pre><code># swallow prefix using a variadic positional parameter\ndef greet(*args):\n    if len(args) == 2:\n        prefix, name = args\n    elif len(args) == 1:\n        prefix = None\n        name = args[0]\n    else:\n        raise ValueError(\"missing parameter 'name'\")\n    if prefix is not None:\n        warnings.warn(DeprecationWarning, \"prefix is deprecated\")\n    print(\"hello \" + name)\n\n# still working as expected\ngreet(\"hello\", \"world\")\n</code></pre> before<pre><code># your parameters are keyword-only parameters (easy deprecation)\ndef greet(*, prefix, name):\n    print(prefix + \" \" + name)\n\ngreet(prefix=\"hello\", name=\"world\")\n</code></pre> after<pre><code># swallow prefix using a variadic keyword parameter\ndef greet(name, **kwargs):\n    prefix = kwargs.get(\"prefix\", None)\n    if prefix is not None:\n        warnings.warn(DeprecationWarning, \"prefix is deprecated\")\n    print(\"hello \" + name)\n\n# still working as expected\ngreet(prefix=\"hello\", name=\"world\")\n</code></pre> before<pre><code># your parameters are positional or keyword parameters (very difficult deprecation)\ndef greet(prefix, name):\n    print(prefix + \" \" + name)\n\ngreet(\"hello\", name=\"world\")\n</code></pre> after<pre><code># no other choice than swallowing both forms...\n# ignoring the deprecated parameter becomes quite complex\ndef greet(*args, **kwargs):\n    if len(args) == 2:\n        prefix, name = args\n    elif len(args) == 1:\n        prefix = None\n        name = args[0]\n    if \"name\" in kwargs:\n        name = kwargs[\"name\"]\n    if \"prefix\" in kwargs:\n        prefix = kwargs[\"prefix\"]\n    if prefix is not None:\n        warnings.warn(DeprecationWarning, \"prefix is deprecated\")\n    print(\"hello \" + name)\n\n# still working as expected\ngreet(\"hello\", \"world\")\ngreet(\"hello\", name=\"world\")\ngreet(prefix=\"hello\", name=\"world\")\n</code></pre>"},{"location":"checking/#parameter-changed-kind","title":"Parameter changed kind","text":"<p>Parameter kind was changed</p> <p>Changing the kind of a parameter to another (positional-only, keyword-only, positional or keyword, variadic positional, variadic keyword) can immediately break your users' code.</p> before<pre><code># your code\ndef greet(name):\n    print(\"hello \" + name)\n\ndef greet2(name):\n    print(\"hello \" + name)\n\n# user's code: all working fine\ngreet(\"tim\")\ngreet(name=\"tim\")\ngreet2(\"tim\")\ngreet2(name=\"tim\")\n</code></pre> after<pre><code># your code\ndef greet(name, /):\n    print(\"hello \" + name)\n\ndef greet2(*, name):\n    print(\"hello \" + name)\n\n# user's code: working as expected\ngreet(\"tim\")\ngreet2(name=\"tim\")\n\n# immediate error\ngreet(name=\"tim\")\ngreet2(\"tim\")\n</code></pre> <p>Hint</p> <p>Although it actually is a breaking change, changing your positional or keyword parameters' kind to keyword-only makes your public function more robust to future changes (forward-compatibility).</p> <p>For functions with lots of optional parameters, and a few (one or two) required parameters, it can be a good idea to accept the required parameters as positional or keyword, while accepting the optional parameters as keyword-only parameters:</p> <pre><code>def greet(name, *, punctuation=False, bold=False, italic=False):\n    ...\n\n# simple cases are easy to write\ngreet(\"tim\")\ngreet(\"tiff\")\n\n# complex cases are never ambiguous\ngreet(\"tim\", italic=True, bold=True)\ngreet(name=\"tiff\", bold=True, punctuation=True)\n</code></pre> <p>Positional-only parameters are useful in some specific cases, such as when a function takes two or more numeric values, and their order does not matter, and naming the parameters would not make sense:</p> <pre><code>def multiply3(a, b, c, /):\n    return a * b * c\n\n# all the following are equivalent\nmultiply3(4, 2, 3)\nmultiply3(4, 3, 2)\nmultiply3(2, 3, 4)\n# etc.\n</code></pre>"},{"location":"checking/#parameter-changed-default","title":"Parameter changed default","text":"<p>Parameter default was changed</p> <p>Changing the default value of a parameter can silently break your users' code.</p> before<pre><code># your code\ndef compute_something(value: int, to_float=True):\n    value = ...\n    if to_float:\n        return float(value)\n    return value\n\n# user's code: condition is entered\nif isinstance(compute_something(7), float):\n    ...\n</code></pre> after<pre><code># your code\ndef compute_something(value: int, to_float=False):\n    value = ...\n    if to_float:\n        return float(value)\n    return value\n\n# user's code: condition is not entered anymore\nif isinstance(compute_something(7), float):\n    ...\n</code></pre> <p>Note</p> <p>Changing default value of parameters is not really an API breakage, depending on our definition of API, since this won't raise immediate errors like <code>TypeError</code>. Not using the parameter still provides the argument with a default value: the contract is fulfilled. But default values very often have specific meaning, and changing them will silently lead (no immediate error) to incorrect behavior, potentially making it difficult to detect, understand and fix the issue. That is why it is important to warn developers about such changes.</p> <p>Hint</p> <p>Allow a deprecation period for the old default value by using a sentinel value to detect when the parameter wasn't used by the user:</p> in the coming release<pre><code>_sentinel = object()\n\ndef compute_something(value: int, to_float=_sentinel):\n    value = ...\n    if to_float is _sentinel:\n        to_float = True\n        warnings.warn(\n            DeprecationWarning,\n            \"default value of 'to_float' will change from True to False, \"\n            \"please provide 'to_float=True' if you want to retain the current behavior\"\n        )\n    if to_float:\n        return float(value)\n    return value\n</code></pre> <p>In a later release you can remove the sentinel, the deprecation warning, and set <code>False</code> as default to <code>to_float</code>.</p> in a later release<pre><code>def compute_something(value: int, to_float=False):\n    value = ...\n    if to_float:\n        return float(value)\n    return value\n</code></pre>"},{"location":"checking/#parameter-changed-required","title":"Parameter changed required","text":"<p>Parameter is now required</p> <p>Changing an optional parameter to a required one (by removing its default value) can immediately break your users' code.</p> before<pre><code># your code\ndef greet(name, prefix=\"hello\"):\n    print(prefix + \" \" + name)\n\n# user's code\ngreet(\"tiff\")\n</code></pre> after<pre><code># your code\ndef greet(name, prefix):\n    print(prefix + \" \" + name)\n\n# user's code: immediate error\ngreet(\"tiff\")\n</code></pre> <p>Hint</p> <p>Allow a deprecation period for the default value by using a sentinel value to detect when the parameter wasn't used by the user:</p> in the coming release<pre><code>_sentinel = object()\n\ndef greet(name, prefix=_sentinel):\n    if prefix is _sentinel:\n        prefix = \"hello\"\n        warnings.warn(DeprecationWarning, \"'prefix' will become required in the next release\")\n    print(prefix + \" \" + name)\n</code></pre> <p>In a later release you can remove the sentinel, the deprecation warning, and the default value of <code>prefix</code>.</p> in a later release<pre><code>def greet(name, prefix):\n    print(prefix + \" \" + name)\n</code></pre>"},{"location":"checking/#parameter-added-required","title":"Parameter added required","text":"<p>Parameter was added as required</p> <p>Adding a new, required parameter can immediately break your users' code.</p> before<pre><code># your code\ndef greet(name):\n    print(\"hello \" + name)\n\n# user's code\ngreet(\"tiff\")\n</code></pre> after<pre><code># your code\ndef greet(name, prefix):\n    print(prefix + \" \" + name)\n\n# user's code: immediate error\ngreet(\"tiff\")\n</code></pre> <p>Hint</p> <p>You can delay (or avoid) and inform your users about the upcoming breakage by temporarily (or permanently) providing a default value for the new parameter:</p> in the coming release<pre><code>def greet(name, prefix=\"hello\"):\n    print(prefix + \" \" + name)\n</code></pre>"},{"location":"checking/#return-changed-type","title":"Return changed type","text":"<p>Return types are incompatible</p> <p>Not yet supported!</p> <p> Telling if a type construct is compatible with another one is not trivial, especially statically. Support for this will be implemented later.</p>"},{"location":"checking/#object-removed","title":"Object removed","text":"<p>Public object was removed</p> <p>Removing a public object from a module can immediately break your users' code.</p> before<pre><code># your/module.py\nspecial_thing = \"hey\"\n\n# user/module.py\nfrom your.module import special_thing\n\n# other/user/module.py\nfrom your import module\nprint(module.special_thing)\n</code></pre> after<pre><code># user/module.py: import error\nfrom your.module import special_thing\n\n# other/user/module.py: attribute error\nfrom your import module\nprint(module.special_thing)\n</code></pre> <p>Hint</p> <p>Allow a deprecation period by declaring a module-level <code>__getattr__</code> function that returns the given object while warning about its deprecation:</p> <pre><code>def __getattr__(name):\n    if name == \"special_thing\":\n        warnings.warn(DeprecationWarning, \"'special_thing' is deprecated and will be removed\")\n        return \"hey\"\n</code></pre>"},{"location":"checking/#object-changed-kind","title":"Object changed kind","text":"<p>Public object points to a different kind of object</p> <p>Changing the kind (attribute, function, class, module) of a public object can silently break your users' code.</p> before<pre><code># your code\nclass Factory:\n    def __call__(self, ...):\n        ...\n\nfactory = Factory(...)\n\n# user's code: condition is entered\nif isinstance(factory, Factory):\n    ...\n</code></pre> after<pre><code># your code\nclass Factory:\n    ...\n\ndef factory(...):\n    ...\n\n# user's code: condition is not entered anymore\nif isinstance(factory, Factory):\n    ...\n</code></pre> <p>Note</p> <p>Changing the kind of an object is not really an API breakage, depending on our definition of API, since this won't always raise immediate errors like <code>TypeError</code>. The object is still here and accessed: the contract is fulfilled. But developers sometimes rely on the kind of an object, so changing it will lead to incorrect behavior, potentially making it difficult to detect, understand and fix the issue. That is why it is important to warn developers about such changes.</p>"},{"location":"checking/#attribute-changed-type","title":"Attribute changed type","text":"<p>Attribute types are incompatible</p> <p>Not yet supported!</p> <p> Telling if a type construct is compatible with another one is not trivial, especially statically. Support for this will be implemented later.</p>"},{"location":"checking/#attribute-changed-value","title":"Attribute changed value","text":"<p>Attribute value was changed</p> <p>Changing the value of an attribute can silently break your users' code.</p> before<pre><code># your code\nPY_VERSION = os.getenv(\"PY_VERSION\")\n\n# user's code: condition is entered\nif PY_VERSION is None:\n    ...\n</code></pre> after<pre><code># your code\nPY_VERSION = os.getenv(\"PY_VERSION\", \"3.8\")\n\n# user's code: condition is not entered anymore\nif PY_VERSION is None:\n    ...\n</code></pre> <p>Note</p> <p>Changing the value of an attribute is not really an API breakage, depending on our definition of API, since this won't raise immediate errors like <code>TypeError</code>. The attribute is still here and accessed: the contract is fulfilled. But developers heavily rely on the value of public attributes, so changing it will lead to incorrect behavior, potentially making it difficult to detect, understand and fix the issue. That is why it is important to warn developers about such changes.</p> <p>Hint</p> <p>Make sure to document the change of value of the attribute in your changelog, particularly the previous and new range of values it can take.</p>"},{"location":"checking/#class-removed-base","title":"Class removed base","text":"<p>Base class was removed</p> <p>Removing a class from another class' bases can silently break your users' code.</p> before<pre><code># your code\nclass A: ...\nclass B: ...\nclass C(A, B): ...\n\n# user's code: condition is entered\nif B in klass.__bases__:\n    ...\n</code></pre> after<pre><code># your code\nclass A: ...\nclass B: ...\nclass C(A): ...\n\n# user's code: condition is not entered anymore\nif B in klass.__bases__:\n    ...\n</code></pre> <p>Note</p> <p>Unless inherited members are lost in the process, removing a class base is not really an API breakage, depending on our definition of API, since this won't raise immediate errors like <code>TypeError</code>. The class is here, its members as well: the contract is fulfilled. But developers sometimes rely on the actual bases of a class, so changing them will lead to incorrect behavior, potentially making it difficult to detect, understand and fix the issue. That is why it is important to warn developers about such changes.</p>"},{"location":"checking/#output-style","title":"Output style","text":"<p>By default, Griffe will print each detected breakage on a single line, on <code>stderr</code>:</p> <pre><code>$ griffe check griffe -ssrc -b0.24.0 -a0.23.0\nsrc/griffe/loader.py:156: GriffeLoader.resolve_aliases(only_exported): Parameter kind was changed: positional or keyword -&gt; keyword-only\nsrc/griffe/loader.py:156: GriffeLoader.resolve_aliases(only_exported): Parameter default was changed: True -&gt; None\nsrc/griffe/loader.py:156: GriffeLoader.resolve_aliases(only_known_modules): Parameter kind was changed: positional or keyword -&gt; keyword-only\nsrc/griffe/loader.py:156: GriffeLoader.resolve_aliases(only_known_modules): Parameter default was changed: True -&gt; None\nsrc/griffe/loader.py:156: GriffeLoader.resolve_aliases(max_iterations): Parameter kind was changed: positional or keyword -&gt; keyword-only\nsrc/griffe/loader.py:308: GriffeLoader.resolve_module_aliases(only_exported): Parameter was removed\nsrc/griffe/loader.py:308: GriffeLoader.resolve_module_aliases(only_known_modules): Parameter was removed\nsrc/griffe/git.py:39: tmp_worktree(commit): Parameter was removed\nsrc/griffe/git.py:39: tmp_worktree(repo): Positional parameter was moved: position: from 2 to 1 (-1)\nsrc/griffe/git.py:75: load_git(commit): Parameter was removed\nsrc/griffe/git.py:75: load_git(repo): Parameter kind was changed: positional or keyword -&gt; keyword-only\nsrc/griffe/git.py:75: load_git(submodules): Parameter kind was changed: positional or keyword -&gt; keyword-only\nsrc/griffe/git.py:75: load_git(try_relative_path): Parameter was removed\nsrc/griffe/git.py:75: load_git(extensions): Parameter kind was changed: positional or keyword -&gt; keyword-only\nsrc/griffe/git.py:75: load_git(search_paths): Parameter kind was changed: positional or keyword -&gt; keyword-only\nsrc/griffe/git.py:75: load_git(docstring_parser): Parameter kind was changed: positional or keyword -&gt; keyword-only\nsrc/griffe/git.py:75: load_git(docstring_options): Parameter kind was changed: positional or keyword -&gt; keyword-only\nsrc/griffe/git.py:75: load_git(lines_collection): Parameter kind was changed: positional or keyword -&gt; keyword-only\nsrc/griffe/git.py:75: load_git(modules_collection): Parameter kind was changed: positional or keyword -&gt; keyword-only\nsrc/griffe/git.py:75: load_git(allow_inspection): Parameter kind was changed: positional or keyword -&gt; keyword-only\n\n</code></pre> <p>Depending on the detected breakages, the lines might be hard to read (being too compact), so <code>griffe check</code> also accepts a <code>--verbose</code> or <code>-v</code> option to add some space to the output:</p> <pre><code>$ griffe check griffe -ssrc -b0.24.0 -a0.23.0 --verbose\nsrc/griffe/loader.py:156: GriffeLoader.resolve_aliases(only_exported):\nParameter kind was changed:\n  Old: positional or keyword\n  New: keyword-only\n\nsrc/griffe/loader.py:156: GriffeLoader.resolve_aliases(only_exported):\nParameter default was changed:\n  Old: True\n  New: None\n\nsrc/griffe/loader.py:156: GriffeLoader.resolve_aliases(only_known_modules):\nParameter kind was changed:\n  Old: positional or keyword\n  New: keyword-only\n\nsrc/griffe/loader.py:156: GriffeLoader.resolve_aliases(only_known_modules):\nParameter default was changed:\n  Old: True\n  New: None\n\nsrc/griffe/loader.py:156: GriffeLoader.resolve_aliases(max_iterations):\nParameter kind was changed:\n  Old: positional or keyword\n  New: keyword-only\n\nsrc/griffe/loader.py:308: GriffeLoader.resolve_module_aliases(only_exported):\nParameter was removed\n\nsrc/griffe/loader.py:308: \nGriffeLoader.resolve_module_aliases(only_known_modules):\nParameter was removed\n\nsrc/griffe/git.py:39: tmp_worktree(commit):\nParameter was removed\n\nsrc/griffe/git.py:39: tmp_worktree(repo):\nPositional parameter was moved:\n  Details: position: from 1 to 0 (-1)\n\nsrc/griffe/git.py:75: load_git(commit):\nParameter was removed\n\nsrc/griffe/git.py:75: load_git(repo):\nParameter kind was changed:\n  Old: positional or keyword\n  New: keyword-only\n\nsrc/griffe/git.py:75: load_git(submodules):\nParameter kind was changed:\n  Old: positional or keyword\n  New: keyword-only\n\nsrc/griffe/git.py:75: load_git(try_relative_path):\nParameter was removed\n\nsrc/griffe/git.py:75: load_git(extensions):\nParameter kind was changed:\n  Old: positional or keyword\n  New: keyword-only\n\nsrc/griffe/git.py:75: load_git(search_paths):\nParameter kind was changed:\n  Old: positional or keyword\n  New: keyword-only\n\nsrc/griffe/git.py:75: load_git(docstring_parser):\nParameter kind was changed:\n  Old: positional or keyword\n  New: keyword-only\n\nsrc/griffe/git.py:75: load_git(docstring_options):\nParameter kind was changed:\n  Old: positional or keyword\n  New: keyword-only\n\nsrc/griffe/git.py:75: load_git(lines_collection):\nParameter kind was changed:\n  Old: positional or keyword\n  New: keyword-only\n\nsrc/griffe/git.py:75: load_git(modules_collection):\nParameter kind was changed:\n  Old: positional or keyword\n  New: keyword-only\n\nsrc/griffe/git.py:75: load_git(allow_inspection):\nParameter kind was changed:\n  Old: positional or keyword\n  New: keyword-only\n\n</code></pre>"},{"location":"cli_reference/","title":"CLI reference","text":""},{"location":"cli_reference/#griffe","title":"griffe","text":"<p>Signatures for entire Python programs. </p> <p>Global Options:</p> <ul> <li><code>-h</code>, <code>--help</code>: Show this help message and exit. Commands also accept the -h/--help option.</li> <li><code>-V</code>, <code>--version</code>: show program's version number and exit</li> </ul> <p>Commands:</p>"},{"location":"cli_reference/#dump","title":"dump","text":"<p>Load package-signatures and dump them as JSON.</p> <p>Search Options:</p> <ul> <li><code>-s</code>, <code>--search</code>: Paths to search packages into.</li> </ul> <p>Loading Options:</p> <ul> <li><code>-e</code>, <code>--extensions</code>: A list of extensions to use.</li> <li><code>-X</code>, <code>--no-inspection</code>: Disallow inspection of builtin/compiled/not found modules. Default: <code>True</code>.</li> </ul> <p>Dump Options:</p> <ul> <li><code>packages</code> <code>PACKAGE</code>: Packages to find, load and dump.</li> <li><code>-f</code>, <code>--full</code>: Whether to dump full data in JSON.</li> <li><code>-o</code>, <code>--output</code>: Output file. Supports templating to output each package in its own file, with <code>{package}</code>. Default: <code>sys.stdout</code>.</li> <li><code>-d</code>, <code>--docstyle</code>: The docstring style to parse.</li> <li><code>-D</code>, <code>--docopts</code>: The options for the docstring parser.</li> <li><code>-y</code>, <code>--sys-path</code>: Whether to append <code>sys.path</code> to search paths specified with <code>-s</code>.</li> <li><code>-r</code>, <code>--resolve-aliases</code>: Whether to resolve aliases.</li> <li><code>-I</code>, <code>--resolve-implicit</code>: Whether to resolve implicitely exported aliases as well. Aliases are explicitely exported when defined in <code>__all__</code>.</li> <li><code>-U</code>, <code>--resolve-external</code>: Whether to resolve aliases pointing to external/unknown modules (not loaded directly).</li> <li><code>-S</code>, <code>--stats</code>: Show statistics at the end.</li> </ul> <p>Debugging Options:</p> <ul> <li><code>-L</code>, <code>--log-level</code> <code>LEVEL</code>: Set the log level: <code>DEBUG</code>, <code>INFO</code>, <code>WARNING</code>, <code>ERROR</code>, <code>CRITICAL</code>. Default: <code>INFO</code>.</li> </ul> <p>Common Options:</p> <ul> <li><code>-h</code>, <code>--help</code>: Show this help message and exit.</li> </ul>"},{"location":"cli_reference/#check","title":"check","text":"<p>Check for API breakages or possible improvements.</p> <p>Search Options:</p> <ul> <li><code>-s</code>, <code>--search</code>: Paths to search packages into.</li> </ul> <p>Loading Options:</p> <ul> <li><code>-e</code>, <code>--extensions</code>: A list of extensions to use.</li> <li><code>-X</code>, <code>--no-inspection</code>: Disallow inspection of builtin/compiled/not found modules. Default: <code>True</code>.</li> </ul> <p>Debugging Options:</p> <ul> <li><code>-L</code>, <code>--log-level</code> <code>LEVEL</code>: Set the log level: <code>DEBUG</code>, <code>INFO</code>, <code>WARNING</code>, <code>ERROR</code>, <code>CRITICAL</code>. Default: <code>INFO</code>.</li> </ul> <p>Common Options:</p> <ul> <li><code>-h</code>, <code>--help</code>: Show this help message and exit.</li> </ul> <p>Check Options:</p> <ul> <li><code>package</code> <code>PACKAGE</code>: Package to find, load and check, as path.</li> <li><code>-a</code>, <code>--against</code> <code>REF</code>: Older Git reference (commit, branch, tag) to check against. Default: load latest tag.</li> <li><code>-b</code>, <code>--base-ref</code> <code>BASE_REF</code>: Git reference (commit, branch, tag) to check. Default: load current code.</li> <li><code>--color</code>: Force enable colors in the output.</li> <li><code>--no-color</code>: Force disable colors in the output.</li> <li><code>-v</code>, <code>--verbose</code>: Verbose output.</li> </ul>"},{"location":"code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at pawamoy@pm.me. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"code_of_conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"code_of_conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"code_of_conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"code_of_conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p>"},{"location":"contributing/#environment-setup","title":"Environment setup","text":"<p>Nothing easier!</p> <p>Fork and clone the repository, then:</p> <pre><code>cd griffe\nmake setup\n</code></pre> <p>Note</p> <p> If it fails for some reason, you'll need to install PDM manually.</p> <p>You can install it with:</p> <pre><code>python3 -m pip install --user pipx\npipx install pdm\n</code></pre> <p>Now you can try running <code>make setup</code> again, or simply <code>pdm install</code>.</p> <p>You now have the dependencies installed.</p> <p>You can run the application with <code>pdm run griffe [ARGS...]</code>.</p> <p>Run <code>make help</code> to see all the available actions!</p>"},{"location":"contributing/#tasks","title":"Tasks","text":"<p>This project uses duty to run tasks. A Makefile is also provided. The Makefile will try to run certain tasks on multiple Python versions. If for some reason you don't want to run the task on multiple Python versions, you run the task directly with <code>pdm run duty TASK</code>.</p> <p>The Makefile detects if a virtual environment is activated, so <code>make</code> will work the same with the virtualenv activated or not.</p> <p>If you work in VSCode, see examples of tasks and run configurations.</p>"},{"location":"contributing/#development","title":"Development","text":"<p>As usual:</p> <ol> <li>create a new branch: <code>git switch -c feature-or-bugfix-name</code></li> <li>edit the code and/or the documentation</li> </ol> <p>Before committing:</p> <ol> <li>run <code>make format</code> to auto-format the code</li> <li>run <code>make check</code> to check everything (fix any warning)</li> <li>run <code>make test</code> to run the tests (fix any issue)</li> <li>if you updated the documentation or the project dependencies:<ol> <li>run <code>make docs</code></li> <li>go to http://localhost:8000 and check that everything looks good</li> </ol> </li> <li>follow our commit message convention</li> </ol> <p>If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review.</p> <p>Don't bother updating the changelog, we will take care of this.</p>"},{"location":"contributing/#commit-message-convention","title":"Commit message convention","text":"<p>Commit messages must follow our convention based on the Angular style or the Karma convention:</p> <pre><code>&lt;type&gt;[(scope)]: Subject\n\n[Body]\n</code></pre> <p>Subject and body must be valid Markdown. Subject must have proper casing (uppercase for first letter if it makes sense), but no dot at the end, and no punctuation in general.</p> <p>Scope and body are optional. Type can be:</p> <ul> <li><code>build</code>: About packaging, building wheels, etc.</li> <li><code>chore</code>: About packaging or repo/files management.</li> <li><code>ci</code>: About Continuous Integration.</li> <li><code>deps</code>: Dependencies update.</li> <li><code>docs</code>: About documentation.</li> <li><code>feat</code>: New feature.</li> <li><code>fix</code>: Bug fix.</li> <li><code>perf</code>: About performance.</li> <li><code>refactor</code>: Changes that are not features or bug fixes.</li> <li><code>style</code>: A change in code style/format.</li> <li><code>tests</code>: About tests.</li> </ul> <p>If you write a body, please add trailers at the end (for example issues and PR references, or co-authors), without relying on GitHub's flavored Markdown:</p> <pre><code>Body.\n\nIssue #10: https://github.com/namespace/project/issues/10\nRelated to PR namespace/other-project#15: https://github.com/namespace/other-project/pull/15\n</code></pre> <p>These \"trailers\" must appear at the end of the body, without any blank lines between them. The trailer title can contain any character except colons <code>:</code>. We expect a full URI for each trailer, not just GitHub autolinks (for example, full GitHub URLs for commits and issues, not the hash or the #issue-number).</p> <p>We do not enforce a line length on commit messages summary and body, but please avoid very long summaries, and very long lines in the body, unless they are part of code blocks that must not be wrapped.</p>"},{"location":"contributing/#pull-requests-guidelines","title":"Pull requests guidelines","text":"<p>Link to any related issue in the Pull Request message.</p> <p>During the review, we recommend using fixups:</p> <pre><code># SHA is the SHA of the commit you want to fix\ngit commit --fixup=SHA\n</code></pre> <p>Once all the changes are approved, you can squash your commits:</p> <pre><code>git rebase -i --autosquash main\n</code></pre> <p>And force-push:</p> <pre><code>git push -f\n</code></pre> <p>If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.</p>"},{"location":"credits/","title":"Credits","text":""},{"location":"credits/#exec-2--credits","title":"Credits","text":"<p>These projects were used to build griffe. Thank you!</p> <p><code>python</code> | <code>pdm</code> | <code>copier-pdm</code></p>"},{"location":"credits/#exec-2--runtime-dependencies","title":"Runtime dependencies","text":"Project Summary Version (accepted) Version (last resolved) License <code>colorama</code> Cross-platform colored terminal text. <code>&gt;=0.4</code> <code>0.4.6</code> BSD License"},{"location":"credits/#exec-2--development-dependencies","title":"Development dependencies","text":"Project Summary Version (accepted) Version (last resolved) License <code>ansimarkup</code> Produce colored terminal text with an xml-like markup <code>~=1.4</code> <code>1.5.0</code> Revised BSD License <code>attrs</code> Classes Without Boilerplate <code>&gt;=22.2.0</code> <code>23.1.0</code> MIT License <code>babel</code> Internationalization utilities <code>&gt;=2.10.3</code> <code>2.12.1</code> BSD <code>beautifulsoup4</code> Screen-scraping library <code>4.12.2</code> MIT License <code>black</code> The uncompromising code formatter. <code>&gt;=23.1</code> <code>23.7.0</code> MIT <code>blacken-docs</code> Run Black on Python code blocks in documentation files. <code>&gt;=1.13</code> <code>1.16.0</code> MIT <code>certifi</code> Python package for providing Mozilla's CA Bundle. <code>&gt;=2017.4.17</code> <code>2023.7.22</code> MPL-2.0 <code>charset-normalizer</code> The Real First Universal Charset Detector. Open, modern and actively maintained alternative to Chardet. <code>&lt;4,&gt;=2</code> <code>3.2.0</code> MIT <code>click</code> Composable command line interface toolkit <code>&gt;=8.0.0</code> <code>8.1.7</code> BSD-3-Clause <code>colorama</code> Cross-platform colored terminal text. <code>; platform_system == \"Windows\"</code> <code>0.4.6</code> BSD License <code>coverage</code> Code coverage measurement for Python <code>[toml]&gt;=5.2.1</code> <code>7.3.0</code> Apache-2.0 <code>csscompressor</code> A python port of YUI CSS Compressor <code>&gt;=0.9.5</code> <code>0.9.5</code> BSD <code>cssselect</code> cssselect parses CSS3 Selectors and translates them to XPath 1.0 <code>&gt;=1.2.0</code> <code>1.2.0</code> BSD <code>dparse</code> A parser for Python dependency files <code>&gt;=0.6.2</code> <code>0.6.3</code> MIT license <code>duty</code> A simple task runner. <code>&gt;=0.10</code> <code>1.0.0</code> ISC <code>exceptiongroup</code> Backport of PEP 654 (exception groups) <code>&gt;=1.0.0rc8; python_version &lt; \"3.11\"</code> <code>1.1.3</code> ? <code>execnet</code> execnet: rapid multi-Python deployment <code>&gt;=1.1</code> <code>2.0.2</code> MIT License <code>failprint</code> Run a command, print its output only if it fails. <code>&gt;=0.11</code> <code>1.0.1</code> ISC <code>ghp-import</code> Copy your docs directly to the gh-pages branch. <code>&gt;=1.0</code> <code>2.1.0</code> Apache Software License <code>git-changelog</code> Automatic Changelog generator using Jinja2 templates. <code>&gt;=1.0</code> <code>2.2.0</code> ISC <code>gitdb</code> Git Object Database <code>&lt;5,&gt;=4.0.1</code> <code>4.0.10</code> BSD License <code>gitpython</code> GitPython is a Python library used to interact with Git repositories <code>3.1.32</code> BSD <code>htmlmin2</code> An HTML Minifier <code>&gt;=0.1.13</code> <code>0.1.13</code> BSD <code>hypothesis</code> A library for property-based testing <code>[lark]&gt;=6.58.1</code> <code>6.82.7</code> MPL-2.0 <code>hypothesmith</code> Hypothesis strategies for generating Python programs, something like CSmith <code>&gt;=0.2.0</code> <code>0.2.3</code> MPL 2.0 <code>idna</code> Internationalized Domain Names in Applications (IDNA) <code>&lt;4,&gt;=2.5</code> <code>3.4</code> BSD License <code>importlib-metadata</code> Read metadata from Python packages <code>&gt;=4.3; python_version &lt; \"3.10\"</code> <code>6.8.0</code> ? <code>importlib-resources</code> Read resources from Python packages <code>&gt;=1.4.0; python_version &lt; \"3.9\"</code> <code>6.0.1</code> ? <code>iniconfig</code> brain-dead simple config-ini parsing <code>2.0.0</code> MIT License <code>jinja2</code> A very fast and expressive template engine. <code>&lt;4,&gt;=2.11</code> <code>3.1.2</code> BSD-3-Clause <code>jsmin</code> JavaScript minifier. <code>&gt;=3.0.1</code> <code>3.0.1</code> MIT License <code>jsonschema</code> An implementation of JSON Schema validation for Python <code>&gt;=4.17.3</code> <code>4.19.0</code> MIT <code>jsonschema-specifications</code> The JSON Schema meta-schemas and vocabularies, exposed as a Registry <code>&gt;=2023.03.6</code> <code>2023.7.1</code> MIT <code>lark</code> a modern parsing library <code>&gt;=0.10.1</code> <code>1.1.7</code> MIT <code>libcst</code> A concrete syntax tree with AST-like properties for Python 3.5, 3.6, 3.7, 3.8, 3.9, and 3.10 programs. <code>&gt;=0.4.0</code> <code>1.0.1</code> MIT License <code>lxml</code> Powerful and Pythonic XML processing library combining libxml2/libxslt with the ElementTree API. <code>&gt;=4.6</code> <code>4.9.3</code> BSD-3-Clause <code>markdown</code> Python implementation of John Gruber's Markdown. <code>&lt;4.0.0,&gt;=3.3.3</code> <code>3.4.4</code> BSD License <code>markdown-callouts</code> Markdown extension: a classier syntax for admonitions <code>&gt;=0.2</code> <code>0.3.0</code> MIT <code>markdown-exec</code> Utilities to execute code blocks in Markdown files. <code>&gt;=0.5</code> <code>1.6.0.1.0.1</code> ISC <code>markdown-it-py</code> Python port of markdown-it. Markdown parsing, done right! <code>&gt;=2.2.0</code> <code>3.0.0</code> MIT License <code>markdown2</code> A fast and complete Python implementation of Markdown <code>&gt;=2.4.3</code> <code>2.4.10</code> MIT <code>markupsafe</code> Safely add untrusted strings to HTML/XML markup. <code>&gt;=2.0</code> <code>2.1.3</code> BSD-3-Clause <code>mdurl</code> Markdown URL utilities <code>~=0.1</code> <code>0.1.2</code> MIT License <code>mergedeep</code> A deep merge function for \ud83d\udc0d. <code>&gt;=1.3.4</code> <code>1.3.4</code> MIT License <code>mkdocs</code> Project documentation with Markdown. <code>&gt;=1.5</code> <code>1.5.2</code> BSD License <code>mkdocs-coverage</code> MkDocs plugin to integrate your coverage HTML report into your site. <code>&gt;=0.2</code> <code>1.0.0</code> ISC <code>mkdocs-gen-files</code> MkDocs plugin to programmatically generate documentation pages during the build <code>&gt;=0.3</code> <code>0.5.0</code> MIT License <code>mkdocs-git-committers-plugin-2</code> An MkDocs plugin to create a list of contributors on the page <code>&gt;=1.1</code> <code>1.1.2</code> MIT <code>mkdocs-literate-nav</code> MkDocs plugin to specify the navigation in Markdown instead of YAML <code>&gt;=0.4</code> <code>0.6.0</code> MIT License <code>mkdocs-material</code> Documentation that simply works <code>&gt;=7.3</code> <code>9.2.5+insiders.4.40.1</code> MIT License <code>mkdocs-material-extensions</code> Extension pack for Python Markdown and MkDocs Material. <code>&gt;=1.1</code> <code>1.1.1</code> MIT License <code>mkdocs-minify-plugin</code> An MkDocs plugin to minify HTML, JS or CSS files prior to being written to disk <code>&gt;=0.6.4</code> <code>0.7.1</code> MIT <code>mkdocstrings</code> Automatic documentation from sources, for MkDocs. <code>[python]&gt;=0.18</code> <code>0.22.0</code> ISC <code>mkdocstrings-python</code> A Python handler for mkdocstrings. <code>&gt;=0.5.2</code> <code>1.6.0.1.4.0</code> ISC <code>mypy</code> Optional static typing for Python <code>&gt;=0.910</code> <code>1.5.1</code> MIT License <code>mypy-extensions</code> Type system extensions for programs checked with the mypy type checker. <code>&gt;=0.4.3</code> <code>1.0.0</code> MIT License <code>packaging</code> Core utilities for Python packages <code>&gt;=22.0</code> <code>23.1</code> BSD License <code>paginate</code> Divides large result sets into pages for easier browsing <code>&gt;=0.5.6</code> <code>0.5.6</code> MIT <code>pathspec</code> Utility library for gitignore style pattern matching of file paths. <code>&gt;=0.9.0</code> <code>0.11.2</code> Mozilla Public License 2.0 (MPL 2.0) <code>pkgutil-resolve-name</code> Resolve a name to an object. <code>&gt;=1.3.10; python_version &lt; \"3.9\"</code> <code>1.3.10</code> ? <code>platformdirs</code> A small Python package for determining appropriate platform-specific dirs, e.g. a \"user data dir\". <code>&gt;=2</code> <code>3.10.0</code> MIT License <code>pluggy</code> plugin and hook calling mechanisms for python <code>&lt;2.0,&gt;=0.12</code> <code>1.3.0</code> MIT <code>ptyprocess</code> Run a subprocess in a pseudo terminal <code>~=0.6; sys_platform != \"win32\"</code> <code>0.7.0</code> ISC License (ISCL) <code>pygments</code> Pygments is a syntax highlighting package written in Python. <code>&gt;=2.14</code> <code>2.16.1</code> BSD-2-Clause <code>pymdown-extensions</code> Extension pack for Python Markdown. <code>&gt;=9</code> <code>10.2</code> MIT License <code>pyquery</code> A jquery-like library for python <code>&gt;=1.2</code> <code>2.0.0</code> BSD <code>pytest</code> pytest: simple powerful testing with Python <code>&gt;=6.2</code> <code>7.4.0</code> MIT <code>pytest-cov</code> Pytest plugin for measuring coverage. <code>&gt;=3.0</code> <code>4.1.0</code> MIT <code>pytest-randomly</code> Pytest plugin to randomly order tests and control random.seed. <code>&gt;=3.10</code> <code>3.15.0</code> MIT <code>pytest-xdist</code> pytest xdist plugin for distributed testing, most importantly across multiple CPUs <code>&gt;=2.4</code> <code>3.3.1</code> MIT <code>python-dateutil</code> Extensions to the standard Python datetime module <code>&gt;=2.8.1</code> <code>2.8.2</code> Dual License <code>pytz</code> World timezone definitions, modern and historical <code>&gt;=2015.7; python_version &lt; \"3.9\"</code> <code>2023.3</code> ? <code>pyyaml</code> YAML parser and emitter for Python <code>&gt;=5.2</code> <code>6.0.1</code> MIT <code>pyyaml-env-tag</code> A custom YAML tag for referencing environment variables in YAML files. <code>&gt;=0.1</code> <code>0.1</code> MIT License <code>readtime</code> Calculates the time some text takes the average human to read, based on Medium's read time forumula <code>&gt;=2.0</code> <code>3.0.0</code> BSD <code>referencing</code> JSON Referencing + Python <code>&gt;=0.28.4</code> <code>0.30.2</code> MIT <code>regex</code> Alternative regular expression module, to replace re. <code>&gt;=2022.4.24</code> <code>2023.8.8</code> Apache Software License <code>requests</code> Python HTTP for Humans. <code>2.31.0</code> Apache 2.0 <code>rich</code> Render rich text, tables, progress bars, syntax highlighting, markdown and more to the terminal <code>&gt;=12.6.0</code> <code>13.5.2</code> MIT <code>rpds-py</code> Python bindings to Rust's persistent data structures (rpds) <code>&gt;=0.7.1</code> <code>0.10.0</code> MIT <code>ruamel-yaml</code> ruamel.yaml is a YAML parser/emitter that supports roundtrip preservation of comments, seq/map flow style, and map key order <code>&gt;=0.17.21</code> <code>0.17.32</code> MIT license <code>ruamel-yaml-clib</code> C version of reader, parser and emitter for ruamel.yaml derived from libyaml <code>&gt;=0.2.7; platform_python_implementation == \"CPython\" and python_version &lt; \"3.12\"</code> <code>0.2.7</code> MIT <code>ruff</code> An extremely fast Python linter, written in Rust. <code>&gt;=0.0.246</code> <code>0.0.286</code> MIT <code>safety</code> Checks installed dependencies for known vulnerabilities and licenses. <code>&gt;=2</code> <code>2.3.4</code> MIT license <code>semver</code> Python helper for Semantic Versioning (https://semver.org) <code>&gt;=2.13</code> <code>3.0.1</code> BSD <code>setuptools</code> Easily download, build, install, upgrade, and uninstall Python packages <code>&gt;=19.3</code> <code>68.1.2</code> MIT License <code>six</code> Python 2 and 3 compatibility utilities <code>&gt;=1.5</code> <code>1.16.0</code> MIT <code>smmap</code> A pure Python implementation of a sliding window memory map manager <code>&lt;6,&gt;=3.0.1</code> <code>5.0.0</code> BSD <code>soupsieve</code> A modern CSS selector implementation for Beautiful Soup. <code>&gt;1.2</code> <code>2.4.1</code> MIT License <code>toml</code> Python Library for Tom's Obvious, Minimal Language <code>&gt;=0.10</code> <code>0.10.2</code> MIT <code>tomli</code> A lil' TOML parser <code>&gt;=1.1.0; python_version &lt; \"3.11\"</code> <code>2.0.1</code> ? <code>types-markdown</code> Typing stubs for Markdown <code>&gt;=3.3</code> <code>3.4.2.10</code> Apache-2.0 license <code>types-pyyaml</code> Typing stubs for PyYAML <code>&gt;=6.0</code> <code>6.0.12.11</code> Apache-2.0 license <code>types-toml</code> Typing stubs for toml <code>&gt;=0.10</code> <code>0.10.8.7</code> Apache-2.0 license <code>typing-extensions</code> Backported and Experimental Type Hints for Python 3.7+ <code>&gt;=3.10.0.0; python_version &lt; \"3.10\"</code> <code>4.7.1</code> Python Software Foundation License <code>typing-inspect</code> Runtime inspection utilities for typing module. <code>&gt;=0.4.0</code> <code>0.9.0</code> MIT <code>urllib3</code> HTTP library with thread-safe connection pooling, file post, and more. <code>&lt;3,&gt;=1.21.1</code> <code>2.0.4</code> MIT License <code>watchdog</code> Filesystem events monitoring <code>&gt;=2.0</code> <code>3.0.0</code> Apache License 2.0 <code>zipp</code> Backport of pathlib-compatible object wrapper for zip files <code>&gt;=0.5</code> <code>3.16.2</code> ? <p>More credits from the author</p>"},{"location":"docstrings/","title":"Docstrings","text":"<p>Griffe provides different docstring parsers allowing to extract even more structured data from source code.</p> <p>The available parsers are:</p> <ul> <li><code>google</code>, to parse Google-style docstrings,     see Napoleon's documentation</li> <li><code>numpy</code>, to parse Numpydoc docstrings,     see Numpydoc's documentation</li> <li><code>sphinx</code>, to parse Sphinx-style docstrings,     see Sphinx's documentation</li> </ul>"},{"location":"docstrings/#syntax","title":"Syntax","text":"<p>Most of the time, the syntax specified in the aforementioned docs is supported. In some cases, the original syntax is not supported, or is supported but with subtle differences. We will try to document these differences in the following sections.</p> <p>No assumption is made on the markup used in docstrings: it's retrieved as regular text. Tooling making use of Griffe can then choose to render the text as if it is Markdown, or AsciiDoc, or reStructuredText, etc..</p>"},{"location":"docstrings/#google-style","title":"Google-style","text":"<p>Sections are written like this:</p> <pre><code>section identifier: optional section title\n    section contents\n</code></pre> <p>All sections identifiers are case-insensitive. All sections support multiple lines in descriptions, as well as blank lines. The first line must not be blank. Each section must be separated from contents above by a blank line.</p> <p>\u274c This is invalid and will be parsed as regular markup:</p> <pre><code>Some text.\nNote: # (1)!\n    Some information.\n\n    Blank lines allowed.\n</code></pre> <ol> <li>Missing blank line above.</li> </ol> <p>\u274c This is invalid and will be parsed as regular markup:</p> <pre><code>Some text.\n\nNote: # (1)!\n\n    Some information.\n\n    Blank lines allowed.\n</code></pre> <ol> <li>Extraneous blank line below.</li> </ol> <p>\u2705 This is valid and will parsed as a text section followed by a note admonition:</p> <pre><code>Some text.\n\nNote:\n    Some information.\n\n    Blank lines allowed.\n</code></pre> <p>Find out possibly invalid section syntax by grepping for \"reasons\" in Griffe debug logs:</p> <pre><code>griffe dump -Ldebug -o/dev/null \\\n-fdgoogle -D '{\"strict_sections\": true}' \\\nyour_package 2&gt;&amp;1 | grep reasons\n</code></pre> <p>Some sections support documenting multiple items (attributes, parameters, etc.). When multiple items are supported, each item description can use multiple lines, and continuation lines must be indented once more so that the parser is able to differentiate items.</p> <pre><code>def foo(a, b):\n\"\"\"Foo.\n\n    Parameters:\n        a: Here's a.\n            Continuation line 1.\n\n            Continuation line 2.\n        b: Here's b.\n    \"\"\"\n</code></pre> <p>It's possible to start a description with a newline if you find it less confusing:</p> <pre><code>def foo(a, b):\n\"\"\"Foo.\n\n    Parameters:\n        a:\n            Here's a.\n            Continuation line 1.\n\n            Continuation line 2.\n        b: Here's b.\n    \"\"\"\n</code></pre>"},{"location":"docstrings/#parser-options","title":"Parser options","text":"<p>The parser accepts a few options:</p> <ul> <li><code>ignore_init_summary</code>: Ignore the first line in <code>__init__</code> methods' docstrings.     Useful when merging <code>__init__</code> docstring into class' docstrings. Default: false.     with mkdocstrings-python's <code>merge_init_into_class</code> option. Default: false.</li> <li><code>returns_multiple_items</code>: Parse Returns sections as if they contain multiple items.     It means that continuation lines must be indented. Default: true.</li> <li><code>returns_named_value</code>: Whether to parse <code>thing: Description</code> in Returns sections as a name and description,     rather than a type and description. When true, type must be wrapped in parentheses: <code>(int): Description.</code>.     When false, parentheses are optional but the items cannot be named: <code>int: Description</code>. Default: true.</li> <li><code>returns_type_in_property_summary</code>: Whether to parse the return type of properties     at the beginning of their summary: <code>str: Summary of the property</code>. Default: false.</li> <li><code>trim_doctest_flags</code>: Remove the doctest flags written as comments in <code>pycon</code> snippets within a docstring.     These flags are used to alter the behavior of doctest when testing docstrings,     and should not be visible in your docs. Default: true.</li> <li><code>warn_unknown_params</code>: Warn about parameters documented in docstrings that do not appear in the signature. Default: true.</li> </ul>"},{"location":"docstrings/#attributes","title":"Attributes","text":"<ul> <li>Multiple items allowed</li> </ul> <p>Attributes sections allow to document attributes of a module, class, or class instance. They should be used in modules and classes docstrings only.</p> <pre><code>\"\"\"My module.\n\nAttributes:\n    foo: Description for `foo`.\n    bar: Description for `bar`.\n\"\"\"\n\nfoo: int = 0\nbar: bool = True\n\n\nclass MyClass:\n\"\"\"My class.\n\n    Attributes:\n        foofoo: Description for `foofoo`.\n        barbar: Description for `barbar`.\n    \"\"\"\n\n    foofoo: int = 0\n\n    def __init__(self):\n        self.barbar: bool = True\n</code></pre> <p>Type annotations are fetched from the related attributes definitions. You can override those by adding types between parentheses before the colon:</p> <pre><code>\"\"\"My module.\n\nAttributes:\n    foo (Integer): Description for `foo`.\n    bar (Boolean): Description for `bar`.\n\"\"\"\n</code></pre> <p>Types in docstrings are resolved using the docstrings' parent scope.</p> <p>When documenting an attribute with <code>attr_name (attr_type): Attribute description</code>, <code>attr_type</code> will be resolved using the scope of the docstrings' parent object (class or module). For example, a type of <code>list[str]</code> will be parsed just as if it was an actual Python annotation. You can therefore use complex types (available in the current scope) in docstrings, for example <code>Optional[Union[int, Tuple[float, float]]]</code>.</p>"},{"location":"docstrings/#functionsmethods","title":"Functions/Methods","text":"<ul> <li>Multiple items allowed</li> </ul> <p>Functions or Methods sections allow to document functions of a module, or methods of a class. They should be used in modules and classes docstrings only.</p> <pre><code>\"\"\"My module.\n\nFunctions:\n    foo: Description for `foo`.\n    bar: Description for `bar`.\n\"\"\"\n\n\ndef foo():\n    return \"foo\"\n\n\ndef bar(baz: int) -&gt; int:\n    return baz * 2\n\n\nclass MyClass:\n\"\"\"My class.\n\n    Methods:\n        foofoo: Description for `foofoo`.\n        barbar: Description for `barbar`.\n    \"\"\"\n\n    def foofoo(self):\n        return \"foofoo\"\n\n    @staticmethod\n    def barbar():\n        return \"barbar\"\n</code></pre> <p>It's possible to write the function/method signature as well as its name:</p> <pre><code>\"\"\"\nFunctions:\n    foo(): Description for `foo`.\n    bar(baz=1): Description for `bar`.\n\"\"\"\n</code></pre> <p>The signatures do not have to match the real ones: you can shorten them to only show the important parameters.</p>"},{"location":"docstrings/#classes","title":"Classes","text":"<ul> <li>Multiple items allowed</li> </ul> <p>Classes sections allow to document classes of a module or class. They should be used in modules and classes docstrings only.</p> <pre><code>\"\"\"My module.\n\nClasses:\n    Foo: Description for `foo`.\n    Bar: Description for `bar`.\n\"\"\"\n\n\nclass Foo:\n    ...\n\n\nclass Bar:\n    def __init__(self, baz: int) -&gt; int:\n        return baz * 2\n\n\nclass MyClass:\n\"\"\"My class.\n\n    Classes:\n        FooFoo: Description for `foofoo`.\n        BarBar: Description for `barbar`.\n    \"\"\"\n\n    class FooFoo:\n        ...\n\n    class BarBar:\n        ...\n</code></pre> <p>It's possible to write the class signature as well as its name:</p> <pre><code>\"\"\"\nFunctions:\n    Foo(): Description for `Foo`.\n    Bar(baz=1): Description for `Bar`.\n\"\"\"\n</code></pre> <p>The signatures do not have to match the real ones: you can shorten them to only show the important initialization parameters.</p>"},{"location":"docstrings/#modules","title":"Modules","text":"<ul> <li>Multiple items allowed</li> </ul> <p>Modules sections allow to document submodules of a module. They should be used in modules docstrings only.</p> <pre><code>\ud83d\udcc1 my_pkg/\n\u251c\u2500\u2500 \ud83d\udcc4 __init__.py\n\u251c\u2500\u2500 \ud83d\udcc4 foo.py\n\u2514\u2500\u2500 \ud83d\udcc4 bar.py\n</code></pre> my_pkg/__init__.py<pre><code>\"\"\"My package.\n\nModules:\n    foo: Description for `foo`.\n    bar: Description for `bar`.\n\"\"\"\n</code></pre>"},{"location":"docstrings/#deprecated","title":"Deprecated","text":"<p>Deprecated sections allow to document a deprecation that happened at a particular version. They can be used in every docstring.</p> <pre><code>\"\"\"My module.\n\nDeprecated:\n    1.2: The `foo` attribute is deprecated.\n\"\"\"\n\nfoo: int = 0\n</code></pre>"},{"location":"docstrings/#examples","title":"Examples","text":"<p>Examples sections allow to add examples of Python code without the use of markup code blocks. They are a mix of prose and interactive console snippets. They can be used in every docstring.</p> <pre><code>\"\"\"My module.\n\nExamples:\n    Some explanation of what is possible.\n\n    &gt;&gt;&gt; print(\"hello!\")\n    hello!\n\n    Blank lines delimit prose vs. console blocks.\n\n    &gt;&gt;&gt; a = 0\n    &gt;&gt;&gt; a += 1\n    &gt;&gt;&gt; a\n    1\n\"\"\"\n</code></pre> <p>Not the same as Example sections.</p> <p>Example (singular) sections are parsed as admonitions. Console code blocks will only be understood in Examples (plural) sections.</p>"},{"location":"docstrings/#parameters","title":"Parameters","text":"<ul> <li>Aliases: Args, Arguments, Params</li> <li>Multiple items allowed</li> </ul> <p>Parameters sections allow to document parameters of a function. They are typically used in functions docstrings, but can also be used in dataclasses docstrings.</p> <pre><code>def foo(a: int, b: str):\n\"\"\"Foo.\n\n    Parameters:\n        a: Here's a.\n        b: Here's b.\n    \"\"\"\n</code></pre> <pre><code>from dataclasses import dataclass\n\n\n@dataclass\nclass Foo:\n\"\"\"Foo.\n\n    Parameters:\n        a: Here's a.\n        b: Here's b.\n    \"\"\"\n\n    foo: int\n    bar: str\n</code></pre> <p>Type annotations are fetched from the related parameters definitions. You can override those by adding types between parentheses before the colon:</p> <pre><code>\"\"\"My function.\n\nParameters:\n    foo (Integer): Description for `foo`.\n    bar (String): Description for `bar`.\n\"\"\"\n</code></pre> <p>Types in docstrings are resolved using the docstrings' parent scope.</p> <p>When documenting a parameter with <code>param_name (param_type): Parameter description</code>, <code>param_type</code> will be resolved using the scope of the function (or class). For example, a type of <code>list[str]</code> will be parsed just as if it was an actual Python annotation. You can therefore use complex types (available in the current scope) in docstrings, for example <code>Optional[Union[int, Tuple[float, float]]]</code>.</p>"},{"location":"docstrings/#other-parameters","title":"Other Parameters","text":"<ul> <li>Aliases: Keyword Args, Keyword Arguments, Other Args, Other Arguments, Other Params</li> <li>Multiple items allowed</li> </ul> <p>Other parameters sections allow to document secondary parameters such as variadic keyword arguments, or parameters that should be of lesser interest to the user. They are used the same way Parameters sections are, but can also be useful in decorators / to document returned callables.</p> <pre><code>def foo(a, b, **kwargs):\n\"\"\"Foo.\n\n    Parameters:\n        a: Here's a.\n        b: Here's b.\n\n    Other parameters:\n        c (int): Here's c.\n        d (bool): Here's d.\n    \"\"\"\n</code></pre> <pre><code>def foo(a, b):\n\"\"\"Returns a callable.\n\n    Parameters:\n        a: Here's a.\n        b: Here's b.\n\n    Other parameters: Parameters of the returned callable:\n        c (int): Here's c.\n        d (bool): Here's d.\n    \"\"\"\n\n    def inner(c, d):\n        ...\n\n    return inner\n</code></pre> <p>Types in docstrings are resolved using the docstrings' parent scope.</p> <p>See the same tip for parameters.</p>"},{"location":"docstrings/#raises","title":"Raises","text":"<ul> <li>Aliases: Exceptions</li> <li>Multiple items allowed</li> </ul> <p>Raises sections allow to document exceptions that are raised by a function. They are usually only used in functions docstrings.</p> <pre><code>def foo(a: int):\n\"\"\"Foo.\n\n    Parameters:\n        a: A value.\n\n    Raises:\n        ValueError: When `a` is less than 0.\n    \"\"\"\n    if a &lt; 0:\n        raise ValueError(\"message\")\n</code></pre> <p>Exceptions names are resolved using the function's scope.</p> <p><code>ValueError</code> and other built-in exceptions are resolved as such. You can document custom exception, using the names available in the current scope, for example <code>my_exceptions.MyCustomException</code> or <code>MyCustomException</code> directly, depending on what you imported/defined in the current module.</p>"},{"location":"docstrings/#warns","title":"Warns","text":"<ul> <li>Aliases: Warnings</li> <li>Multiple items allowed</li> </ul> <p>Warns sections allow to document warnings emitted by the following code. They are usually only used in functions docstrings.</p> <pre><code>import warnings\n\n\ndef foo():\n\"\"\"Foo.\n\n    Warns:\n        UserWarning: To annoy users.\n    \"\"\"\n    warnings.warn(\"Just messing with you.\", UserWarning)\n</code></pre> <p>Warnings names are resolved using the function's scope.</p> <p><code>UserWarning</code> and other built-in warnings are resolved as such. You can document custom warnings, using the names available in the current scope, for example <code>my_warnings.MyCustomWarning</code> or <code>MyCustomWarning</code> directly, depending on what you imported/defined in the current module.</p>"},{"location":"docstrings/#yields","title":"Yields","text":"<ul> <li>Multiple items allowed</li> </ul> <p>Yields sections allow to document values that generator yield. They should be used only in generators docstrings. Documented items can be given a name when it makes sense.</p> <pre><code>from typing import Iterator\n\n\ndef foo() -&gt; Iterator[int]:\n\"\"\"Foo.\n\n    Yields:\n        Integers from 0 to 9.\n    \"\"\"\n    for i in range(10):\n        yield i\n</code></pre> <p>Type annotations are fetched from the function return annotation when the annotation is <code>typing.Generator</code> or <code>typing.Iterator</code>. If your generator yields tuples, you can document each item of the tuple separately, and the type annotation will be fetched accordingly:</p> <pre><code>from datetime import datetime\n\n\ndef foo() -&gt; Iterator[tuple[float, float, datetime]]:\n\"\"\"Foo.\n\n    Yields:\n        x: Absissa.\n        y: Ordinate.\n        t: Time.\n\n    ...\n    \"\"\"\n    ...\n</code></pre> <p>Type annotations can as usual be overridden using types in parentheses in the docstring itself:</p> <pre><code>\"\"\"Foo.\n\nYields:\n    x (int): Absissa.\n    y (int): Ordinate.\n    t (int): Timestamp.\n\"\"\"\n</code></pre> <p>Types in docstrings are resolved using the docstrings' parent scope.</p> <p>See previous tips for types in docstrings.</p>"},{"location":"docstrings/#receives","title":"Receives","text":"<ul> <li>Multiple items allowed</li> </ul> <p>Receives sections allow to document values that can be sent to generators using their <code>send</code> method. They should be used only in generators docstrings. Documented items can be given a name when it makes sense.</p> <pre><code>from typing import Generator\n\n\ndef foo() -&gt; Generator[int, str, None]:\n\"\"\"Foo.\n\n    Receives:\n        reverse: Reverse the generator if `\"reverse\"` is received.\n\n    Yields:\n        Integers from 0 to 9.\n\n    Examples:\n        &gt;&gt;&gt; gen = foo()\n        &gt;&gt;&gt; next(gen)\n        0\n        &gt;&gt;&gt; next(gen)\n        1\n        &gt;&gt;&gt; next(gen)\n        2\n        &gt;&gt;&gt; gen.send(\"reverse\")\n        2\n        &gt;&gt;&gt; next(gen)\n        1\n        &gt;&gt;&gt; next(gen)\n        0\n        &gt;&gt;&gt; next(gen)\n        Traceback (most recent call last):\n          File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n        StopIteration\n    \"\"\"\n    for i in range(10):\n        received = yield i\n        if received == \"reverse\":\n            for j in range(i, -1, -1):\n                yield j\n            break\n</code></pre> <p>Type annotations are fetched from the function return annotation when the annotation is <code>typing.Generator</code>. If your generator is able to receive tuples, you can document each item of the tuple separately, and the type annotation will be fetched accordingly:</p> <pre><code>def foo() -&gt; Generator[int, tuple[str, bool], None]:\n\"\"\"Foo.\n\n    Receives:\n        mode: Some mode.\n        flag: Some flag.\n\n    ...\n    \"\"\"\n    ...\n</code></pre> <p>Type annotations can as usual be overridden using types in parentheses in the docstring itself:</p> <pre><code>\"\"\"Foo.\n\nReceives:\n    mode (ModeEnum): Some mode.\n    flag (int): Some flag.\n\"\"\"\n</code></pre> <p>Types in docstrings are resolved using the docstrings' parent scope.</p> <p>See previous tips for types in docstrings.</p>"},{"location":"docstrings/#returns","title":"Returns","text":"<ul> <li>Multiple items allowed</li> </ul> <p>Returns sections allow to document values returned by functions. They should be used only in functions docstrings. Documented items can be given a name when it makes sense.</p> <pre><code>import random\n\n\ndef foo() -&gt; int:\n\"\"\"Foo.\n\n    Returns:\n        A random integer.\n    \"\"\"\n    return random.randint(0, 100)\n</code></pre> <p>Type annotations are fetched from the function return annotation. If your function returns tuples of values, you can document each item of the tuple separately, and the type annotation will be fetched accordingly:</p> <pre><code>def foo() -&gt; tuple[bool, float]:\n\"\"\"Foo.\n\n    Returns:\n        success: Whether it succeeded.\n        precision: Final precision.\n\n    ...\n    \"\"\"\n    ...\n</code></pre> <p>You have to indent each continuation line when documenting returned values, even if there's only one value returned:</p> <pre><code>\"\"\"Foo.\n\nReturns:\n    success: Whether it succeeded.\n        A longer description of what is considered success,\n        and what is considered failure.\n\"\"\"\n</code></pre> <p>If you don't want to indent continuation lines for the only returned value, use the <code>returns_multiple_items=False</code> parser option.</p> <p>Type annotations can as usual be overridden using types in parentheses in the docstring itself:</p> <pre><code>\"\"\"Foo.\n\nReturns:\n    success (int): Whether it succeeded.\n    precision (Decimal): Final precision.\n\"\"\"\n</code></pre> <p>If you want to specify the type without a name, you still have to wrap the type in parentheses:</p> <pre><code>\"\"\"Foo.\n\nReturns:\n    (int): Whether it succeeded.\n    (Decimal): Final precision.\n\"\"\"\n</code></pre> <p>If you don't want to wrap the type in parentheses, use the <code>returns_named_value=False</code> parser option. Setting it to false will disallow specifying a name.</p> <p>Types in docstrings are resolved using the docstrings' function scope.</p> <p>See previous tips for types in docstrings.</p> <p>Continuation lines for a single returned item must still be indented.</p> <p>Even when your function returns a single value, you must indent continuation lines of its description so that the parser does not think you are documenting multiple items.</p>"},{"location":"docstrings/#numpydoc-style","title":"Numpydoc-style","text":"<p>Sections are written like this:</p> <pre><code>section identifier\n------------------\nsection contents\n</code></pre> <p>All sections identifiers are case-insensitive. All sections support multiple lines in descriptions.</p> <p>Some sections support documenting items items. Item descriptions start on a new, indented line. When multiple items are supported, each item description can use multiple lines.</p> <pre><code>def foo(a, b):\n\"\"\"Foo.\n\n    Parameters\n    ----------\n    a\n        Here's a.\n        Continuation line 1.\n\n        Continuation line 2.\n    b\n        Here's b.\n    \"\"\"\n</code></pre> <p>For items that have an optional name and type, several syntaxes are supported:</p> <ul> <li> <p>specifying both the name and type:</p> <pre><code>\"\"\"\nname : type\n    description\n\"\"\"\n</code></pre> </li> <li> <p>specifying just the name:</p> <pre><code>\"\"\"\nname\n    description\n\"\"\"\n</code></pre> <p>or</p> <pre><code>\"\"\"\nname :\n    description\n\"\"\"\n</code></pre> </li> <li> <p>specifying just the type:</p> <pre><code>\"\"\"\n: type\n    description\n\"\"\"\n</code></pre> </li> <li> <p>specifying neither the name nor type:</p> <pre><code>\"\"\"\n:\n    description\n\"\"\"\n</code></pre> </li> </ul>"},{"location":"docstrings/#parser-options_1","title":"Parser options","text":"<p>The parser accepts a few options:</p> <ul> <li><code>ignore_init_summary</code>: Ignore the first line in <code>__init__</code> methods' docstrings.     Useful when merging <code>__init__</code> docstring into class' docstrings     with mkdocstrings-python's <code>merge_init_into_class</code> option. Default: false.</li> <li><code>trim_doctest_flags</code>: Remove the doctest flags written as comments in <code>pycon</code> snippets within a docstring.     These flags are used to alter the behavior of doctest when testing docstrings,     and should not be visible in your docs. Default: true.</li> <li><code>warn_unknown_params</code>: Warn about parameters documented in docstrings that do not appear in the signature. Default: true.</li> <li><code>allow_section_blank_line</code>: Allow blank lines in sections' content.     When false, a blank line finishes the current section.     When true, single blank lines are kept as part of the section.     You can terminate sections with double blank lines. Default: false.</li> </ul>"},{"location":"docstrings/#attributes_1","title":"Attributes","text":"<ul> <li>Multiple items allowed</li> </ul> <p>Attributes sections allow to document attributes of a module, class, or class instance. They should be used in modules and classes docstrings only.</p> <pre><code>\"\"\"My module.\n\nAttributes\n----------\nfoo\n    Description for `foo`.\nbar\n    Description for `bar`.\n\"\"\"\n\nfoo: int = 0\nbar: bool = True\n\n\nclass MyClass:\n\"\"\"My class.\n\n    Attributes\n    ----------\n    foofoo\n        Description for `foofoo`.\n    barbar\n        Description for `barbar`.\n    \"\"\"\n\n    foofoo: int = 0\n\n    def __init__(self):\n        self.barbar: bool = True\n</code></pre> <p>Type annotations are fetched from the related attributes definitions. You can override those by adding types between parentheses before the colon:</p> <pre><code>\"\"\"My module.\n\nAttributes\n----------\nfoo : Integer\n    Description for `foo`.\nbar : Boolean\n    Description for `bar`.\n\"\"\"\n</code></pre> <p>Types in docstrings are resolved using the docstrings' parent scope.</p> <p>When documenting an attribute with <code>attr_name : attr_type</code>, <code>attr_type</code> will be resolved using the scope of the docstrings' parent object (class or module). For example, a type of <code>list[str]</code> will be parsed just as if it was an actual Python annotation. You can therefore use complex types (available in the current scope) in docstrings, for example <code>Optional[Union[int, Tuple[float, float]]]</code>.</p>"},{"location":"docstrings/#functionsmethods_1","title":"Functions/Methods","text":"<ul> <li>Multiple items allowed</li> </ul> <p>Functions or Methods sections allow to document functions of a module, or methods of a class. They should be used in modules and classes docstrings only.</p> <pre><code>\"\"\"My module.\n\nFunctions\n---------\nfoo\n    Description for `foo`.\nbar\n    Description for `bar`.\n\"\"\"\n\n\ndef foo():\n    return \"foo\"\n\n\ndef bar(baz: int) -&gt; int:\n    return baz * 2\n\n\nclass MyClass:\n\"\"\"My class.\n\n    Methods\n    -------\n    foofoo\n        Description for `foofoo`.\n    barbar\n        Description for `barbar`.\n    \"\"\"\n\n    def foofoo(self):\n        return \"foofoo\"\n\n    @staticmethod\n    def barbar():\n        return \"barbar\"\n</code></pre> <p>It's possible to write the function/method signature as well as its name:</p> <pre><code>\"\"\"\nFunctions\n---------\nfoo()\n    Description for `foo`.\nbar(baz=1)\n    Description for `bar`.\n\"\"\"\n</code></pre> <p>The signatures do not have to match the real ones: you can shorten them to only show the important parameters.</p>"},{"location":"docstrings/#classes_1","title":"Classes","text":"<ul> <li>Multiple items allowed</li> </ul> <p>Classes sections allow to document classes of a module or class. They should be used in modules and classes docstrings only.</p> <pre><code>\"\"\"My module.\n\nClasses\n-------\nFoo\n    Description for `foo`.\nBar\n    Description for `bar`.\n\"\"\"\n\n\nclass Foo:\n    ...\n\n\nclass Bar:\n    def __init__(self, baz: int) -&gt; int:\n        return baz * 2\n\n\nclass MyClass:\n\"\"\"My class.\n\n    Classes\n    -------\n    FooFoo\n        Description for `foofoo`.\n    BarBar\n        Description for `barbar`.\n    \"\"\"\n\n    class FooFoo:\n        ...\n\n    class BarBar:\n        ...\n</code></pre> <p>It's possible to write the class signature as well as its name:</p> <pre><code>\"\"\"\nFunctions\n---------\nFoo()\n    Description for `Foo`.\nBar(baz=1)\n    Description for `Bar`.\n\"\"\"\n</code></pre> <p>The signatures do not have to match the real ones: you can shorten them to only show the important initialization parameters.</p>"},{"location":"docstrings/#modules_1","title":"Modules","text":"<ul> <li>Multiple items allowed</li> </ul> <p>Modules sections allow to document submodules of a module. They should be used in modules docstrings only.</p> <pre><code>\ud83d\udcc1 my_pkg/\n\u251c\u2500\u2500 \ud83d\udcc4 __init__.py\n\u251c\u2500\u2500 \ud83d\udcc4 foo.py\n\u2514\u2500\u2500 \ud83d\udcc4 bar.py\n</code></pre> my_pkg/__init__.py<pre><code>\"\"\"My package.\n\nModules\n-------\nfoo\n    Description for `foo`.\nbar\n    Description for `bar`.\n\"\"\"\n</code></pre>"},{"location":"docstrings/#deprecated_1","title":"Deprecated","text":"<p>Deprecated sections allow to document a deprecation that happened at a particular version. They can be used in every docstring.</p> <pre><code>\"\"\"My module.\n\nDeprecated\n----------\n    1.2\n        The `foo` attribute is deprecated.\n\"\"\"\n\nfoo: int = 0\n</code></pre>"},{"location":"docstrings/#examples_1","title":"Examples","text":"<p>Examples sections allow to add examples of Python code without the use of markup code blocks. They are a mix of prose and interactive console snippets. They can be used in every docstring.</p> <pre><code>\"\"\"My module.\n\nExamples\n--------\nSome explanation of what is possible.\n\n&gt;&gt;&gt; print(\"hello!\")\nhello!\n\nBlank lines delimit prose vs. console blocks.\n\n&gt;&gt;&gt; a = 0\n&gt;&gt;&gt; a += 1\n&gt;&gt;&gt; a\n1\n\"\"\"\n</code></pre>"},{"location":"docstrings/#parameters_1","title":"Parameters","text":"<ul> <li>Aliases: Args, Arguments, Params</li> <li>Multiple items allowed</li> </ul> <p>Parameters sections allow to document parameters of a function. They are typically used in functions docstrings, but can also be used in dataclasses docstrings.</p> <pre><code>def foo(a: int, b: str):\n\"\"\"Foo.\n\n    Parameters\n    ----------\n    a\n        Here's a.\n    b\n        Here's b.\n    \"\"\"\n</code></pre> <pre><code>from dataclasses import dataclass\n\n\n@dataclass\nclass Foo:\n\"\"\"Foo.\n\n    Parameters\n    ----------\n    a\n        Here's a.\n    b\n        Here's b.\n    \"\"\"\n\n    foo: int\n    bar: str\n</code></pre> <p>Type annotations are fetched from the related parameters definitions. You can override those by adding types between parentheses before the colon:</p> <pre><code>\"\"\"My function.\n\nParameters\n----------\nfoo : Integer\n    Description for `foo`.\nbar : String\n    Description for `bar`.\n\"\"\"\n</code></pre> <p>Types in docstrings are resolved using the docstrings' parent scope.</p> <p>When documenting a parameter with <code>param_name : param_type</code>, <code>param_type</code> will be resolved using the scope of the function (or class). For example, a type of <code>list[str]</code> will be parsed just as if it was an actual Python annotation. You can therefore use complex types (available in the current scope) in docstrings, for example <code>Optional[Union[int, Tuple[float, float]]]</code>.</p>"},{"location":"docstrings/#other-parameters_1","title":"Other Parameters","text":"<ul> <li>Aliases: Keyword Args, Keyword Arguments, Other Args, Other Arguments, Other Params</li> <li>Multiple items allowed</li> </ul> <p>Other parameters sections allow to document secondary parameters such as variadic keyword arguments, or parameters that should be of lesser interest to the user. They are used the same way Parameters sections are.</p> <pre><code>def foo(a, b, **kwargs):\n\"\"\"Foo.\n\n    Parameters\n    ----------\n    a\n        Here's a.\n    b\n        Here's b.\n\n    Other parameters\n    ----------------\n    c : int\n        Here's c.\n    d : bool\n        Here's d.\n    \"\"\"\n</code></pre> <p>Types in docstrings are resolved using the docstrings' parent scope.</p> <p>See the same tip for parameters.</p>"},{"location":"docstrings/#raises_1","title":"Raises","text":"<ul> <li>Aliases: Exceptions</li> <li>Multiple items allowed</li> </ul> <p>Raises sections allow to document exceptions that are raised by a function. They are usually only used in functions docstrings.</p> <pre><code>def foo(a: int):\n\"\"\"Foo.\n\n    Parameters\n    ----------\n    a\n        A value.\n\n    Raises\n    ------\n    ValueError\n        When `a` is less than 0.\n    \"\"\"\n    if a &lt; 0:\n        raise ValueError(\"message\")\n</code></pre> <p>Exceptions names are resolved using the function's scope.</p> <p><code>ValueError</code> and other built-in exceptions are resolved as such. You can document custom exception, using the names available in the current scope, for example <code>my_exceptions.MyCustomException</code> or <code>MyCustomException</code> directly, depending on what you imported/defined in the current module.</p>"},{"location":"docstrings/#warns_1","title":"Warns","text":"<ul> <li>Aliases: Warnings</li> <li>Multiple items allowed</li> </ul> <p>Warns sections allow to document warnings emitted by the following code. They are usually only used in functions docstrings.</p> <pre><code>import warnings\n\n\ndef foo():\n\"\"\"Foo.\n\n    Warns\n    -----\n    UserWarning\n        To annoy users.\n    \"\"\"\n    warnings.warn(\"Just messing with you.\", UserWarning)\n</code></pre> <p>Warnings names are resolved using the function's scope.</p> <p><code>UserWarning</code> and other built-in warnings are resolved as such. You can document custom warnings, using the names available in the current scope, for example <code>my_warnings.MyCustomWarning</code> or <code>MyCustomWarning</code> directly, depending on what you imported/defined in the current module.</p>"},{"location":"docstrings/#yields_1","title":"Yields","text":"<ul> <li>Multiple items allowed</li> </ul> <p>Yields sections allow to document values that generator yield. They should be used only in generators docstrings. Documented items can be given a name when it makes sense.</p> <pre><code>from typing import Iterator\n\n\ndef foo() -&gt; Iterator[int]:\n\"\"\"Foo.\n\n    Yields\n    ------\n    :\n        Integers from 0 to 9.\n    \"\"\"\n    for i in range(10):\n        yield i\n</code></pre> <p>Type annotations are fetched from the function return annotation when the annotation is <code>typing.Generator</code> or <code>typing.Iterator</code>. If your generator yields tuples, you can document each item of the tuple separately, and the type annotation will be fetched accordingly:</p> <pre><code>from datetime import datetime\n\n\ndef foo() -&gt; Iterator[tuple[float, float, datetime]]:\n\"\"\"Foo.\n\n    Yields\n    ------\n    x\n        Absissa.\n    y\n        Ordinate.\n    t\n        Time.\n    \"\"\"\n    ...\n</code></pre> <p>Type annotations can as usual be overridden using types in parentheses in the docstring itself:</p> <pre><code>\"\"\"Foo.\n\nYields\n------\nx : int\n    Absissa.\ny : int\n    Ordinate.\nt : int\n    Timestamp.\n\"\"\"\n</code></pre> <p>Types in docstrings are resolved using the docstrings' parent scope.</p> <p>See previous tips for types in docstrings.</p>"},{"location":"docstrings/#receives_1","title":"Receives","text":"<ul> <li>Multiple items allowed</li> </ul> <p>Receives sections allow to document values that can be sent to generators using their <code>send</code> method. They should be used only in generators docstrings. Documented items can be given a name when it makes sense.</p> <pre><code>from typing import Generator\n\n\ndef foo() -&gt; Generator[int, str, None]:\n\"\"\"Foo.\n\n    Receives\n    --------\n    reverse\n        Reverse the generator if `\"reverse\"` is received.\n\n    Yields\n    ------\n    :\n        Integers from 0 to 9.\n\n    Examples\n    --------\n    &gt;&gt;&gt; gen = foo()\n    &gt;&gt;&gt; next(gen)\n    0\n    &gt;&gt;&gt; next(gen)\n    1\n    &gt;&gt;&gt; next(gen)\n    2\n    &gt;&gt;&gt; gen.send(\"reverse\")\n    2\n    &gt;&gt;&gt; next(gen)\n    1\n    &gt;&gt;&gt; next(gen)\n    0\n    &gt;&gt;&gt; next(gen)\n    Traceback (most recent call last):\n        File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n    StopIteration\n    \"\"\"\n    for i in range(10):\n        received = yield i\n        if received == \"reverse\":\n            for j in range(i, -1, -1):\n                yield j\n            break\n</code></pre> <p>Type annotations are fetched from the function return annotation when the annotation is <code>typing.Generator</code>. If your generator is able to receive tuples, you can document each item of the tuple separately, and the type annotation will be fetched accordingly:</p> <pre><code>def foo() -&gt; Generator[int, tuple[str, bool], None]:\n\"\"\"Foo.\n\n    Receives\n    --------\n    mode\n        Some mode.\n    flag\n        Some flag.\n    \"\"\"\n    ...\n</code></pre> <p>Type annotations can as usual be overridden using types in parentheses in the docstring itself:</p> <pre><code>\"\"\"Foo.\n\nReceives\n--------\nmode : ModeEnum\n    Some mode.\nflag : int\n    Some flag.\n\"\"\"\n</code></pre> <p>Types in docstrings are resolved using the docstrings' parent scope.</p> <p>See previous tips for types in docstrings.</p>"},{"location":"docstrings/#returns_1","title":"Returns","text":"<ul> <li>Multiple items allowed</li> </ul> <p>Returns sections allow to document values returned by functions. They should be used only in functions docstrings. Documented items can be given a name when it makes sense.</p> <pre><code>import random\n\n\ndef foo() -&gt; int:\n\"\"\"Foo.\n\n    Returns\n    -------\n    :\n        A random integer.\n    \"\"\"\n    return random.randint(0, 100)\n</code></pre> <p>Type annotations are fetched from the function return annotation. If your function returns tuples of values, you can document each item of the tuple separately, and the type annotation will be fetched accordingly:</p> <pre><code>def foo() -&gt; tuple[bool, float]:\n\"\"\"Foo.\n\n    Returns\n    -------\n    success\n        Whether it succeeded.\n    precision\n        Final precision.\n    \"\"\"\n    ...\n</code></pre> <p>Type annotations can as usual be overridden using types in parentheses in the docstring itself:</p> <pre><code>\"\"\"Foo.\n\nReturns\n-------\nsuccess : int\n    Whether it succeeded.\nprecision : Decimal\n    Final precision.\n\"\"\"\n</code></pre> <p>Types in docstrings are resolved using the docstrings' function scope.</p> <p>See previous tips for types in docstrings.</p>"},{"location":"docstrings/#parsers-features","title":"Parsers features","text":"<p>Want to contribute?</p> <p>Each red cross is a link to an issue on the bugtracker. You will find some guidance on how to add support for the corresponding item.</p> <p>The sections are easier to deal in that order:</p> <ul> <li>Deprecated (single item, version and text)</li> <li>Raises, Warns (multiple items, no names, single type each)</li> <li>Attributes, Other Parameters, Parameters (multiple items, one name and one optional type each)</li> <li>Returns (multiple items, optional name and/or type each, annotation to split when multiple names)</li> <li>Receives, Yields (multiple items, optional name and/or type each, several types of annotations to split when multiple names)</li> </ul> <p>\"Examples\" section are a bit different as they require to parse the examples. But you can probably reuse the code in the Google parser. We can probably even factorize the examples parsing into a single function.</p> <p>You can tackle several items at once in a single PR, as long as they relate to a single parser or a single section (a line or a column of the following tables).</p>"},{"location":"docstrings/#sections","title":"Sections","text":"Section Google Numpy Sphinx Attributes \u2705 \u2705 \u2705 Functions \u2705 \u2705 \u274c Methods \u2705 \u2705 \u274c Classes \u2705 \u2705 \u274c Modules \u2705 \u2705 \u274c Deprecated \u2705 \u2705<sup>1</sup> \u274c Examples \u2705 \u2705 \u274c Parameters \u2705 \u2705 \u2705 Other Parameters \u2705 \u2705 \u274c Raises \u2705 \u2705 \u2705 Warns \u2705 \u2705 \u274c Yields \u2705 \u2705 \u274c Receives \u2705 \u2705 \u274c Returns \u2705 \u2705 \u2705"},{"location":"docstrings/#getting-annotationsdefaults-from-parent","title":"Getting annotations/defaults from parent","text":"Section Google Numpy Sphinx Attributes \u2705 \u2705 \u274c Functions / / / Methods / / / Classes / / / Modules / / / Deprecated / / / Examples / / / Parameters \u2705 \u2705 \u2705 Other Parameters \u2705 \u2705 \u274c Raises / / / Warns / / / Yields \u2705 \u2705 \u274c Receives \u2705 \u2705 \u274c Returns \u2705 \u2705 \u2705"},{"location":"docstrings/#cross-references-for-annotations-in-docstrings","title":"Cross-references for annotations in docstrings","text":"Section Google Numpy Sphinx Attributes \u2705 \u2705 \u274c Functions \u274c \u274c / Methods \u274c \u274c / Classes \u274c \u274c / Modules / / / Deprecated / / / Examples / / / Parameters \u2705 \u2705 \u274c Other Parameters \u2705 \u2705 \u274c Raises \u2705 \u2705 \u274c Warns \u2705 \u2705 \u274c Yields \u2705 \u2705 \u274c Receives \u2705 \u2705 \u274c Returns \u2705 \u2705 \u274c <ol> <li> <p>Support for a regular section instead of the RST directive specified in the Numpydoc styleguide.\u00a0\u21a9</p> </li> </ol>"},{"location":"dumping/","title":"Dumping packages' signatures as JSON","text":"<p>Griffe can be used to load packages' signatures and output them as JSON on the standard output or in writable files.</p> <p>Pass the names of packages to the <code>griffe dump</code> command:</p> <pre><code>$ griffe dump httpx fastapi\n{\n  \"httpx\": {\n    \"name\": \"httpx\",\n    ...\n  },\n  \"fastapi\": {\n    \"name\": \"fastapi\",\n    ...\n  }\n}\n</code></pre> <p>It will output a JSON-serialized version of the packages' signatures.</p> <p>Try it out on Griffe itself:</p> <pre><code>$ griffe dump griffe\n{\n  \"griffe\": {\n    \"name\": \"griffe\",\n    ...\n  }\n}\n</code></pre> <p>To output in a file instead of standard output, use the <code>--output</code> or <code>-o</code> option:</p> <pre><code>$ griffe dump griffe -o griffe.json\n</code></pre> <p>If you load multiple packages' signatures, you can dump each in its own file with a templated filepath:</p> <pre><code>$ griffe dump griffe -o './dumps/{package}.json'\n</code></pre> <p>By default, Griffe will search in <code>sys.path</code>, so if you installed it through pipx, there are few chances it will find your packages. To explicitly specify search paths, use the <code>-s, --search &lt;PATH&gt;</code> option. You can use it multiple times. You can also add the search paths to the <code>PYTHONPATH</code> environment variable. If Griffe can't find the packages, it will fail with a <code>ModuleNotFoundError</code>.</p> <p>For an example of what real data looks like, see the full Griffe JSON dump. </p>"},{"location":"extensions/","title":"Extensions","text":"<p>Extensions allow to enhance or customize the data that Griffe collects.</p>"},{"location":"extensions/#using-extensions","title":"Using extensions","text":"<p>Extensions can be specified both on the command-line (in the terminal), and programmatically (in Python).</p>"},{"location":"extensions/#on-the-command-line","title":"On the command-line","text":"<p>On the command-line, you can specify extensions to use with the <code>-e</code>, <code>--extensions</code> option. This option accepts a single positional argument which can take two forms:</p> <ul> <li>a comma-separated list of extensions</li> <li>a JSON list of extensions</li> </ul> <p>Extensions can accept options: the comma-separated list does not allow to specify options, while the JSON list does. See examples below.</p> <p>With both forms, each extension refers to one of these three things:</p> <ul> <li>the name of a built-in extension's module, for example <code>dynamic_docstrings</code>   (this is just an example, this built-in extension does not exist)</li> <li>the Python dotted-path to a module containing one or more extensions,   or to an extension directly, for example <code>package.module</code> and <code>package.module.ThisExtension</code></li> <li>the file path to a Python script, and an optional extension name, separated by a colon,   for example <code>scripts/griffe_exts.py</code> and <code>scripts/griffe_exts.py:ThisExtension</code></li> </ul> <p>The specified extension modules can contain more than one extension: Griffe will pick up and load every extension declared or imported within the modules. If options are specified for a module that contains multiple extensions, the same options will be passed to all the extensions, so extension writers must make sure that all extensions within a single module accept the same options. If they don't, Griffe will abort with an error.</p> <p>To specify options in the JSON form, use a dictionary instead of a string: the dictionary's only key is the extension identifier (built-in name, Python path, file path) and its value is a dictionary of options.</p> <p>Some examples:</p> <pre><code>griffe dump griffe -e pydantic,scripts/exts.py:DynamicDocstrings,griffe_attrs\n</code></pre> <pre><code>griffe check --search src griffe -e '[\n  {\"pydantic\": {\"schema\": true}},\n  {\n    \"scripts/exts.py:DynamicDocstrings\": {\n      \"paths\": [\"mypkg.mymod.myobj\"]\n    }\n  },\n  \"griffe_attrs\"\n]'\n</code></pre> <p>In the above two examples, <code>pydantic</code> would be a built-in extension, <code>scripts/exts.py:DynamicDocstrings</code> the file path plus name of a local extension, and <code>griffe_attrs</code> the name of a third-party package that exposes one or more extensions.</p>"},{"location":"extensions/#programmatically","title":"Programmatically","text":"<p>Within Python code, extensions can be specified with the <code>extensions</code> parameter of the <code>GriffeLoader</code> class or <code>load</code> function.</p> <p>The parameter accepts an instance of the <code>Extensions</code> class. Such an instance is created with the help of the <code>load_extensions</code> function, which itself accepts a list of strings, dictionaries, extension classes and extension instances.</p> <p>Strings and dictionaries are used the same way as on the command-line. Extension instances are used as such, and extension classes are instantiated without any options.</p> <p>Example:</p> <pre><code>import griffe\n\nfrom mypackage.extensions import ThisExtension, ThisOtherExtension\n\nextensions = griffe.load_extensions(\n    [\n        {\"pydantic\": {\"schema\": true}},\n        {\"scripts/exts.py:DynamicDocstrings\": {\"paths\": [\"mypkg.mymod.myobj\"]}},\n        \"griffe_attrs\",\n        ThisExtension(option=\"value\"),\n        ThisOtherExtension,\n    ]\n)\n\ndata = griffe.load(\"mypackage\", extensions=extensions)\n</code></pre>"},{"location":"extensions/#in-mkdocs","title":"In MkDocs","text":"<p>MkDocs and its mkdocstrings plugin can be configured to use Griffe extensions:</p> mkdocs.yml<pre><code>plugins:\n- mkdocstrings:\nhandlers:\npython:\noptions:\nextensions:\n- pydantic: {schema: true}\n- scripts/exts.py:DynamicDocstrings:\npaths: [mypkg.mymod.myobj]\n- griffe_attrs\n</code></pre> <p>The <code>extensions</code> key accepts a list that is passed to the <code>load_extensions</code> function. See how to use extensions programmatically to learn more.</p>"},{"location":"extensions/#writing-extensions","title":"Writing extensions","text":"<p>In the next section we give a bit of context on how Griffe works, to show how extensions can integrate into the data collection process. Feel free to skip to the Events and hooks section or the Full example section if you'd prefer to see concrete examples first.</p>"},{"location":"extensions/#how-it-works","title":"How it works","text":"<p>To extract information from your Python sources, Griffe tries to build Abstract Syntax Trees by parsing the sources with <code>ast</code> utilities.</p> <p>If the source code is not available (the modules are built-in or compiled), Griffe imports the modules and builds object trees instead.</p> <p>Griffe then follows the Visitor pattern to walk the tree and extract information. For ASTs, Griffe uses its Visitor agent and for object trees, it uses its Inspector agent.</p> <p>Sometimes during the walk through the tree (depth-first order), both the visitor and inspector agents will trigger events. These events can be hooked on by extensions to alter or enhance Griffe's behavior. Some hooks will be passed just the current node being visited, others will be passed both the node and an instance of an Object subclass, such as a Module, a Class, a Function, or an Attribute. Extensions will therefore be able to modify these instances.</p> <p>The following flow chart shows an example of an AST visit. The tree is simplified: actual trees have a lot more nodes like <code>if/elif/else</code> nodes, <code>try/except/else/finally</code> nodes, and many more.</p> <pre><code>flowchart TB\nM(Module definition) --- C(Class definition) &amp; F(Function definition)\nC --- m(Function definition) &amp; A(Variable assignment)</code></pre> <p>The following flow chart shows an example of an object tree inspection. The tree is simplified as well: many more types of objects are handled. </p> <pre><code>flowchart TB\nM(Module) --- C(Class) &amp; F(Function)\nC --- m(Method) &amp; A(Attribute)</code></pre> <p>For a more concrete example, let say that we visit (or inspect) an AST (or object tree) for a given module, and that this module contains a single class, which itself contains a single method:</p> <ul> <li>the agent (visitor or inspector) will walk through the tree   by starting with the module node</li> <li>it will instantiate a Module,   then walk through its members, continuing with the class node</li> <li>it will instantiate a Class,   then walk through its members, continuing with the function node</li> <li>it will instantiate a Function</li> <li>then it will go back up and finish walking since there are   no more nodes to walk through</li> </ul> <p>Every time the agent enters a node, creates an object instance, or finish handling members of an object, it will trigger an event.</p> <p>The flow of events is drawn in the following flowchart:</p> <pre><code>flowchart TB\nvisit_mod{{enter module node}}\nevent_mod_node{{\"&lt;a href='/griffe/reference/griffe/extensions/#griffe.extensions.base.Extension.on_node'&gt;&lt;b&gt;&lt;code style='color: var(--md-accent-fg-color)'&gt;on_node&lt;/code&gt;&lt;/b&gt;&lt;/a&gt; event&lt;br&gt;&lt;a href='/griffe/reference/griffe/extensions/#griffe.extensions.base.Extension.on_module_node'&gt;&lt;b&gt;&lt;code style='color: var(--md-accent-fg-color)'&gt;on_module_node&lt;/code&gt;&lt;/b&gt;&lt;/a&gt; event\"}}\ncreate_mod{{create module instance}}\nevent_mod_instance{{\"&lt;a href='/griffe/reference/griffe/extensions/#griffe.extensions.base.Extension.on_instance'&gt;&lt;b&gt;&lt;code style='color: var(--md-accent-fg-color)'&gt;on_instance&lt;/code&gt;&lt;/b&gt;&lt;/a&gt; event&lt;br&gt;&lt;a href='/griffe/reference/griffe/extensions/#griffe.extensions.base.Extension.on_module_instance'&gt;&lt;b&gt;&lt;code style='color: var(--md-accent-fg-color)'&gt;on_module_instance&lt;/code&gt;&lt;/b&gt;&lt;/a&gt; event\"}}\nvisit_mod_members{{visit module members}}\nvisit_cls{{enter class node}}\nevent_cls_node{{\"&lt;a href='/griffe/reference/griffe/extensions/#griffe.extensions.base.Extension.on_node'&gt;&lt;b&gt;&lt;code style='color: var(--md-accent-fg-color)'&gt;on_node&lt;/code&gt;&lt;/b&gt;&lt;/a&gt; event&lt;br&gt;&lt;a href='/griffe/reference/griffe/extensions/#griffe.extensions.base.Extension.on_class_node'&gt;&lt;b&gt;&lt;code style='color: var(--md-accent-fg-color)'&gt;on_class_node&lt;/code&gt;&lt;/b&gt;&lt;/a&gt; event\"}}\ncreate_cls{{create class instance}}\nevent_cls_instance{{\"&lt;a href='/griffe/reference/griffe/extensions/#griffe.extensions.base.Extension.on_instance'&gt;&lt;b&gt;&lt;code style='color: var(--md-accent-fg-color)'&gt;on_instance&lt;/code&gt;&lt;/b&gt;&lt;/a&gt; event&lt;br&gt;&lt;a href='/griffe/reference/griffe/extensions/#griffe.extensions.base.Extension.on_class_instance'&gt;&lt;b&gt;&lt;code style='color: var(--md-accent-fg-color)'&gt;on_class_instance&lt;/code&gt;&lt;/b&gt;&lt;/a&gt; event\"}}\nvisit_cls_members{{visit class members}}\nvisit_func{{enter func node}}\nevent_func_node{{\"&lt;a href='/griffe/reference/griffe/extensions/#griffe.extensions.base.Extension.on_node'&gt;&lt;b&gt;&lt;code style='color: var(--md-accent-fg-color)'&gt;on_node&lt;/code&gt;&lt;/b&gt;&lt;/a&gt; event&lt;br&gt;&lt;a href='/griffe/reference/griffe/extensions/#griffe.extensions.base.Extension.on_function_node'&gt;&lt;b&gt;&lt;code style='color: var(--md-accent-fg-color)'&gt;on_function_node&lt;/code&gt;&lt;/b&gt;&lt;/a&gt; event\"}}\ncreate_func{{create function instance}}\nevent_func_instance{{\"&lt;a href='/griffe/reference/griffe/extensions/#griffe.extensions.base.Extension.on_instance'&gt;&lt;b&gt;&lt;code style='color: var(--md-accent-fg-color)'&gt;on_instance&lt;/code&gt;&lt;/b&gt;&lt;/a&gt; event&lt;br&gt;&lt;a href='/griffe/reference/griffe/extensions/#griffe.extensions.base.Extension.on_function_instance'&gt;&lt;b&gt;&lt;code style='color: var(--md-accent-fg-color)'&gt;on_function_instance&lt;/code&gt;&lt;/b&gt;&lt;/a&gt; event\"}}\nevent_cls_members{{\"&lt;a href='/griffe/reference/griffe/extensions/#griffe.extensions.base.Extension.on_members'&gt;&lt;b&gt;&lt;code style='color: var(--md-accent-fg-color)'&gt;on_members&lt;/code&gt;&lt;/b&gt;&lt;/a&gt; event&lt;br&gt;&lt;a href='/griffe/reference/griffe/extensions/#griffe.extensions.base.Extension.on_class_members'&gt;&lt;b&gt;&lt;code style='color: var(--md-accent-fg-color)'&gt;on_class_members&lt;/code&gt;&lt;/b&gt;&lt;/a&gt; event\"}}\nevent_mod_members{{\"&lt;a href='/griffe/reference/griffe/extensions/#griffe.extensions.base.Extension.on_members'&gt;&lt;b&gt;&lt;code style='color: var(--md-accent-fg-color)'&gt;on_members&lt;/code&gt;&lt;/b&gt;&lt;/a&gt; event&lt;br&gt;&lt;a href='/griffe/reference/griffe/extensions/#griffe.extensions.base.Extension.on_module_members'&gt;&lt;b&gt;&lt;code style='color: var(--md-accent-fg-color)'&gt;on_module_members&lt;/code&gt;&lt;/b&gt;&lt;/a&gt; event\"}}\n\nstart{start} --&gt; visit_mod\nvisit_mod --&gt; event_mod_node\nevent_mod_node --&gt; create_mod\ncreate_mod --&gt; event_mod_instance\nevent_mod_instance --&gt; visit_mod_members\nvisit_mod_members --1--&gt; visit_cls\nvisit_cls --&gt; event_cls_node\nevent_cls_node --&gt; create_cls\ncreate_cls --&gt; event_cls_instance\nevent_cls_instance --&gt; visit_cls_members\nvisit_cls_members --1--&gt; visit_func\nvisit_func --&gt; event_func_node\nevent_func_node --&gt; create_func\ncreate_func --&gt; event_func_instance\nevent_func_instance --&gt; visit_cls_members\nvisit_cls_members --2--&gt; event_cls_members\nevent_cls_members --&gt; visit_mod_members\nvisit_mod_members --2--&gt; event_mod_members\nevent_mod_members --&gt; finish{finish}\n\nclass event_mod_node event\nclass event_mod_instance event\nclass event_cls_node event\nclass event_cls_instance event\nclass event_func_node event\nclass event_func_instance event\nclass event_cls_members event\nclass event_mod_members event\nclassDef event stroke:#3cc,stroke-width:2</code></pre> <p>Hopefully this flowchart gave you a pretty good idea of what happens when Griffe collects data from a Python module. The next setion will explain in more details the different events that are triggered, and how to hook onto them in your extensions.</p>"},{"location":"extensions/#events-and-hooks","title":"Events and hooks","text":"<p>There are 3 generic events:</p> <ul> <li><code>on_node</code></li> <li><code>on_instance</code></li> <li><code>on_members</code></li> </ul> <p>There are also specific events for each object kind:</p> <ul> <li><code>on_module_node</code></li> <li><code>on_module_instance</code></li> <li><code>on_module_members</code></li> <li><code>on_class_node</code></li> <li><code>on_class_instance</code></li> <li><code>on_class_members</code></li> <li><code>on_function_node</code></li> <li><code>on_function_instance</code></li> <li><code>on_attribute_node</code></li> <li><code>on_attribute_instance</code></li> </ul> <p>The \"on node\" events are triggered when the agent (visitor or inspector) starts handling a node in the tree (AST or object tree).</p> <p>The \"on instance\" events are triggered when the agent just created an instance of Module, Class, Function, or Attribute, and added it as a member of its parent.</p> <p>The \"on members\" events are triggered when the agent just finished handling all the members of an object. Functions and attributes do not have members, so there are no \"on members\" event for these two kinds.</p> <p>Hooks are methods that are called when a particular event is triggered. To target a specific event, the hook must be named after it.</p> <p>Extensions are classes that inherit from Griffe's Extension base class and define some hooks as methods:</p> <pre><code>import ast\nfrom griffe import Extension, Object, ObjectNode\n\n\nclass MyExtension(Extension):\n    def on_instance(self, node: ast.AST | ObjectNode, obj: Object) -&gt; None:\n\"\"\"Do something with `node` and/or `obj`.\"\"\"\n</code></pre> <p>Hooks are always defined as methods of a class inheriting from  Extension, never as standalone functions.</p> <p>Since hooks are declared in a class, feel free to also declare state variables (or any other variable) in the <code>__init__</code> method:</p> <pre><code>import ast\nfrom griffe import Extension, Object, ObjectNode\n\n\nclass MyExtension(Extension):\n    def __init__(self) -&gt; None:\n        super().__init__(self)\n        self.state_thingy = \"initial stuff\"\n        self.list_of_things = []\n\n    def on_instance(self, node: ast.AST | ObjectNode, obj: Object) -&gt; None:\n\"\"\"Do something with `node` and/or `obj`.\"\"\"\n</code></pre>"},{"location":"extensions/#staticdynamic-support","title":"Static/dynamic support","text":"<p>Extensions can support both static and dynamic analysis of modules. If a module is scanned statically, your extension hooks will receive AST nodes (from the ast module of the standard library). If the module is scanned dynamically, your extension hooks will receive object nodes.</p> <p>To support static analysis, dynamic analysis, or both, you can therefore check the type of the received node:</p> <pre><code>import ast\nfrom griffe import Extension, Object, ObjectNode\n\n\nclass MyExtension(Extension):\n    def on_instance(self, node: ast.AST | ObjectNode, obj: Object) -&gt; None:\n\"\"\"Do something with `node` and/or `obj`.\"\"\"\n        if isinstance(node, ast.AST):\n            ...  # apply logic for static analysis\n        else:\n            ...  # apply logic for dynamic analysis\n</code></pre> <p>Since hooks also receive instantiated modules, classes, functions and attributes, most of the time you will not need to use the <code>node</code> argument other than for checking its type and deciding what to do based on the result. If you do need to, read the next section explaining how to visit trees.</p>"},{"location":"extensions/#visiting-trees","title":"Visiting trees","text":"<p>Extensions provide basic functionality to help you visit trees:</p> <ul> <li><code>visit</code>: call <code>self.visit(node)</code>   to start visiting an abstract syntax tree.</li> <li><code>generic_visit</code>: call   <code>self.generic_visit(node)</code> to visit each subnode of a given node.</li> <li><code>inspect</code>: call <code>self.inspect(node)</code>   to start visiting an object tree. Nodes contain references to the runtime objects,   see <code>ObjectNode</code>.</li> <li><code>generic_inspect</code>: call   <code>self.generic_inspect(node)</code> to visit each subnode of a given node.</li> </ul> <p>Calling <code>self.visit(node)</code> or <code>self.inspect(node)</code> will do nothing unless you actually implement methods that handle specific types of nodes:</p> <ul> <li> <p>for ASTs, methods must be named <code>visit_&lt;node_type&gt;</code> where <code>&lt;node_type&gt;</code>     is replaced with the lowercase name of the node's class. For example,     to allow visiting <code>ClassDef</code> nodes, you must     implement the <code>visit_classdef</code> method:</p> <pre><code>import ast\nfrom griffe import Extension\n\n\nclass MyExtension(Extension):\n    def visit_classdef(node: ast.ClassDef) -&gt; None:\n        # do something with the node\n        ...\n        # then visit the subnodes\n        # (it only makes sense if you implement other methods\n        # such as visit_functiondef or visit_assign for example)\n        self.generic_visit(node)\n</code></pre> <p>See the list of existing AST classes to learn what method you can implement.</p> </li> <li> <p>for object trees, methods must be named <code>inspect_&lt;node_type&gt;</code>,     where <code>&lt;node_type&gt;</code> is replaced with the string value of the node's kind.     The different kinds are listed in the <code>ObjectKind</code> enumeration.     For example, to allow inspecting coroutine nodes, you must implement     the <code>inspect_coroutine</code> method:</p> <pre><code>from griffe import Extension, ObjectNode\n\n\nclass MyExtension(Extension):\n    def inspect_coroutine(node: ObjectNode) -&gt; None:\n        # do something with the node\n        ...\n        # then visit the subnodes if it makes sense\n        self.generic_inspect(node)\n</code></pre> </li> </ul>"},{"location":"extensions/#extra-data","title":"Extra data","text":"<p>All Griffe objects (modules, classes, functions, attributes) can store additional (meta)data in their <code>extra</code> attribute. This attribute is a dictionary of dictionaries. The first layer is used as namespacing: each extension writes into its own namespace, or integrates with other projects by reading/writing in their namespaces, according to what they support and document.</p> <pre><code>import ast\nfrom griffe import Extension, Object, ObjectNode\n\nself_namespace = \"my_extension\"\n\n\nclass MyExtension(Extension):\n    def on_instance(self, node: ast.AST | ObjectNode, obj: Object) -&gt; None:\n        obj.extra[self_namespace][\"some_key\"] = \"some_value\"\n</code></pre> <p>For example, mkdocstrings-python looks into the <code>mkdocstrings</code> namespace for a <code>template</code> key. Extensions can therefore provide a custom template value by writing into <code>extra[\"mkdocstrings\"][\"template\"]</code>:</p> <pre><code>import ast\nfrom griffe import Extension, ObjectNode, Class\n\nself_namespace = \"my_extension\"\nmkdocstrings_namespace = \"mkdocstrings\"\n\n\nclass MyExtension(Extension):\n    def on_class_instance(self, node: ast.AST | ObjectNode, cls: Class) -&gt; None:\n        obj.extra[mkdocstrings_namespace][\"template\"] = \"my_custom_template\"\n</code></pre> <p>Read more about mkdocstrings handler extensions.</p>"},{"location":"extensions/#options","title":"Options","text":"<p>Extensions can be made to support options. These options can then be passed from the command-line using JSON, from Python directly, or from other tools like MkDocs, in <code>mkdocs.yml</code>.</p> <pre><code>import ast\nfrom griffe import Attribute, Extension, ObjectNode\n\n\nclass MyExtension(Extension):\n    def __init__(self, option1: str, option2: bool = False) -&gt; None:\n        super().__init__(self)\n        self.option1 = option1\n        self.option2 = option2\n\n    def on_attribute_instance(self, node: ast.AST | ObjectNode, attr: Attribute) -&gt; None:\n        if self.option2:\n            ...  # do something\n</code></pre>"},{"location":"extensions/#logging","title":"Logging","text":"<p>To better integrate with Griffe and other tools in the ecosystem (notably MkDocs), use Griffe loggers to log messages:</p> <pre><code>import ast\nfrom griffe import Extension, ObjectNode, Module, get_logger\n\nlogger = get_logger(__name__)\n\n\nclass MyExtension(Extension):\n    def on_module_members(self, node: ast.AST | ObjectNode, mod: Module) -&gt; None:\n        logger.info(f\"Doing some work on module {mod.path} and its members\")\n</code></pre>"},{"location":"extensions/#full-example","title":"Full example","text":"<p>The following example shows how one could write a \"dynamic docstrings\" extension that dynamically import objects that declare their docstrings dynamically, to improve support for such docstrings. The extension is configurable to run only on user-selected objects.</p> <p>Package structure (or just write your extension in a local script):</p> <pre><code>\ud83d\udcc1 ./\n\u251c\u2500\u2500 \ud83d\udcc4 pyproject.toml\n\u2514\u2500\u2500 \ud83d\udcc1 src/\n    \u2514\u2500\u2500 \ud83d\udcc1 dynamic_docstrings/\n        \u251c\u2500\u2500 \ud83d\udcc4 __init__.py\n        \u2514\u2500\u2500 \ud83d\udcc4 extension.py\n</code></pre> ./src/dynamic_docstrings/extension.py<pre><code>import ast\nimport inspect\nfrom griffe import Docstring, Extension, Object, ObjectNode, get_logger, dynamic_import\n\nlogger = get_logger(__name__)\n\n\nclass DynamicDocstrings(Extension):\n    def __init__(self, object_paths: list[str] | None = None) -&gt; None:\n        self.object_paths = object_paths\n\n    def on_instance(self, node: ast.AST | ObjectNode, obj: Object) -&gt; None:\n        if isinstance(node, ObjectNode):\n            return  # skip runtime objects, their docstrings are already right\n\n        if self.object_paths and obj.path not in self.object_paths:\n            return  # skip objects that were not selected\n\n        # import object to get its evaluated docstring\n        try:\n            runtime_obj = dynamic_import(obj.path)\n            docstring = runtime_obj.__doc__\n        except ImportError:\n            logger.debug(f\"Could not get dynamic docstring for {obj.path}\")\n            return\n        except AttributeError:\n            logger.debug(f\"Object {obj.path} does not have a __doc__ attribute\")\n            return\n\n        # update the object instance with the evaluated docstring\n        docstring = inspect.cleandoc(docstring)\n        if obj.docstring:\n            obj.docstring.value = docstring\n        else:\n            obj.docstring = Docstring(docstring, parent=obj)\n</code></pre> <p>You can then expose this extension in the top-level module of your package:</p> ./src/dynamic_docstrings/__init__.py<pre><code>from dynamic_docstrings.extension import DynamicDocstrings\n\n__all__ = [\"DynamicDocstrings\"]\n</code></pre> <p>This will allow users to load and use this extension by referring to it as <code>dynamic_docstrings</code> (your Python package name).</p> <p>See how to use extensions to learn more about how to load and use your new extension.</p>"},{"location":"extensions/#ast-nodes","title":"AST nodes","text":"<p> <ul> <li><code>Add</code></li> <li><code>alias</code></li> <li><code>And</code></li> <li><code>AnnAssign</code></li> <li><code>arg</code></li> <li><code>arguments</code></li> <li><code>Assert</code></li> <li><code>Assign</code></li> <li><code>AsyncFor</code></li> <li><code>AsyncFunctionDef</code></li> <li><code>AsyncWith</code></li> <li><code>Attribute</code></li> <li><code>AugAssign</code></li> <li><code>Await</code></li> <li><code>BinOp</code></li> <li><code>BitAnd</code></li> <li><code>BitOr</code></li> <li><code>BitXor</code></li> <li><code>BoolOp</code></li> <li><code>Break</code></li> <li><code>Bytes</code><sup>1</sup></li> <li><code>Call</code></li> <li><code>ClassDef</code></li> <li><code>Compare</code></li> <li><code>comprehension</code></li> <li><code>Constant</code></li> <li><code>Continue</code></li> <li><code>Del</code></li> <li><code>Delete</code></li> </ul> <p> <ul> <li><code>Dict</code></li> <li><code>DictComp</code></li> <li><code>Div</code></li> <li><code>Ellipsis</code><sup>1</sup></li> <li><code>Eq</code></li> <li><code>ExceptHandler</code></li> <li><code>Expr</code></li> <li><code>Expression</code><sup>1</sup></li> <li><code>ExtSlice</code><sup>2</sup></li> <li><code>FloorDiv</code></li> <li><code>For</code></li> <li><code>FormattedValue</code></li> <li><code>FunctionDef</code></li> <li><code>GeneratorExp</code></li> <li><code>Global</code></li> <li><code>Gt</code></li> <li><code>GtE</code></li> <li><code>If</code></li> <li><code>IfExp</code></li> <li><code>Import</code></li> <li><code>ImportFrom</code></li> <li><code>In</code></li> <li><code>Index</code><sup>2</sup></li> <li><code>Interactive</code><sup>3</sup></li> <li><code>Invert</code></li> <li><code>Is</code></li> <li><code>IsNot</code></li> <li><code>JoinedStr</code></li> <li><code>keyword</code></li> </ul> <p> <ul> <li><code>Lambda</code></li> <li><code>List</code></li> <li><code>ListComp</code></li> <li><code>Load</code></li> <li><code>LShift</code></li> <li><code>Lt</code></li> <li><code>LtE</code></li> <li><code>Match</code></li> <li><code>MatchAs</code></li> <li><code>match_case</code></li> <li><code>MatchClass</code></li> <li><code>MatchMapping</code></li> <li><code>MatchOr</code></li> <li><code>MatchSequence</code></li> <li><code>MatchSingleton</code></li> <li><code>MatchStar</code></li> <li><code>MatchValue</code></li> <li><code>MatMult</code></li> <li><code>Mod</code></li> <li><code>Module</code><sup>3</sup></li> <li><code>Mult</code></li> <li><code>Name</code></li> <li><code>NameConstant</code><sup>1</sup></li> <li><code>NamedExpr</code></li> <li><code>Nonlocal</code></li> <li><code>Not</code></li> <li><code>NotEq</code></li> <li><code>NotIn</code></li> <li><code>Num</code><sup>1</sup></li> </ul> <p> <ul> <li><code>Or</code></li> <li><code>Pass</code></li> <li><code>pattern</code><sup>3</sup></li> <li><code>Pow</code></li> <li><code>Print</code><sup>4</sup></li> <li><code>Raise</code></li> <li><code>Return</code></li> <li><code>RShift</code></li> <li><code>Set</code></li> <li><code>SetComp</code></li> <li><code>Slice</code></li> <li><code>Starred</code></li> <li><code>Store</code></li> <li><code>Str</code><sup>1</sup></li> <li><code>Sub</code></li> <li><code>Subscript</code></li> <li><code>Try</code></li> <li><code>TryExcept</code><sup>5</sup></li> <li><code>TryFinally</code><sup>6</sup></li> <li><code>Tuple</code></li> <li><code>UAdd</code></li> <li><code>UnaryOp</code></li> <li><code>USub</code></li> <li><code>While</code></li> <li><code>With</code></li> <li><code>withitem</code></li> <li><code>Yield</code></li> <li><code>YieldFrom</code></li> </ul> <p></p> <ol> <li> <p>Deprecated since Python 3.8.\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>Deprecated since Python 3.9.\u00a0\u21a9\u21a9</p> </li> <li> <p>Not documented.\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p><code>print</code> became a builtin (instead of a keyword) in Python 3.\u00a0\u21a9</p> </li> <li> <p>Now <code>ExceptHandler</code>, in the <code>handlers</code> attribute of <code>Try</code> nodes.\u00a0\u21a9</p> </li> <li> <p>Now a list of expressions in the <code>finalbody</code> attribute of <code>Try</code> nodes.\u00a0\u21a9</p> </li> </ol>"},{"location":"license/","title":"License","text":"<pre><code>ISC License\n\nCopyright (c) 2021, Timoth\u00e9e Mazzucotelli\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\nWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\nANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\nACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\nOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n</code></pre>"},{"location":"loading/","title":"Loading data with Python","text":"<p>Griffe provides a shortcut function for simple needs:</p> <pre><code>import griffe\n\nmkdocs = griffe.load(\"mkdocs\")\n</code></pre> <p>The <code>load</code> function accepts a number of parameters.</p> <p>For more complex needs, create and use a loader:</p> <pre><code>from griffe.loader import GriffeLoader\n\nloader = GriffeLoader()\nmkdocs = loader.load_module(\"mkdocs\")\n</code></pre> <p>Similarly, the <code>GriffeLoader</code> accepts a number of parameters to configure how the modules are found and loaded.</p> <p>If you don't want to recurse in the submodules:</p> <pre><code>mkdocs = loader.load_module(\"mkdocs\", submodules=False)\n</code></pre>"},{"location":"loading/#navigating-into-the-loaded-objects","title":"Navigating into the loaded objects","text":"<p>Both the <code>load</code> function and the <code>GriffeLoader.load_module</code> method return a <code>Module</code> instance. There are several ways to access members of an object:</p> <ul> <li>through its <code>members</code> attribute, which is a dictionary,   with the usual <code>keys()</code>, <code>values()</code> and <code>items()</code> methods.</li> <li>thanks to its <code>__getitem__</code> method. For example <code>griffe[\"dataclasses\"]</code>   returns the <code>Module</code> instance representing Griffe's <code>dataclasses</code> module.   Since this module also has members, you can chain calls: <code>griffe[\"dataclasses\"][\"Module\"]</code>.   Conveniently, you can chain the names with dots in a single call: <code>griffe[\"dataclasses.Module\"]</code>.   You can even pass a tuple instead of a string: <code>griffe[(\"dataclasses\", \"Module\")]</code>.</li> <li>through the <code>modules</code>,   <code>classes</code>,   <code>functions</code> and   <code>attributes</code> properties,   which take care of filtering members based on their kind, and return dictionaries.</li> </ul> <p>Most of the time, you will only use classes from the <code>griffe.dataclasses</code> and <code>griffe.docstrings.dataclasses</code> modules.</p>"},{"location":"loading/#class-inheritance","title":"Class inheritance","text":"<p>New in version 0.30</p> <p>Inheritance support is experimental</p> <p> Inheritance support was recently added, and might need some corrections before being fully usable. Don't hesitate to report any issue that arises from using inheritance support in Griffe.</p> <p>Griffe supports class inheritance, both when visiting and inspecting modules.</p> <p>To access members of a class that are inherited from base classes, use <code>Object.inherited_members</code>. If this is the first time you access inherited members, the base classes of the given class will be resolved and cached, then the MRO (Method Resolution Order) will be computed for these bases classes, and a dictionary of inherited members will be built and cached. Next times you access it, you'll get the cached dictionary. Make sure to only access <code>inherited_members</code> once everything is loaded by Griffe, to avoid computing things too early. Don't access inherited members in extensions, while visiting or inspecting a module.</p> <p>Important: only classes from already loaded packages will be used when computing inherited members. This gives users control over how deep into inheritance to go, by pre-loading packages from which you want to inherit members. For example, if <code>package_c.ClassC</code> inherits from <code>package_b.ClassB</code>, itself inheriting from <code>package_a.ClassA</code>, and you want to load <code>ClassB</code> members only:</p> <pre><code>from griffe.loader import GriffeLoader\n\nloader = GriffeLoader()\n# note that we don't load package_a\nloader.load_module(\"package_b\")\nloader.load_module(\"package_c\")\n</code></pre> <p>If a base class cannot be resolved during computation of inherited members, Griffe logs a DEBUG message.</p> <p>If you want to access all members at once (both declared and inherited), use <code>Object.all_members</code>.</p> <p>If you want to access only declared members, use <code>Object.members</code>.</p> <p>Accessing <code>Object.attributes</code>, <code>Object.functions</code>, <code>Object.classes</code> or <code>Object.modules</code> will trigger inheritance computation, so make sure to only call it once everything is loaded by Griffe. Don't access inherited members in extensions, while visiting or inspecting a module.</p>"},{"location":"loading/#limitations","title":"Limitations","text":"<p>Currently, there are two limitations to our class inheritance support:</p> <ol> <li> <p>when visiting (static analysis), some objects are not yet properly recognized as classes,     for example named tuples. If you inherit from a named tuple,     its members won't be added to the inherited members of the inheriting class.</p> <pre><code>MyTuple = namedtuple(\"MyTuple\", \"attr1 attr2\")\n\n\nclass MyClass(MyTuple):\n    ...\n</code></pre> </li> <li> <p>when inspecting (dynamic analysis), ephemeral base classes won't be resolved,     and therefore their members won't appear in child classes. To circumvent that,     assign these dynamic classes to variables:</p> <pre><code># instead of\nclass MyClass(namedtuple(\"MyTuple\", \"attr1 attr2\")):\n    ...\n\n\n# do\nMyTuple = namedtuple(\"MyTuple\", \"attr1 attr2\")\n\n\nclass MyClass(MyTuple):\n    ...\n</code></pre> </li> </ol> <p>We will try to lift these limitations in the future.</p>"},{"location":"parsing_docstrings/","title":"Using Griffe as a docstring-parsing library","text":"<p>You can use Griffe to parse arbitrary docstrings. You don't have to load anything through the Griffe loader. You just need to import the <code>Docstring</code> class. Then you can build a <code>Docstring</code> instance and call its <code>parse</code> method, choosing the parsing-style to use:</p> <pre><code>from griffe.dataclasses import Docstring\n\ntext = \"Hello I'm a docstring!\"\ndocstring = Docstring(text, lineno=1)\nparsed = docstring.parse(\"google\")\n</code></pre> <p>If you want to take advantage of the parsers ability to fetch annotations from the object from which the docstring originates, you can manually create the parent objects and link them to the docstring:</p> <pre><code>from griffe.dataclasses import Docstring, Function, Parameters, Parameter, ParameterKind\n\nfunction = Function(\n    \"func\",\n    parameters=Parameters(\n        Parameter(\"param1\", annotation=\"str\", kind=ParameterKind.positional_or_keyword),\n        Parameter(\"param2\", annotation=\"int\", kind=ParameterKind.keyword_only),\n    ),\n)\ntext = \"\"\"\nHello I'm a docstring!\n\nParameters:\n    param1: Description.\n    param2: Description.\n\"\"\"\ndocstring = Docstring(text, lineno=1, parent=function)\nparsed = docstring.parse(\"google\")\n</code></pre> <p>With this the parser will fetch the <code>str</code> and <code>int</code> annotations from the parent function's parameters.</p>"},{"location":"try_it_out/","title":"Try Griffe in your browser","text":"<p>Try Griffe directly in your browser thanks to Pyodide! You can click the \"Run\" button in the top-right corner of each editor, or hit Ctrl+Enter to run the code.</p> <p>In the following example, we import <code>griffe</code> and use it to load itself. Then we output the signature of the <code>Function</code> class as JSON.</p> <p> Editor (session: default) Run <pre>import griffe\ngriffe_pkg = griffe.load(\"griffe\")\ngriffe_pkg[\"dataclasses.Function\"].as_json(indent=2)</pre> Output Clear <pre><code></code></pre> </p> <p>Try it out with another package of your choice! Just replace <code>your-dist-name</code> with a package's distribution name, and <code>your_package_name</code> with the package's import name:</p> <p> Editor (session: default) Run <pre>import micropip\nawait micropip.install(\"your-dist-name\")\ndata = griffe.load(\"your_package_name\")\ndata.as_json(indent=2)[:1000]  # truncate to a thousand characters...</pre> Output Clear <pre><code></code></pre> </p>"},{"location":"usage/","title":"Usage","text":"<p>Redirecting...</p>"},{"location":"reference/griffe/","title":"Index","text":""},{"location":"reference/griffe/#griffe","title":"griffe","text":"<p>griffe package.</p> <p>Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API.</p> <p>Modules:</p> <ul> <li> __main__         \u2013          <p>Entry-point module, in case you use <code>python -m griffe</code>.</p> </li> <li> agents         \u2013          <p>These modules contain the different agents that are able to extract data.</p> </li> <li> c3linear         \u2013          <p>Compute method resolution order. Implements <code>Class.mro</code> attribute.</p> </li> <li> cli         \u2013          <p>Module that contains the command line application.</p> </li> <li> collections         \u2013          <p>This module stores collections of data, useful during parsing.</p> </li> <li> dataclasses         \u2013          <p>This module contains the data classes that represent Python objects.</p> </li> <li> diff         \u2013          <p>This module exports \"breaking changes\" related utilities.</p> </li> <li> docstrings         \u2013          <p>This module exposes objects related to docstrings.</p> </li> <li> encoders         \u2013          <p>This module contains data encoders/serializers and decoders/deserializers.</p> </li> <li> enumerations         \u2013          <p>This module contains all the enumerations of the package.</p> </li> <li> exceptions         \u2013          <p>This module contains all the exceptions specific to Griffe.</p> </li> <li> expressions         \u2013          <p>This module contains the data classes that represent resolvable names and expressions.</p> </li> <li> extensions         \u2013          <p>This module is the public interface to import elements from the base.</p> </li> <li> finder         \u2013          <p>This module contains the code allowing to find modules.</p> </li> <li> git         \u2013          <p>This module contains the code allowing to load modules from specific git commits.</p> </li> <li> importer         \u2013          <p>This module contains utilities to dynamically import objects.</p> </li> <li> loader         \u2013          <p>This module contains the code allowing to load modules data.</p> </li> <li> logger         \u2013          <p>This module contains logging utilities.</p> </li> <li> merger         \u2013          <p>This module contains utilities to merge data together.</p> </li> <li> mixins         \u2013          <p>This module contains some mixins classes about accessing and setting members.</p> </li> <li> stats         \u2013          <p>This module contains utilities to compute loading statistics.</p> </li> <li> tests         \u2013          <p>Test helpers and pytest fixtures.</p> </li> </ul> <p>Classes:</p> <ul> <li> Attribute         \u2013          <p>The class representing a Python module/class/instance attribute.</p> </li> <li> Class         \u2013          <p>The class representing a Python class.</p> </li> <li> Docstring         \u2013          <p>This class represents docstrings.</p> </li> <li> Extension         \u2013          <p>Base class for Griffe extensions.</p> </li> <li> Function         \u2013          <p>The class representing a Python function.</p> </li> <li> Module         \u2013          <p>The class representing a Python module.</p> </li> <li> Object         \u2013          <p>An abstract class representing a Python object.</p> </li> <li> ObjectNode         \u2013          <p>Helper class to represent an object tree.</p> </li> </ul> <p>Functions:</p> <ul> <li> dynamic_import           \u2013            <p>Dynamically import the specified object.</p> </li> <li> find_breaking_changes           \u2013            <p>Find breaking changes between two versions of the same API.</p> </li> <li> get_logger           \u2013            <p>Create and return a new logger instance.</p> </li> <li> load           \u2013            <p>Load and return a module.</p> </li> <li> load_extensions           \u2013            <p>Load configured extensions.</p> </li> <li> load_git           \u2013            <p>Load and return a module from a specific Git reference.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Attribute","title":"Attribute","text":"<pre><code>Attribute(\n    *args: Any,\n    value: str | Expr | None = None,\n    annotation: str | Expr | None = None,\n    **kwargs: Any\n)\n</code></pre> <p>             Bases: <code>Object</code></p> <p>The class representing a Python module/class/instance attribute.</p> <p>Parameters:</p> <ul> <li> *args             (<code>Any</code>, default:                 <code>()</code> )         \u2013          <p>See <code>griffe.dataclasses.Object</code>.</p> </li> <li> value             (<code>str | Expr | None</code>, default:                 <code>None</code> )         \u2013          <p>The attribute value, if any.</p> </li> <li> annotation             (<code>str | Expr | None</code>, default:                 <code>None</code> )         \u2013          <p>The attribute annotation, if any.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>See <code>griffe.dataclasses.Object</code>.</p> </li> </ul> <p>Methods:</p> <ul> <li> __delitem__           \u2013            <p>Delete a member with its name or path.</p> </li> <li> __getitem__           \u2013            <p>Get a member with its name or path.</p> </li> <li> __setitem__           \u2013            <p>Set a member with its name or path.</p> </li> <li> as_dict           \u2013            <p>Return this function's data as a dictionary.</p> </li> <li> as_json           \u2013            <p>Return this object's data as a JSON string.</p> </li> <li> del_member           \u2013            <p>Delete a member with its name or path.</p> </li> <li> filter_members           \u2013            <p>Filter and return members based on predicates.</p> </li> <li> from_json           \u2013            <p>Create an instance of this class from a JSON string.</p> </li> <li> get_member           \u2013            <p>Get a member with its name or path.</p> </li> <li> has_labels           \u2013            <p>Tell if this object has all the given labels.</p> </li> <li> is_exported           \u2013            <p>Tell if this object/alias is implicitely exported by its parent.</p> </li> <li> is_kind           \u2013            <p>Tell if this object is of the given kind.</p> </li> <li> is_public           \u2013            <p>Whether this object is considered public.</p> </li> <li> member_is_exported           \u2013            <p>Tell if a member of this object is \"exported\".</p> </li> <li> resolve           \u2013            <p>Resolve a name within this object's and parents' scope.</p> </li> <li> set_member           \u2013            <p>Set a member with its name or path.</p> </li> </ul> <p>Attributes:</p> <ul> <li> all_members             (<code>dict[str, Object | Alias]</code>)         \u2013          <p>All members (declared and inherited).</p> </li> <li> attributes             (<code>dict[str, Attribute]</code>)         \u2013          <p>Return the attribute members.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Return the full dotted path of this object.</p> </li> <li> classes             (<code>dict[str, Class]</code>)         \u2013          <p>Return the class members.</p> </li> <li> filepath             (<code>Path | list[Path]</code>)         \u2013          <p>Return the file path where this object was defined.</p> </li> <li> functions             (<code>dict[str, Function]</code>)         \u2013          <p>Return the function members.</p> </li> <li> has_docstring             (<code>bool</code>)         \u2013          <p>Tell if this object has a non-empty docstring.</p> </li> <li> has_docstrings             (<code>bool</code>)         \u2013          <p>Tell if this object or any of its members has a non-empty docstring.</p> </li> <li> inherited_members             (<code>dict[str, Alias]</code>)         \u2013          <p>Members that are inherited from base classes.</p> </li> <li> is_attribute             (<code>bool</code>)         \u2013          <p>Tell if this object is an attribute.</p> </li> <li> is_class             (<code>bool</code>)         \u2013          <p>Tell if this object is a class.</p> </li> <li> is_explicitely_exported             (<code>bool</code>)         \u2013          <p>Tell if this object/alias is explicitely exported by its parent.</p> </li> <li> is_function             (<code>bool</code>)         \u2013          <p>Tell if this object is a function.</p> </li> <li> is_implicitely_exported             (<code>bool</code>)         \u2013          <p>Tell if this object/alias is implicitely exported by its parent.</p> </li> <li> is_module             (<code>bool</code>)         \u2013          <p>Tell if this object is a module.</p> </li> <li> lines             (<code>list[str]</code>)         \u2013          <p>Return the lines containing the source of this object.</p> </li> <li> lines_collection             (<code>LinesCollection</code>)         \u2013          <p>Return the lines collection attached to this object or its parents.</p> </li> <li> module             (<code>Module</code>)         \u2013          <p>Return the parent module of this object.</p> </li> <li> modules             (<code>dict[str, Module]</code>)         \u2013          <p>Return the module members.</p> </li> <li> modules_collection             (<code>ModulesCollection</code>)         \u2013          <p>Return the modules collection attached to this object or its parents.</p> </li> <li> package             (<code>Module</code>)         \u2013          <p>Return the absolute top module (the package) of this object.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Return the dotted path of this object.</p> </li> <li> relative_filepath             (<code>Path</code>)         \u2013          <p>Return the file path where this object was defined, relative to the current working directory.</p> </li> <li> relative_package_filepath             (<code>Path</code>)         \u2013          <p>Return the file path where this object was defined, relative to the top module path.</p> </li> <li> source             (<code>str</code>)         \u2013          <p>Return the source code of this object.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def __init__(\n    self,\n    *args: Any,\n    value: str | Expr | None = None,\n    annotation: str | Expr | None = None,\n    **kwargs: Any,\n) -&gt; None:\n\"\"\"Initialize the function.\n\n    Parameters:\n        *args: See [`griffe.dataclasses.Object`][].\n        value: The attribute value, if any.\n        annotation: The attribute annotation, if any.\n        **kwargs: See [`griffe.dataclasses.Object`][].\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.value: str | Expr | None = value\n    self.annotation: str | Expr | None = annotation\n</code></pre>"},{"location":"reference/griffe/#griffe.Attribute.all_members","title":"all_members  <code>property</code>","text":"<pre><code>all_members: dict[str, Object | Alias]\n</code></pre> <p>All members (declared and inherited).</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p>"},{"location":"reference/griffe/#griffe.Attribute.attributes","title":"attributes  <code>property</code>","text":"<pre><code>attributes: dict[str, Attribute]\n</code></pre> <p>Return the attribute members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Attribute]</code>         \u2013          <p>A dictionary of attributes.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Attribute.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Return the full dotted path of this object.</p> <p>The canonical path is the path where the object was defined (not imported).</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>A dotted path.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Attribute.classes","title":"classes  <code>property</code>","text":"<pre><code>classes: dict[str, Class]\n</code></pre> <p>Return the class members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Class]</code>         \u2013          <p>A dictionary of classes.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Attribute.filepath","title":"filepath  <code>property</code>","text":"<pre><code>filepath: Path | list[Path]\n</code></pre> <p>Return the file path where this object was defined.</p> <p>Returns:</p> <ul> <li> <code>Path | list[Path]</code>         \u2013          <p>A file path or a list of directories.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Attribute.functions","title":"functions  <code>property</code>","text":"<pre><code>functions: dict[str, Function]\n</code></pre> <p>Return the function members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Function]</code>         \u2013          <p>A dictionary of functions.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Attribute.has_docstring","title":"has_docstring  <code>property</code>","text":"<pre><code>has_docstring: bool\n</code></pre> <p>Tell if this object has a non-empty docstring.</p>"},{"location":"reference/griffe/#griffe.Attribute.has_docstrings","title":"has_docstrings  <code>property</code>","text":"<pre><code>has_docstrings: bool\n</code></pre> <p>Tell if this object or any of its members has a non-empty docstring.</p>"},{"location":"reference/griffe/#griffe.Attribute.inherited_members","title":"inherited_members  <code>cached</code> <code>property</code>","text":"<pre><code>inherited_members: dict[str, Alias]\n</code></pre> <p>Members that are inherited from base classes.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p>"},{"location":"reference/griffe/#griffe.Attribute.is_attribute","title":"is_attribute  <code>property</code>","text":"<pre><code>is_attribute: bool\n</code></pre> <p>Tell if this object is an attribute.</p>"},{"location":"reference/griffe/#griffe.Attribute.is_class","title":"is_class  <code>property</code>","text":"<pre><code>is_class: bool\n</code></pre> <p>Tell if this object is a class.</p>"},{"location":"reference/griffe/#griffe.Attribute.is_explicitely_exported","title":"is_explicitely_exported  <code>property</code>","text":"<pre><code>is_explicitely_exported: bool\n</code></pre> <p>Tell if this object/alias is explicitely exported by its parent.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Attribute.is_function","title":"is_function  <code>property</code>","text":"<pre><code>is_function: bool\n</code></pre> <p>Tell if this object is a function.</p>"},{"location":"reference/griffe/#griffe.Attribute.is_implicitely_exported","title":"is_implicitely_exported  <code>property</code>","text":"<pre><code>is_implicitely_exported: bool\n</code></pre> <p>Tell if this object/alias is implicitely exported by its parent.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Attribute.is_module","title":"is_module  <code>property</code>","text":"<pre><code>is_module: bool\n</code></pre> <p>Tell if this object is a module.</p>"},{"location":"reference/griffe/#griffe.Attribute.lines","title":"lines  <code>property</code>","text":"<pre><code>lines: list[str]\n</code></pre> <p>Return the lines containing the source of this object.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>         \u2013          <p>A list of lines.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Attribute.lines_collection","title":"lines_collection  <code>property</code>","text":"<pre><code>lines_collection: LinesCollection\n</code></pre> <p>Return the lines collection attached to this object or its parents.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When no modules collection can be found in the object or its parents.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>LinesCollection</code>         \u2013          <p>A lines collection.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Attribute.module","title":"module  <code>property</code>","text":"<pre><code>module: Module\n</code></pre> <p>Return the parent module of this object.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When the object is not a module and does not have a parent.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013          <p>The parent module.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Attribute.modules","title":"modules  <code>property</code>","text":"<pre><code>modules: dict[str, Module]\n</code></pre> <p>Return the module members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Module]</code>         \u2013          <p>A dictionary of modules.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Attribute.modules_collection","title":"modules_collection  <code>property</code>","text":"<pre><code>modules_collection: ModulesCollection\n</code></pre> <p>Return the modules collection attached to this object or its parents.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When no modules collection can be found in the object or its parents.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ModulesCollection</code>         \u2013          <p>A modules collection.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Attribute.package","title":"package  <code>property</code>","text":"<pre><code>package: Module\n</code></pre> <p>Return the absolute top module (the package) of this object.</p> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013          <p>The parent module.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Attribute.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Return the dotted path of this object.</p> <p>On regular objects (not aliases), the path is the canonical path.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>A dotted path.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Attribute.relative_filepath","title":"relative_filepath  <code>property</code>","text":"<pre><code>relative_filepath: Path\n</code></pre> <p>Return the file path where this object was defined, relative to the current working directory.</p> <p>If this object's file path is not relative to the current working directory, return its absolute path.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When the relative path could not be computed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code>         \u2013          <p>A file path.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Attribute.relative_package_filepath","title":"relative_package_filepath  <code>property</code>","text":"<pre><code>relative_package_filepath: Path\n</code></pre> <p>Return the file path where this object was defined, relative to the top module path.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When the relative path could not be computed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code>         \u2013          <p>A file path.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Attribute.source","title":"source  <code>property</code>","text":"<pre><code>source: str\n</code></pre> <p>Return the source code of this object.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The source code.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Attribute.__delitem__","title":"__delitem__","text":"<pre><code>__delitem__(key: str | Sequence[str]) -&gt; None\n</code></pre> <p>Delete a member with its name or path.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Members will be looked up in both declared members and inherited ones, triggering computation of the latter.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; del griffe_object[\"foo\"]\n&gt;&gt;&gt; del griffe_object[\"path.to.bar\"]\n&gt;&gt;&gt; del griffe_object[(\"path\", \"to\", \"qux\")]\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def __delitem__(self, key: str | Sequence[str]) -&gt; None:\n\"\"\"Delete a member with its name or path.\n\n    This method is part of the consumer API:\n    do not use when producing Griffe trees!\n\n    Members will be looked up in both declared members and inherited ones,\n    triggering computation of the latter.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; del griffe_object[\"foo\"]\n        &gt;&gt;&gt; del griffe_object[\"path.to.bar\"]\n        &gt;&gt;&gt; del griffe_object[(\"path\", \"to\", \"qux\")]\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        try:\n            del self.members[name]  # type: ignore[attr-defined]\n        except KeyError:\n            del self.inherited_members[name]  # type: ignore[attr-defined]\n    else:\n        del self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/#griffe.Attribute.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key: str | Sequence[str]) -&gt; Any\n</code></pre> <p>Get a member with its name or path.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Members will be looked up in both declared members and inherited ones, triggering computation of the latter.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; foo = griffe_object[\"foo\"]\n&gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n&gt;&gt;&gt; qux = griffe_object[(\"path\", \"to\", \"qux\")]\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def __getitem__(self, key: str | Sequence[str]) -&gt; Any:\n\"\"\"Get a member with its name or path.\n\n    This method is part of the consumer API:\n    do not use when producing Griffe trees!\n\n    Members will be looked up in both declared members and inherited ones,\n    triggering computation of the latter.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; foo = griffe_object[\"foo\"]\n        &gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n        &gt;&gt;&gt; qux = griffe_object[(\"path\", \"to\", \"qux\")]\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        return self.all_members[parts[0]]  # type: ignore[attr-defined]\n    return self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/#griffe.Attribute.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(\n    key: str | Sequence[str], value: Object | Alias\n) -&gt; None\n</code></pre> <p>Set a member with its name or path.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> <li> value             (<code>Object | Alias</code>)         \u2013          <p>The member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; griffe_object[\"foo\"] = foo\n&gt;&gt;&gt; griffe_object[\"path.to.bar\"] = bar\n&gt;&gt;&gt; griffe_object[(\"path\", \"to\", \"qux\")] = qux\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def __setitem__(self, key: str | Sequence[str], value: Object | Alias) -&gt; None:\n\"\"\"Set a member with its name or path.\n\n    This method is part of the consumer API:\n    do not use when producing Griffe trees!\n\n    Parameters:\n        key: The name or path of the member.\n        value: The member.\n\n    Examples:\n        &gt;&gt;&gt; griffe_object[\"foo\"] = foo\n        &gt;&gt;&gt; griffe_object[\"path.to.bar\"] = bar\n        &gt;&gt;&gt; griffe_object[(\"path\", \"to\", \"qux\")] = qux\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        self.members[name] = value  # type: ignore[attr-defined]\n        if self.is_collection:  # type: ignore[attr-defined]\n            value._modules_collection = self  # type: ignore[union-attr]\n        else:\n            value.parent = self  # type: ignore[assignment]\n    else:\n        self.members[parts[0]][parts[1:]] = value  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/#griffe.Attribute.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return this function's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return this function's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    base = super().as_dict(**kwargs)\n    if self.value is not None:\n        base[\"value\"] = self.value\n    if self.annotation is not None:\n        base[\"annotation\"] = self.annotation\n    return base\n</code></pre>"},{"location":"reference/griffe/#griffe.Attribute.as_json","title":"as_json","text":"<pre><code>as_json(*, full: bool = False, **kwargs: Any) -&gt; str\n</code></pre> <p>Return this object's data as a JSON string.</p> <p>Parameters:</p> <ul> <li> full             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to return full info, or just base info.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options passed to encoder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>A JSON string.</p> </li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>def as_json(self, *, full: bool = False, **kwargs: Any) -&gt; str:\n\"\"\"Return this object's data as a JSON string.\n\n    Parameters:\n        full: Whether to return full info, or just base info.\n        **kwargs: Additional serialization options passed to encoder.\n\n    Returns:\n        A JSON string.\n    \"\"\"\n    from griffe.encoders import JSONEncoder  # avoid circular import\n\n    return json.dumps(self, cls=JSONEncoder, full=full, **kwargs)\n</code></pre>"},{"location":"reference/griffe/#griffe.Attribute.del_member","title":"del_member","text":"<pre><code>del_member(key: str | Sequence[str]) -&gt; None\n</code></pre> <p>Delete a member with its name or path.</p> <p>This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).</p> <p>Members will be looked up in declared members only, not inherited ones.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; griffe_object.del_member(\"foo\")\n&gt;&gt;&gt; griffe_object.del_member(\"path.to.bar\")\n&gt;&gt;&gt; griffe_object.del_member((\"path\", \"to\", \"qux\"))\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def del_member(self, key: str | Sequence[str]) -&gt; None:\n\"\"\"Delete a member with its name or path.\n\n    This method is part of the producer API:\n    you can use it safely while building Griffe trees\n    (for example in Griffe extensions).\n\n    Members will be looked up in declared members only, not inherited ones.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; griffe_object.del_member(\"foo\")\n        &gt;&gt;&gt; griffe_object.del_member(\"path.to.bar\")\n        &gt;&gt;&gt; griffe_object.del_member((\"path\", \"to\", \"qux\"))\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        del self.members[name]  # type: ignore[attr-defined]\n    else:\n        self.members[parts[0]].del_member(parts[1:])  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/#griffe.Attribute.filter_members","title":"filter_members","text":"<pre><code>filter_members(\n    *predicates: Callable[[Object | Alias], bool]\n) -&gt; dict[str, Object | Alias]\n</code></pre> <p>Filter and return members based on predicates.</p> <p>Parameters:</p> <ul> <li> *predicates             (<code>Callable[[Object | Alias], bool]</code>, default:                 <code>()</code> )         \u2013          <p>A list of predicates, i.e. callables accepting a member as argument and returning a boolean.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Object | Alias]</code>         \u2013          <p>A dictionary of members.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def filter_members(self, *predicates: Callable[[Object | Alias], bool]) -&gt; dict[str, Object | Alias]:\n\"\"\"Filter and return members based on predicates.\n\n    Parameters:\n        *predicates: A list of predicates, i.e. callables accepting a member as argument and returning a boolean.\n\n    Returns:\n        A dictionary of members.\n    \"\"\"\n    if not predicates:\n        return self.members\n    members: dict[str, Object | Alias] = {}\n    for name, member in self.members.items():\n        if all(predicate(member) for predicate in predicates):\n            members[name] = member\n    return members\n</code></pre>"},{"location":"reference/griffe/#griffe.Attribute.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_string: str, **kwargs: Any) -&gt; _ObjType\n</code></pre> <p>Create an instance of this class from a JSON string.</p> <p>Parameters:</p> <ul> <li> json_string             (<code>str</code>)         \u2013          <p>JSON to decode into Object.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional options passed to decoder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_ObjType</code>         \u2013          <p>An Object instance.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>           \u2013          <p>When the json_string does not represent and object of the class from which this classmethod has been called.</p> </li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>@classmethod\ndef from_json(cls: type[_ObjType], json_string: str, **kwargs: Any) -&gt; _ObjType:  # noqa: PYI019\n\"\"\"Create an instance of this class from a JSON string.\n\n    Parameters:\n        json_string: JSON to decode into Object.\n        **kwargs: Additional options passed to decoder.\n\n    Returns:\n        An Object instance.\n\n    Raises:\n        TypeError: When the json_string does not represent and object\n            of the class from which this classmethod has been called.\n    \"\"\"\n    from griffe.encoders import json_decoder  # avoid circular import\n\n    kwargs.setdefault(\"object_hook\", json_decoder)\n    obj = json.loads(json_string, **kwargs)\n    if not isinstance(obj, cls):\n        raise TypeError(f\"provided JSON object is not of type {cls}\")\n    return obj\n</code></pre>"},{"location":"reference/griffe/#griffe.Attribute.get_member","title":"get_member","text":"<pre><code>get_member(key: str | Sequence[str]) -&gt; Any\n</code></pre> <p>Get a member with its name or path.</p> <p>This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).</p> <p>Members will be looked up in declared members only, not inherited ones.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; foo = griffe_object[\"foo\"]\n&gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n&gt;&gt;&gt; bar = griffe_object[(\"path\", \"to\", \"bar\")]\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def get_member(self, key: str | Sequence[str]) -&gt; Any:\n\"\"\"Get a member with its name or path.\n\n    This method is part of the producer API:\n    you can use it safely while building Griffe trees\n    (for example in Griffe extensions).\n\n    Members will be looked up in declared members only, not inherited ones.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; foo = griffe_object[\"foo\"]\n        &gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n        &gt;&gt;&gt; bar = griffe_object[(\"path\", \"to\", \"bar\")]\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        return self.members[parts[0]]  # type: ignore[attr-defined]\n    return self.members[parts[0]].get_member(parts[1:])  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/#griffe.Attribute.has_labels","title":"has_labels","text":"<pre><code>has_labels(labels: set[str]) -&gt; bool\n</code></pre> <p>Tell if this object has all the given labels.</p> <p>Parameters:</p> <ul> <li> labels             (<code>set[str]</code>)         \u2013          <p>A set of labels.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def has_labels(self, labels: set[str]) -&gt; bool:\n\"\"\"Tell if this object has all the given labels.\n\n    Parameters:\n        labels: A set of labels.\n\n    Returns:\n        True or False.\n    \"\"\"\n    return all(label in self.labels for label in labels)\n</code></pre>"},{"location":"reference/griffe/#griffe.Attribute.is_exported","title":"is_exported","text":"<pre><code>is_exported(*, explicitely: bool = True) -&gt; bool\n</code></pre> <p>Tell if this object/alias is implicitely exported by its parent.</p> <p>Parameters:</p> <ul> <li> explicitely             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to only return True when <code>__all__</code> is defined.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>def is_exported(self, *, explicitely: bool = True) -&gt; bool:\n\"\"\"Tell if this object/alias is implicitely exported by its parent.\n\n    Parameters:\n        explicitely: Whether to only return True when `__all__` is defined.\n\n    Returns:\n        True or False.\n    \"\"\"\n    return self.parent.member_is_exported(self, explicitely=explicitely)  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/#griffe.Attribute.is_kind","title":"is_kind","text":"<pre><code>is_kind(kind: str | Kind | set[str | Kind]) -&gt; bool\n</code></pre> <p>Tell if this object is of the given kind.</p> <p>Parameters:</p> <ul> <li> kind             (<code>str | Kind | set[str | Kind]</code>)         \u2013          <p>An instance or set of kinds (strings or enumerations).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When an empty set is given as argument.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def is_kind(self, kind: str | Kind | set[str | Kind]) -&gt; bool:\n\"\"\"Tell if this object is of the given kind.\n\n    Parameters:\n        kind: An instance or set of kinds (strings or enumerations).\n\n    Raises:\n        ValueError: When an empty set is given as argument.\n\n    Returns:\n        True or False.\n    \"\"\"\n    if isinstance(kind, set):\n        if not kind:\n            raise ValueError(\"kind must not be an empty set\")\n        return self.kind in (knd if isinstance(knd, Kind) else Kind(knd) for knd in kind)\n    if isinstance(kind, str):\n        kind = Kind(kind)\n    return self.kind is kind\n</code></pre>"},{"location":"reference/griffe/#griffe.Attribute.is_public","title":"is_public","text":"<pre><code>is_public(\n    *, strict: bool = False, check_name: bool = True\n) -&gt; bool\n</code></pre> <p>Whether this object is considered public.</p> <p>In modules, developers can mark objects as public thanks to the <code>__all__</code> variable. In classes however, there is no convention or standard to do so.</p> <p>Therefore, to decide whether an object is public, we follow this algorithm:</p> <ul> <li>If the object's <code>public</code> attribute is set (boolean), return its value.</li> <li>In strict mode, the object is public only if it is explicitely exported (listed in <code>__all__</code>).     Strict mode should only be used for module members.</li> <li>Otherwise, if name checks are enabled, the object is private if its name starts with an underscore.</li> <li>Otherwise, if the object is an alias, and is neither inherited from a base class,     nor a member of a parent alias, it is not public.</li> <li>Otherwise, the object is public.</li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>def is_public(\n    self,\n    *,\n    strict: bool = False,\n    check_name: bool = True,\n) -&gt; bool:\n\"\"\"Whether this object is considered public.\n\n    In modules, developers can mark objects as public thanks to the `__all__` variable.\n    In classes however, there is no convention or standard to do so.\n\n    Therefore, to decide whether an object is public, we follow this algorithm:\n\n    - If the object's `public` attribute is set (boolean), return its value.\n    - In strict mode, the object is public only if it is explicitely exported (listed in `__all__`).\n        Strict mode should only be used for module members.\n    - Otherwise, if name checks are enabled, the object is private if its name starts with an underscore.\n    - Otherwise, if the object is an alias, and is neither inherited from a base class,\n        nor a member of a parent alias, it is not public.\n    - Otherwise, the object is public.\n    \"\"\"\n    if self.public is not None:  # type: ignore[attr-defined]\n        return self.public  # type: ignore[attr-defined]\n    if self.is_explicitely_exported:\n        return True\n    if strict:\n        return False\n    if check_name and self.name.startswith(\"_\"):  # type: ignore[attr-defined]\n        return False\n    if self.is_alias and not (self.inherited or self.parent.is_alias):  # type: ignore[attr-defined]\n        return False\n    return True\n</code></pre>"},{"location":"reference/griffe/#griffe.Attribute.member_is_exported","title":"member_is_exported","text":"<pre><code>member_is_exported(\n    member: Object | Alias, *, explicitely: bool = True\n) -&gt; bool\n</code></pre> <p>Tell if a member of this object is \"exported\".</p> <p>By exported, we mean that the object is included in the <code>__all__</code> attribute of its parent module or class. When <code>__all__</code> is not defined, we consider the member to be implicitely exported, unless it's a module and it was not imported, and unless it's not defined at runtime.</p> <p>Parameters:</p> <ul> <li> member             (<code>Object | Alias</code>)         \u2013          <p>The member to verify.</p> </li> <li> explicitely             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to only return True when <code>__all__</code> is defined.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def member_is_exported(self, member: Object | Alias, *, explicitely: bool = True) -&gt; bool:\n\"\"\"Tell if a member of this object is \"exported\".\n\n    By exported, we mean that the object is included in the `__all__` attribute\n    of its parent module or class. When `__all__` is not defined,\n    we consider the member to be *implicitely* exported,\n    unless it's a module and it was not imported,\n    and unless it's not defined at runtime.\n\n    Parameters:\n        member: The member to verify.\n        explicitely: Whether to only return True when `__all__` is defined.\n\n    Returns:\n        True or False.\n    \"\"\"\n    if not member.runtime:\n        return False\n    if self.exports is None:\n        return not explicitely and (member.is_alias or not member.is_module or member.name in self.imports)\n    return member.name in self.exports\n</code></pre>"},{"location":"reference/griffe/#griffe.Attribute.resolve","title":"resolve","text":"<pre><code>resolve(name: str) -&gt; str\n</code></pre> <p>Resolve a name within this object's and parents' scope.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013          <p>The name to resolve.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NameResolutionError</code>           \u2013          <p>When the name could not be resolved.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The resolved name.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def resolve(self, name: str) -&gt; str:\n\"\"\"Resolve a name within this object's and parents' scope.\n\n    Parameters:\n        name: The name to resolve.\n\n    Raises:\n        NameResolutionError: When the name could not be resolved.\n\n    Returns:\n        The resolved name.\n    \"\"\"\n    if name in self.members:\n        if self.members[name].is_alias:\n            return self.members[name].target_path  # type: ignore[union-attr]\n        return self.members[name].path\n    if name in self.imports:\n        return self.imports[name]\n    if self.parent is None:\n        # could be a built-in\n        raise NameResolutionError(f\"{name} could not be resolved in the scope of {self.path}\")\n    if name == self.parent.name and not self.parent.is_module:\n        return self.parent.path\n    return self.parent.resolve(name)\n</code></pre>"},{"location":"reference/griffe/#griffe.Attribute.set_member","title":"set_member","text":"<pre><code>set_member(\n    key: str | Sequence[str], value: Object | Alias\n) -&gt; None\n</code></pre> <p>Set a member with its name or path.</p> <p>This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> <li> value             (<code>Object | Alias</code>)         \u2013          <p>The member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; griffe_object.set_member(\"foo\", foo)\n&gt;&gt;&gt; griffe_object.set_member(\"path.to.bar\", bar)\n&gt;&gt;&gt; griffe_object.set_member((\"path\", \"to\", \"qux\", qux)\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def set_member(self, key: str | Sequence[str], value: Object | Alias) -&gt; None:\n\"\"\"Set a member with its name or path.\n\n    This method is part of the producer API:\n    you can use it safely while building Griffe trees\n    (for example in Griffe extensions).\n\n    Parameters:\n        key: The name or path of the member.\n        value: The member.\n\n    Examples:\n        &gt;&gt;&gt; griffe_object.set_member(\"foo\", foo)\n        &gt;&gt;&gt; griffe_object.set_member(\"path.to.bar\", bar)\n        &gt;&gt;&gt; griffe_object.set_member((\"path\", \"to\", \"qux\", qux)\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        if name in self.members:  # type: ignore[attr-defined]\n            member = self.members[name]  # type: ignore[attr-defined]\n            if not member.is_alias:\n                # when reassigning a module to an existing one,\n                # try to merge them as one regular and one stubs module\n                # (implicit support for .pyi modules)\n                if member.is_module and not (member.is_namespace_package or member.is_namespace_subpackage):\n                    with suppress(AliasResolutionError, CyclicAliasError):\n                        if value.is_module and value.filepath != member.filepath:\n                            with suppress(ValueError):\n                                value = merge_stubs(member, value)  # type: ignore[arg-type]\n                for alias in member.aliases.values():\n                    with suppress(CyclicAliasError):\n                        alias.target = value\n        self.members[name] = value  # type: ignore[attr-defined]\n        if self.is_collection:  # type: ignore[attr-defined]\n            value._modules_collection = self  # type: ignore[union-attr]\n        else:\n            value.parent = self  # type: ignore[assignment]\n    else:\n        self.members[parts[0]].set_member(parts[1:], value)  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/#griffe.Class","title":"Class","text":"<pre><code>Class(\n    *args: Any,\n    bases: Sequence[Expr | str] | None = None,\n    decorators: list[Decorator] | None = None,\n    **kwargs: Any\n)\n</code></pre> <p>             Bases: <code>Object</code></p> <p>The class representing a Python class.</p> <p>Parameters:</p> <ul> <li> *args             (<code>Any</code>, default:                 <code>()</code> )         \u2013          <p>See <code>griffe.dataclasses.Object</code>.</p> </li> <li> bases             (<code>Sequence[Expr | str] | None</code>, default:                 <code>None</code> )         \u2013          <p>The list of base classes, if any.</p> </li> <li> decorators             (<code>list[Decorator] | None</code>, default:                 <code>None</code> )         \u2013          <p>The class decorators, if any.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>See <code>griffe.dataclasses.Object</code>.</p> </li> </ul> <p>Methods:</p> <ul> <li> __delitem__           \u2013            <p>Delete a member with its name or path.</p> </li> <li> __getitem__           \u2013            <p>Get a member with its name or path.</p> </li> <li> __setitem__           \u2013            <p>Set a member with its name or path.</p> </li> <li> as_dict           \u2013            <p>Return this class' data as a dictionary.</p> </li> <li> as_json           \u2013            <p>Return this object's data as a JSON string.</p> </li> <li> del_member           \u2013            <p>Delete a member with its name or path.</p> </li> <li> filter_members           \u2013            <p>Filter and return members based on predicates.</p> </li> <li> from_json           \u2013            <p>Create an instance of this class from a JSON string.</p> </li> <li> get_member           \u2013            <p>Get a member with its name or path.</p> </li> <li> has_labels           \u2013            <p>Tell if this object has all the given labels.</p> </li> <li> is_exported           \u2013            <p>Tell if this object/alias is implicitely exported by its parent.</p> </li> <li> is_kind           \u2013            <p>Tell if this object is of the given kind.</p> </li> <li> is_public           \u2013            <p>Whether this object is considered public.</p> </li> <li> member_is_exported           \u2013            <p>Tell if a member of this object is \"exported\".</p> </li> <li> mro           \u2013            <p>Return a list of classes in order corresponding to Python's MRO.</p> </li> <li> resolve           \u2013            <p>Resolve a name within this object's and parents' scope.</p> </li> <li> set_member           \u2013            <p>Set a member with its name or path.</p> </li> </ul> <p>Attributes:</p> <ul> <li> all_members             (<code>dict[str, Object | Alias]</code>)         \u2013          <p>All members (declared and inherited).</p> </li> <li> attributes             (<code>dict[str, Attribute]</code>)         \u2013          <p>Return the attribute members.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Return the full dotted path of this object.</p> </li> <li> classes             (<code>dict[str, Class]</code>)         \u2013          <p>Return the class members.</p> </li> <li> filepath             (<code>Path | list[Path]</code>)         \u2013          <p>Return the file path where this object was defined.</p> </li> <li> functions             (<code>dict[str, Function]</code>)         \u2013          <p>Return the function members.</p> </li> <li> has_docstring             (<code>bool</code>)         \u2013          <p>Tell if this object has a non-empty docstring.</p> </li> <li> has_docstrings             (<code>bool</code>)         \u2013          <p>Tell if this object or any of its members has a non-empty docstring.</p> </li> <li> inherited_members             (<code>dict[str, Alias]</code>)         \u2013          <p>Members that are inherited from base classes.</p> </li> <li> is_attribute             (<code>bool</code>)         \u2013          <p>Tell if this object is an attribute.</p> </li> <li> is_class             (<code>bool</code>)         \u2013          <p>Tell if this object is a class.</p> </li> <li> is_explicitely_exported             (<code>bool</code>)         \u2013          <p>Tell if this object/alias is explicitely exported by its parent.</p> </li> <li> is_function             (<code>bool</code>)         \u2013          <p>Tell if this object is a function.</p> </li> <li> is_implicitely_exported             (<code>bool</code>)         \u2013          <p>Tell if this object/alias is implicitely exported by its parent.</p> </li> <li> is_module             (<code>bool</code>)         \u2013          <p>Tell if this object is a module.</p> </li> <li> lines             (<code>list[str]</code>)         \u2013          <p>Return the lines containing the source of this object.</p> </li> <li> lines_collection             (<code>LinesCollection</code>)         \u2013          <p>Return the lines collection attached to this object or its parents.</p> </li> <li> module             (<code>Module</code>)         \u2013          <p>Return the parent module of this object.</p> </li> <li> modules             (<code>dict[str, Module]</code>)         \u2013          <p>Return the module members.</p> </li> <li> modules_collection             (<code>ModulesCollection</code>)         \u2013          <p>Return the modules collection attached to this object or its parents.</p> </li> <li> package             (<code>Module</code>)         \u2013          <p>Return the absolute top module (the package) of this object.</p> </li> <li> parameters             (<code>Parameters</code>)         \u2013          <p>Return the parameters of this class' <code>__init__</code> method, if any.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Return the dotted path of this object.</p> </li> <li> relative_filepath             (<code>Path</code>)         \u2013          <p>Return the file path where this object was defined, relative to the current working directory.</p> </li> <li> relative_package_filepath             (<code>Path</code>)         \u2013          <p>Return the file path where this object was defined, relative to the top module path.</p> </li> <li> resolved_bases             (<code>list[Object]</code>)         \u2013          <p>Resolved class bases.</p> </li> <li> source             (<code>str</code>)         \u2013          <p>Return the source code of this object.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def __init__(\n    self,\n    *args: Any,\n    bases: Sequence[Expr | str] | None = None,\n    decorators: list[Decorator] | None = None,\n    **kwargs: Any,\n) -&gt; None:\n\"\"\"Initialize the class.\n\n    Parameters:\n        *args: See [`griffe.dataclasses.Object`][].\n        bases: The list of base classes, if any.\n        decorators: The class decorators, if any.\n        **kwargs: See [`griffe.dataclasses.Object`][].\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.bases: list[Expr | str] = list(bases) if bases else []\n    self.decorators: list[Decorator] = decorators or []\n    self.overloads: dict[str, list[Function]] = defaultdict(list)\n</code></pre>"},{"location":"reference/griffe/#griffe.Class.all_members","title":"all_members  <code>property</code>","text":"<pre><code>all_members: dict[str, Object | Alias]\n</code></pre> <p>All members (declared and inherited).</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p>"},{"location":"reference/griffe/#griffe.Class.attributes","title":"attributes  <code>property</code>","text":"<pre><code>attributes: dict[str, Attribute]\n</code></pre> <p>Return the attribute members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Attribute]</code>         \u2013          <p>A dictionary of attributes.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Class.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Return the full dotted path of this object.</p> <p>The canonical path is the path where the object was defined (not imported).</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>A dotted path.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Class.classes","title":"classes  <code>property</code>","text":"<pre><code>classes: dict[str, Class]\n</code></pre> <p>Return the class members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Class]</code>         \u2013          <p>A dictionary of classes.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Class.filepath","title":"filepath  <code>property</code>","text":"<pre><code>filepath: Path | list[Path]\n</code></pre> <p>Return the file path where this object was defined.</p> <p>Returns:</p> <ul> <li> <code>Path | list[Path]</code>         \u2013          <p>A file path or a list of directories.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Class.functions","title":"functions  <code>property</code>","text":"<pre><code>functions: dict[str, Function]\n</code></pre> <p>Return the function members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Function]</code>         \u2013          <p>A dictionary of functions.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Class.has_docstring","title":"has_docstring  <code>property</code>","text":"<pre><code>has_docstring: bool\n</code></pre> <p>Tell if this object has a non-empty docstring.</p>"},{"location":"reference/griffe/#griffe.Class.has_docstrings","title":"has_docstrings  <code>property</code>","text":"<pre><code>has_docstrings: bool\n</code></pre> <p>Tell if this object or any of its members has a non-empty docstring.</p>"},{"location":"reference/griffe/#griffe.Class.inherited_members","title":"inherited_members  <code>cached</code> <code>property</code>","text":"<pre><code>inherited_members: dict[str, Alias]\n</code></pre> <p>Members that are inherited from base classes.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p>"},{"location":"reference/griffe/#griffe.Class.is_attribute","title":"is_attribute  <code>property</code>","text":"<pre><code>is_attribute: bool\n</code></pre> <p>Tell if this object is an attribute.</p>"},{"location":"reference/griffe/#griffe.Class.is_class","title":"is_class  <code>property</code>","text":"<pre><code>is_class: bool\n</code></pre> <p>Tell if this object is a class.</p>"},{"location":"reference/griffe/#griffe.Class.is_explicitely_exported","title":"is_explicitely_exported  <code>property</code>","text":"<pre><code>is_explicitely_exported: bool\n</code></pre> <p>Tell if this object/alias is explicitely exported by its parent.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Class.is_function","title":"is_function  <code>property</code>","text":"<pre><code>is_function: bool\n</code></pre> <p>Tell if this object is a function.</p>"},{"location":"reference/griffe/#griffe.Class.is_implicitely_exported","title":"is_implicitely_exported  <code>property</code>","text":"<pre><code>is_implicitely_exported: bool\n</code></pre> <p>Tell if this object/alias is implicitely exported by its parent.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Class.is_module","title":"is_module  <code>property</code>","text":"<pre><code>is_module: bool\n</code></pre> <p>Tell if this object is a module.</p>"},{"location":"reference/griffe/#griffe.Class.lines","title":"lines  <code>property</code>","text":"<pre><code>lines: list[str]\n</code></pre> <p>Return the lines containing the source of this object.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>         \u2013          <p>A list of lines.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Class.lines_collection","title":"lines_collection  <code>property</code>","text":"<pre><code>lines_collection: LinesCollection\n</code></pre> <p>Return the lines collection attached to this object or its parents.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When no modules collection can be found in the object or its parents.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>LinesCollection</code>         \u2013          <p>A lines collection.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Class.module","title":"module  <code>property</code>","text":"<pre><code>module: Module\n</code></pre> <p>Return the parent module of this object.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When the object is not a module and does not have a parent.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013          <p>The parent module.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Class.modules","title":"modules  <code>property</code>","text":"<pre><code>modules: dict[str, Module]\n</code></pre> <p>Return the module members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Module]</code>         \u2013          <p>A dictionary of modules.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Class.modules_collection","title":"modules_collection  <code>property</code>","text":"<pre><code>modules_collection: ModulesCollection\n</code></pre> <p>Return the modules collection attached to this object or its parents.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When no modules collection can be found in the object or its parents.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ModulesCollection</code>         \u2013          <p>A modules collection.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Class.package","title":"package  <code>property</code>","text":"<pre><code>package: Module\n</code></pre> <p>Return the absolute top module (the package) of this object.</p> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013          <p>The parent module.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Class.parameters","title":"parameters  <code>property</code>","text":"<pre><code>parameters: Parameters\n</code></pre> <p>Return the parameters of this class' <code>__init__</code> method, if any.</p> <p>This property fetches inherited members, and therefore is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>Parameters</code>         \u2013          <p>The parameters container.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Class.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Return the dotted path of this object.</p> <p>On regular objects (not aliases), the path is the canonical path.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>A dotted path.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Class.relative_filepath","title":"relative_filepath  <code>property</code>","text":"<pre><code>relative_filepath: Path\n</code></pre> <p>Return the file path where this object was defined, relative to the current working directory.</p> <p>If this object's file path is not relative to the current working directory, return its absolute path.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When the relative path could not be computed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code>         \u2013          <p>A file path.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Class.relative_package_filepath","title":"relative_package_filepath  <code>property</code>","text":"<pre><code>relative_package_filepath: Path\n</code></pre> <p>Return the file path where this object was defined, relative to the top module path.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When the relative path could not be computed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code>         \u2013          <p>A file path.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Class.resolved_bases","title":"resolved_bases  <code>cached</code> <code>property</code>","text":"<pre><code>resolved_bases: list[Object]\n</code></pre> <p>Resolved class bases.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p>"},{"location":"reference/griffe/#griffe.Class.source","title":"source  <code>property</code>","text":"<pre><code>source: str\n</code></pre> <p>Return the source code of this object.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The source code.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Class.__delitem__","title":"__delitem__","text":"<pre><code>__delitem__(key: str | Sequence[str]) -&gt; None\n</code></pre> <p>Delete a member with its name or path.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Members will be looked up in both declared members and inherited ones, triggering computation of the latter.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; del griffe_object[\"foo\"]\n&gt;&gt;&gt; del griffe_object[\"path.to.bar\"]\n&gt;&gt;&gt; del griffe_object[(\"path\", \"to\", \"qux\")]\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def __delitem__(self, key: str | Sequence[str]) -&gt; None:\n\"\"\"Delete a member with its name or path.\n\n    This method is part of the consumer API:\n    do not use when producing Griffe trees!\n\n    Members will be looked up in both declared members and inherited ones,\n    triggering computation of the latter.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; del griffe_object[\"foo\"]\n        &gt;&gt;&gt; del griffe_object[\"path.to.bar\"]\n        &gt;&gt;&gt; del griffe_object[(\"path\", \"to\", \"qux\")]\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        try:\n            del self.members[name]  # type: ignore[attr-defined]\n        except KeyError:\n            del self.inherited_members[name]  # type: ignore[attr-defined]\n    else:\n        del self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/#griffe.Class.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key: str | Sequence[str]) -&gt; Any\n</code></pre> <p>Get a member with its name or path.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Members will be looked up in both declared members and inherited ones, triggering computation of the latter.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; foo = griffe_object[\"foo\"]\n&gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n&gt;&gt;&gt; qux = griffe_object[(\"path\", \"to\", \"qux\")]\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def __getitem__(self, key: str | Sequence[str]) -&gt; Any:\n\"\"\"Get a member with its name or path.\n\n    This method is part of the consumer API:\n    do not use when producing Griffe trees!\n\n    Members will be looked up in both declared members and inherited ones,\n    triggering computation of the latter.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; foo = griffe_object[\"foo\"]\n        &gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n        &gt;&gt;&gt; qux = griffe_object[(\"path\", \"to\", \"qux\")]\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        return self.all_members[parts[0]]  # type: ignore[attr-defined]\n    return self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/#griffe.Class.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(\n    key: str | Sequence[str], value: Object | Alias\n) -&gt; None\n</code></pre> <p>Set a member with its name or path.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> <li> value             (<code>Object | Alias</code>)         \u2013          <p>The member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; griffe_object[\"foo\"] = foo\n&gt;&gt;&gt; griffe_object[\"path.to.bar\"] = bar\n&gt;&gt;&gt; griffe_object[(\"path\", \"to\", \"qux\")] = qux\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def __setitem__(self, key: str | Sequence[str], value: Object | Alias) -&gt; None:\n\"\"\"Set a member with its name or path.\n\n    This method is part of the consumer API:\n    do not use when producing Griffe trees!\n\n    Parameters:\n        key: The name or path of the member.\n        value: The member.\n\n    Examples:\n        &gt;&gt;&gt; griffe_object[\"foo\"] = foo\n        &gt;&gt;&gt; griffe_object[\"path.to.bar\"] = bar\n        &gt;&gt;&gt; griffe_object[(\"path\", \"to\", \"qux\")] = qux\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        self.members[name] = value  # type: ignore[attr-defined]\n        if self.is_collection:  # type: ignore[attr-defined]\n            value._modules_collection = self  # type: ignore[union-attr]\n        else:\n            value.parent = self  # type: ignore[assignment]\n    else:\n        self.members[parts[0]][parts[1:]] = value  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/#griffe.Class.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return this class' data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return this class' data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    base = super().as_dict(**kwargs)\n    base[\"bases\"] = self.bases\n    base[\"decorators\"] = [dec.as_dict(**kwargs) for dec in self.decorators]\n    return base\n</code></pre>"},{"location":"reference/griffe/#griffe.Class.as_json","title":"as_json","text":"<pre><code>as_json(*, full: bool = False, **kwargs: Any) -&gt; str\n</code></pre> <p>Return this object's data as a JSON string.</p> <p>Parameters:</p> <ul> <li> full             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to return full info, or just base info.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options passed to encoder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>A JSON string.</p> </li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>def as_json(self, *, full: bool = False, **kwargs: Any) -&gt; str:\n\"\"\"Return this object's data as a JSON string.\n\n    Parameters:\n        full: Whether to return full info, or just base info.\n        **kwargs: Additional serialization options passed to encoder.\n\n    Returns:\n        A JSON string.\n    \"\"\"\n    from griffe.encoders import JSONEncoder  # avoid circular import\n\n    return json.dumps(self, cls=JSONEncoder, full=full, **kwargs)\n</code></pre>"},{"location":"reference/griffe/#griffe.Class.del_member","title":"del_member","text":"<pre><code>del_member(key: str | Sequence[str]) -&gt; None\n</code></pre> <p>Delete a member with its name or path.</p> <p>This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).</p> <p>Members will be looked up in declared members only, not inherited ones.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; griffe_object.del_member(\"foo\")\n&gt;&gt;&gt; griffe_object.del_member(\"path.to.bar\")\n&gt;&gt;&gt; griffe_object.del_member((\"path\", \"to\", \"qux\"))\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def del_member(self, key: str | Sequence[str]) -&gt; None:\n\"\"\"Delete a member with its name or path.\n\n    This method is part of the producer API:\n    you can use it safely while building Griffe trees\n    (for example in Griffe extensions).\n\n    Members will be looked up in declared members only, not inherited ones.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; griffe_object.del_member(\"foo\")\n        &gt;&gt;&gt; griffe_object.del_member(\"path.to.bar\")\n        &gt;&gt;&gt; griffe_object.del_member((\"path\", \"to\", \"qux\"))\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        del self.members[name]  # type: ignore[attr-defined]\n    else:\n        self.members[parts[0]].del_member(parts[1:])  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/#griffe.Class.filter_members","title":"filter_members","text":"<pre><code>filter_members(\n    *predicates: Callable[[Object | Alias], bool]\n) -&gt; dict[str, Object | Alias]\n</code></pre> <p>Filter and return members based on predicates.</p> <p>Parameters:</p> <ul> <li> *predicates             (<code>Callable[[Object | Alias], bool]</code>, default:                 <code>()</code> )         \u2013          <p>A list of predicates, i.e. callables accepting a member as argument and returning a boolean.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Object | Alias]</code>         \u2013          <p>A dictionary of members.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def filter_members(self, *predicates: Callable[[Object | Alias], bool]) -&gt; dict[str, Object | Alias]:\n\"\"\"Filter and return members based on predicates.\n\n    Parameters:\n        *predicates: A list of predicates, i.e. callables accepting a member as argument and returning a boolean.\n\n    Returns:\n        A dictionary of members.\n    \"\"\"\n    if not predicates:\n        return self.members\n    members: dict[str, Object | Alias] = {}\n    for name, member in self.members.items():\n        if all(predicate(member) for predicate in predicates):\n            members[name] = member\n    return members\n</code></pre>"},{"location":"reference/griffe/#griffe.Class.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_string: str, **kwargs: Any) -&gt; _ObjType\n</code></pre> <p>Create an instance of this class from a JSON string.</p> <p>Parameters:</p> <ul> <li> json_string             (<code>str</code>)         \u2013          <p>JSON to decode into Object.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional options passed to decoder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_ObjType</code>         \u2013          <p>An Object instance.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>           \u2013          <p>When the json_string does not represent and object of the class from which this classmethod has been called.</p> </li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>@classmethod\ndef from_json(cls: type[_ObjType], json_string: str, **kwargs: Any) -&gt; _ObjType:  # noqa: PYI019\n\"\"\"Create an instance of this class from a JSON string.\n\n    Parameters:\n        json_string: JSON to decode into Object.\n        **kwargs: Additional options passed to decoder.\n\n    Returns:\n        An Object instance.\n\n    Raises:\n        TypeError: When the json_string does not represent and object\n            of the class from which this classmethod has been called.\n    \"\"\"\n    from griffe.encoders import json_decoder  # avoid circular import\n\n    kwargs.setdefault(\"object_hook\", json_decoder)\n    obj = json.loads(json_string, **kwargs)\n    if not isinstance(obj, cls):\n        raise TypeError(f\"provided JSON object is not of type {cls}\")\n    return obj\n</code></pre>"},{"location":"reference/griffe/#griffe.Class.get_member","title":"get_member","text":"<pre><code>get_member(key: str | Sequence[str]) -&gt; Any\n</code></pre> <p>Get a member with its name or path.</p> <p>This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).</p> <p>Members will be looked up in declared members only, not inherited ones.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; foo = griffe_object[\"foo\"]\n&gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n&gt;&gt;&gt; bar = griffe_object[(\"path\", \"to\", \"bar\")]\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def get_member(self, key: str | Sequence[str]) -&gt; Any:\n\"\"\"Get a member with its name or path.\n\n    This method is part of the producer API:\n    you can use it safely while building Griffe trees\n    (for example in Griffe extensions).\n\n    Members will be looked up in declared members only, not inherited ones.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; foo = griffe_object[\"foo\"]\n        &gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n        &gt;&gt;&gt; bar = griffe_object[(\"path\", \"to\", \"bar\")]\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        return self.members[parts[0]]  # type: ignore[attr-defined]\n    return self.members[parts[0]].get_member(parts[1:])  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/#griffe.Class.has_labels","title":"has_labels","text":"<pre><code>has_labels(labels: set[str]) -&gt; bool\n</code></pre> <p>Tell if this object has all the given labels.</p> <p>Parameters:</p> <ul> <li> labels             (<code>set[str]</code>)         \u2013          <p>A set of labels.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def has_labels(self, labels: set[str]) -&gt; bool:\n\"\"\"Tell if this object has all the given labels.\n\n    Parameters:\n        labels: A set of labels.\n\n    Returns:\n        True or False.\n    \"\"\"\n    return all(label in self.labels for label in labels)\n</code></pre>"},{"location":"reference/griffe/#griffe.Class.is_exported","title":"is_exported","text":"<pre><code>is_exported(*, explicitely: bool = True) -&gt; bool\n</code></pre> <p>Tell if this object/alias is implicitely exported by its parent.</p> <p>Parameters:</p> <ul> <li> explicitely             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to only return True when <code>__all__</code> is defined.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>def is_exported(self, *, explicitely: bool = True) -&gt; bool:\n\"\"\"Tell if this object/alias is implicitely exported by its parent.\n\n    Parameters:\n        explicitely: Whether to only return True when `__all__` is defined.\n\n    Returns:\n        True or False.\n    \"\"\"\n    return self.parent.member_is_exported(self, explicitely=explicitely)  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/#griffe.Class.is_kind","title":"is_kind","text":"<pre><code>is_kind(kind: str | Kind | set[str | Kind]) -&gt; bool\n</code></pre> <p>Tell if this object is of the given kind.</p> <p>Parameters:</p> <ul> <li> kind             (<code>str | Kind | set[str | Kind]</code>)         \u2013          <p>An instance or set of kinds (strings or enumerations).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When an empty set is given as argument.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def is_kind(self, kind: str | Kind | set[str | Kind]) -&gt; bool:\n\"\"\"Tell if this object is of the given kind.\n\n    Parameters:\n        kind: An instance or set of kinds (strings or enumerations).\n\n    Raises:\n        ValueError: When an empty set is given as argument.\n\n    Returns:\n        True or False.\n    \"\"\"\n    if isinstance(kind, set):\n        if not kind:\n            raise ValueError(\"kind must not be an empty set\")\n        return self.kind in (knd if isinstance(knd, Kind) else Kind(knd) for knd in kind)\n    if isinstance(kind, str):\n        kind = Kind(kind)\n    return self.kind is kind\n</code></pre>"},{"location":"reference/griffe/#griffe.Class.is_public","title":"is_public","text":"<pre><code>is_public(\n    *, strict: bool = False, check_name: bool = True\n) -&gt; bool\n</code></pre> <p>Whether this object is considered public.</p> <p>In modules, developers can mark objects as public thanks to the <code>__all__</code> variable. In classes however, there is no convention or standard to do so.</p> <p>Therefore, to decide whether an object is public, we follow this algorithm:</p> <ul> <li>If the object's <code>public</code> attribute is set (boolean), return its value.</li> <li>In strict mode, the object is public only if it is explicitely exported (listed in <code>__all__</code>).     Strict mode should only be used for module members.</li> <li>Otherwise, if name checks are enabled, the object is private if its name starts with an underscore.</li> <li>Otherwise, if the object is an alias, and is neither inherited from a base class,     nor a member of a parent alias, it is not public.</li> <li>Otherwise, the object is public.</li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>def is_public(\n    self,\n    *,\n    strict: bool = False,\n    check_name: bool = True,\n) -&gt; bool:\n\"\"\"Whether this object is considered public.\n\n    In modules, developers can mark objects as public thanks to the `__all__` variable.\n    In classes however, there is no convention or standard to do so.\n\n    Therefore, to decide whether an object is public, we follow this algorithm:\n\n    - If the object's `public` attribute is set (boolean), return its value.\n    - In strict mode, the object is public only if it is explicitely exported (listed in `__all__`).\n        Strict mode should only be used for module members.\n    - Otherwise, if name checks are enabled, the object is private if its name starts with an underscore.\n    - Otherwise, if the object is an alias, and is neither inherited from a base class,\n        nor a member of a parent alias, it is not public.\n    - Otherwise, the object is public.\n    \"\"\"\n    if self.public is not None:  # type: ignore[attr-defined]\n        return self.public  # type: ignore[attr-defined]\n    if self.is_explicitely_exported:\n        return True\n    if strict:\n        return False\n    if check_name and self.name.startswith(\"_\"):  # type: ignore[attr-defined]\n        return False\n    if self.is_alias and not (self.inherited or self.parent.is_alias):  # type: ignore[attr-defined]\n        return False\n    return True\n</code></pre>"},{"location":"reference/griffe/#griffe.Class.member_is_exported","title":"member_is_exported","text":"<pre><code>member_is_exported(\n    member: Object | Alias, *, explicitely: bool = True\n) -&gt; bool\n</code></pre> <p>Tell if a member of this object is \"exported\".</p> <p>By exported, we mean that the object is included in the <code>__all__</code> attribute of its parent module or class. When <code>__all__</code> is not defined, we consider the member to be implicitely exported, unless it's a module and it was not imported, and unless it's not defined at runtime.</p> <p>Parameters:</p> <ul> <li> member             (<code>Object | Alias</code>)         \u2013          <p>The member to verify.</p> </li> <li> explicitely             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to only return True when <code>__all__</code> is defined.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def member_is_exported(self, member: Object | Alias, *, explicitely: bool = True) -&gt; bool:\n\"\"\"Tell if a member of this object is \"exported\".\n\n    By exported, we mean that the object is included in the `__all__` attribute\n    of its parent module or class. When `__all__` is not defined,\n    we consider the member to be *implicitely* exported,\n    unless it's a module and it was not imported,\n    and unless it's not defined at runtime.\n\n    Parameters:\n        member: The member to verify.\n        explicitely: Whether to only return True when `__all__` is defined.\n\n    Returns:\n        True or False.\n    \"\"\"\n    if not member.runtime:\n        return False\n    if self.exports is None:\n        return not explicitely and (member.is_alias or not member.is_module or member.name in self.imports)\n    return member.name in self.exports\n</code></pre>"},{"location":"reference/griffe/#griffe.Class.mro","title":"mro","text":"<pre><code>mro() -&gt; list[Class]\n</code></pre> <p>Return a list of classes in order corresponding to Python's MRO.</p> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def mro(self) -&gt; list[Class]:\n\"\"\"Return a list of classes in order corresponding to Python's MRO.\"\"\"\n    return self._mro()[1:]  # remove self\n</code></pre>"},{"location":"reference/griffe/#griffe.Class.resolve","title":"resolve","text":"<pre><code>resolve(name: str) -&gt; str\n</code></pre> <p>Resolve a name within this object's and parents' scope.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013          <p>The name to resolve.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NameResolutionError</code>           \u2013          <p>When the name could not be resolved.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The resolved name.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def resolve(self, name: str) -&gt; str:\n\"\"\"Resolve a name within this object's and parents' scope.\n\n    Parameters:\n        name: The name to resolve.\n\n    Raises:\n        NameResolutionError: When the name could not be resolved.\n\n    Returns:\n        The resolved name.\n    \"\"\"\n    if name in self.members:\n        if self.members[name].is_alias:\n            return self.members[name].target_path  # type: ignore[union-attr]\n        return self.members[name].path\n    if name in self.imports:\n        return self.imports[name]\n    if self.parent is None:\n        # could be a built-in\n        raise NameResolutionError(f\"{name} could not be resolved in the scope of {self.path}\")\n    if name == self.parent.name and not self.parent.is_module:\n        return self.parent.path\n    return self.parent.resolve(name)\n</code></pre>"},{"location":"reference/griffe/#griffe.Class.set_member","title":"set_member","text":"<pre><code>set_member(\n    key: str | Sequence[str], value: Object | Alias\n) -&gt; None\n</code></pre> <p>Set a member with its name or path.</p> <p>This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> <li> value             (<code>Object | Alias</code>)         \u2013          <p>The member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; griffe_object.set_member(\"foo\", foo)\n&gt;&gt;&gt; griffe_object.set_member(\"path.to.bar\", bar)\n&gt;&gt;&gt; griffe_object.set_member((\"path\", \"to\", \"qux\", qux)\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def set_member(self, key: str | Sequence[str], value: Object | Alias) -&gt; None:\n\"\"\"Set a member with its name or path.\n\n    This method is part of the producer API:\n    you can use it safely while building Griffe trees\n    (for example in Griffe extensions).\n\n    Parameters:\n        key: The name or path of the member.\n        value: The member.\n\n    Examples:\n        &gt;&gt;&gt; griffe_object.set_member(\"foo\", foo)\n        &gt;&gt;&gt; griffe_object.set_member(\"path.to.bar\", bar)\n        &gt;&gt;&gt; griffe_object.set_member((\"path\", \"to\", \"qux\", qux)\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        if name in self.members:  # type: ignore[attr-defined]\n            member = self.members[name]  # type: ignore[attr-defined]\n            if not member.is_alias:\n                # when reassigning a module to an existing one,\n                # try to merge them as one regular and one stubs module\n                # (implicit support for .pyi modules)\n                if member.is_module and not (member.is_namespace_package or member.is_namespace_subpackage):\n                    with suppress(AliasResolutionError, CyclicAliasError):\n                        if value.is_module and value.filepath != member.filepath:\n                            with suppress(ValueError):\n                                value = merge_stubs(member, value)  # type: ignore[arg-type]\n                for alias in member.aliases.values():\n                    with suppress(CyclicAliasError):\n                        alias.target = value\n        self.members[name] = value  # type: ignore[attr-defined]\n        if self.is_collection:  # type: ignore[attr-defined]\n            value._modules_collection = self  # type: ignore[union-attr]\n        else:\n            value.parent = self  # type: ignore[assignment]\n    else:\n        self.members[parts[0]].set_member(parts[1:], value)  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/#griffe.Docstring","title":"Docstring","text":"<pre><code>Docstring(\n    value: str,\n    *,\n    lineno: int | None = None,\n    endlineno: int | None = None,\n    parent: Object | None = None,\n    parser: Literal[\"google\", \"numpy\", \"sphinx\"]\n    | Parser\n    | None = None,\n    parser_options: dict[str, Any] | None = None\n)\n</code></pre> <p>This class represents docstrings.</p> <p>Attributes:</p> <ul> <li> value             (<code>str</code>)         \u2013          <p>The actual documentation string, cleaned up.</p> </li> <li> lineno             (<code>int | None</code>)         \u2013          <p>The starting line number.</p> </li> <li> endlineno             (<code>int | None</code>)         \u2013          <p>The ending line number.</p> </li> <li> parent             (<code>Object | None</code>)         \u2013          <p>The parent object on which this docstring is attached.</p> </li> </ul> <p>Parameters:</p> <ul> <li> value             (<code>str</code>)         \u2013          <p>The docstring value.</p> </li> <li> lineno             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>The starting line number.</p> </li> <li> endlineno             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>The ending line number.</p> </li> <li> parent             (<code>Object | None</code>, default:                 <code>None</code> )         \u2013          <p>The parent object on which this docstring is attached.</p> </li> <li> parser             (<code>Literal['google', 'numpy', 'sphinx'] | Parser | None</code>, default:                 <code>None</code> )         \u2013          <p>The docstring parser to use. By default, no parsing is done.</p> </li> <li> parser_options             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional docstring parsing options.</p> </li> </ul> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this docstring's data as a dictionary.</p> </li> <li> parse           \u2013            <p>Parse the docstring into structured data.</p> </li> </ul> <p>Attributes:</p> <ul> <li> lines             (<code>list[str]</code>)         \u2013          <p>Returns the lines of the docstring.</p> </li> <li> parsed             (<code>list[DocstringSection]</code>)         \u2013          <p>Return the docstring, parsed into structured data.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def __init__(\n    self,\n    value: str,\n    *,\n    lineno: int | None = None,\n    endlineno: int | None = None,\n    parent: Object | None = None,\n    parser: Literal[\"google\", \"numpy\", \"sphinx\"] | Parser | None = None,\n    parser_options: dict[str, Any] | None = None,\n) -&gt; None:\n\"\"\"Initialize the docstring.\n\n    Parameters:\n        value: The docstring value.\n        lineno: The starting line number.\n        endlineno: The ending line number.\n        parent: The parent object on which this docstring is attached.\n        parser: The docstring parser to use. By default, no parsing is done.\n        parser_options: Additional docstring parsing options.\n    \"\"\"\n    self.value: str = inspect.cleandoc(value.rstrip())\n    self.lineno: int | None = lineno\n    self.endlineno: int | None = endlineno\n    self.parent: Object | None = parent\n    self.parser: Literal[\"google\", \"numpy\", \"sphinx\"] | Parser | None = parser\n    self.parser_options: dict[str, Any] = parser_options or {}\n</code></pre>"},{"location":"reference/griffe/#griffe.Docstring.lines","title":"lines  <code>property</code>","text":"<pre><code>lines: list[str]\n</code></pre> <p>Returns the lines of the docstring.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>         \u2013          <p>The docstring's lines.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Docstring.parsed","title":"parsed  <code>cached</code> <code>property</code>","text":"<pre><code>parsed: list[DocstringSection]\n</code></pre> <p>Return the docstring, parsed into structured data.</p> <p>Returns:</p> <ul> <li> <code>list[DocstringSection]</code>         \u2013          <p>The parsed docstring as a list of sections.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Docstring.as_dict","title":"as_dict","text":"<pre><code>as_dict(\n    *,\n    full: bool = False,\n    docstring_parser: Parser | None = None,\n    **kwargs: Any\n) -&gt; dict[str, Any]\n</code></pre> <p>Return this docstring's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> full             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to return full info, or just base info.</p> </li> <li> docstring_parser             (<code>Parser | None</code>, default:                 <code>None</code> )         \u2013          <p>The docstring parser to parse the docstring with. By default, no parsing is done.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization or docstring parsing options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def as_dict(self, *, full: bool = False, docstring_parser: Parser | None = None, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return this docstring's data as a dictionary.\n\n    Parameters:\n        full: Whether to return full info, or just base info.\n        docstring_parser: The docstring parser to parse the docstring with. By default, no parsing is done.\n        **kwargs: Additional serialization or docstring parsing options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    base: dict[str, Any] = {\n        \"value\": self.value,\n        \"lineno\": self.lineno,\n        \"endlineno\": self.endlineno,\n    }\n    if full:\n        base[\"parsed\"] = self.parse(docstring_parser, **kwargs)\n    return base\n</code></pre>"},{"location":"reference/griffe/#griffe.Docstring.parse","title":"parse","text":"<pre><code>parse(\n    parser: Literal[\"google\", \"numpy\", \"sphinx\"]\n    | Parser\n    | None = None,\n    **options: Any\n) -&gt; list[DocstringSection]\n</code></pre> <p>Parse the docstring into structured data.</p> <p>Parameters:</p> <ul> <li> parser             (<code>Literal['google', 'numpy', 'sphinx'] | Parser | None</code>, default:                 <code>None</code> )         \u2013          <p>The docstring parser to use. In order: use the given parser, or the self parser, or no parser (return a single text section).</p> </li> <li> **options             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional docstring parsing options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[DocstringSection]</code>         \u2013          <p>The parsed docstring as a list of sections.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def parse(\n    self,\n    parser: Literal[\"google\", \"numpy\", \"sphinx\"] | Parser | None = None,\n    **options: Any,\n) -&gt; list[DocstringSection]:\n\"\"\"Parse the docstring into structured data.\n\n    Parameters:\n        parser: The docstring parser to use.\n            In order: use the given parser, or the self parser, or no parser (return a single text section).\n        **options: Additional docstring parsing options.\n\n    Returns:\n        The parsed docstring as a list of sections.\n    \"\"\"\n    return parse(self, parser or self.parser, **(options or self.parser_options))\n</code></pre>"},{"location":"reference/griffe/#griffe.Extension","title":"Extension","text":"<p>Base class for Griffe extensions.</p> <p>Methods:</p> <ul> <li> generic_inspect           \u2013            <p>Extend the base generic inspection with extensions.</p> </li> <li> generic_visit           \u2013            <p>Visit children nodes.</p> </li> <li> inspect           \u2013            <p>Inspect a node.</p> </li> <li> on_attribute_instance           \u2013            <p>Run when an Attribute has been created.</p> </li> <li> on_attribute_node           \u2013            <p>Run when visiting a new attribute node during static/dynamic analysis.</p> </li> <li> on_class_instance           \u2013            <p>Run when a Class has been created.</p> </li> <li> on_class_members           \u2013            <p>Run when members of a Class have been loaded.</p> </li> <li> on_class_node           \u2013            <p>Run when visiting a new class node during static/dynamic analysis.</p> </li> <li> on_function_instance           \u2013            <p>Run when a Function has been created.</p> </li> <li> on_function_node           \u2013            <p>Run when visiting a new function node during static/dynamic analysis.</p> </li> <li> on_instance           \u2013            <p>Run when an Object has been created.</p> </li> <li> on_members           \u2013            <p>Run when members of an Object have been loaded.</p> </li> <li> on_module_instance           \u2013            <p>Run when a Module has been created.</p> </li> <li> on_module_members           \u2013            <p>Run when members of a Module have been loaded.</p> </li> <li> on_module_node           \u2013            <p>Run when visiting a new module node during static/dynamic analysis.</p> </li> <li> on_node           \u2013            <p>Run when visiting a new node during static/dynamic analysis.</p> </li> <li> visit           \u2013            <p>Visit a node.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Extension.generic_inspect","title":"generic_inspect","text":"<pre><code>generic_inspect(node: ObjectNode) -&gt; None\n</code></pre> <p>Extend the base generic inspection with extensions.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013          <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def generic_inspect(self, node: ObjectNode) -&gt; None:\n\"\"\"Extend the base generic inspection with extensions.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    for child in node.children:\n        if not child.alias_target_path:\n            self.inspect(child)\n</code></pre>"},{"location":"reference/griffe/#griffe.Extension.generic_visit","title":"generic_visit","text":"<pre><code>generic_visit(node: AST) -&gt; None\n</code></pre> <p>Visit children nodes.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST</code>)         \u2013          <p>The node to visit the children of.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def generic_visit(self, node: ast.AST) -&gt; None:\n\"\"\"Visit children nodes.\n\n    Parameters:\n        node: The node to visit the children of.\n    \"\"\"\n    for child in ast_children(node):\n        self.visit(child)\n</code></pre>"},{"location":"reference/griffe/#griffe.Extension.inspect","title":"inspect","text":"<pre><code>inspect(node: ObjectNode) -&gt; None\n</code></pre> <p>Inspect a node.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013          <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def inspect(self, node: ObjectNode) -&gt; None:\n\"\"\"Inspect a node.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    getattr(self, f\"inspect_{node.kind}\", lambda _: None)(node)\n</code></pre>"},{"location":"reference/griffe/#griffe.Extension.on_attribute_instance","title":"on_attribute_instance","text":"<pre><code>on_attribute_instance(\n    *, node: AST | ObjectNode, attr: Attribute\n) -&gt; None\n</code></pre> <p>Run when an Attribute has been created.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> <li> attr             (<code>Attribute</code>)         \u2013          <p>The attribute instance.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_attribute_instance(self, *, node: ast.AST | ObjectNode, attr: Attribute) -&gt; None:\n\"\"\"Run when an Attribute has been created.\n\n    Parameters:\n        node: The currently visited node.\n        attr: The attribute instance.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/#griffe.Extension.on_attribute_node","title":"on_attribute_node","text":"<pre><code>on_attribute_node(*, node: AST | ObjectNode) -&gt; None\n</code></pre> <p>Run when visiting a new attribute node during static/dynamic analysis.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_attribute_node(self, *, node: ast.AST | ObjectNode) -&gt; None:\n\"\"\"Run when visiting a new attribute node during static/dynamic analysis.\n\n    Parameters:\n        node: The currently visited node.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/#griffe.Extension.on_class_instance","title":"on_class_instance","text":"<pre><code>on_class_instance(\n    *, node: AST | ObjectNode, cls: Class\n) -&gt; None\n</code></pre> <p>Run when a Class has been created.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> <li> cls             (<code>Class</code>)         \u2013          <p>The class instance.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_class_instance(self, *, node: ast.AST | ObjectNode, cls: Class) -&gt; None:\n\"\"\"Run when a Class has been created.\n\n    Parameters:\n        node: The currently visited node.\n        cls: The class instance.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/#griffe.Extension.on_class_members","title":"on_class_members","text":"<pre><code>on_class_members(\n    *, node: AST | ObjectNode, cls: Class\n) -&gt; None\n</code></pre> <p>Run when members of a Class have been loaded.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> <li> cls             (<code>Class</code>)         \u2013          <p>The class instance.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_class_members(self, *, node: ast.AST | ObjectNode, cls: Class) -&gt; None:\n\"\"\"Run when members of a Class have been loaded.\n\n    Parameters:\n        node: The currently visited node.\n        cls: The class instance.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/#griffe.Extension.on_class_node","title":"on_class_node","text":"<pre><code>on_class_node(*, node: AST | ObjectNode) -&gt; None\n</code></pre> <p>Run when visiting a new class node during static/dynamic analysis.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_class_node(self, *, node: ast.AST | ObjectNode) -&gt; None:\n\"\"\"Run when visiting a new class node during static/dynamic analysis.\n\n    Parameters:\n        node: The currently visited node.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/#griffe.Extension.on_function_instance","title":"on_function_instance","text":"<pre><code>on_function_instance(\n    *, node: AST | ObjectNode, func: Function\n) -&gt; None\n</code></pre> <p>Run when a Function has been created.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> <li> func             (<code>Function</code>)         \u2013          <p>The function instance.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_function_instance(self, *, node: ast.AST | ObjectNode, func: Function) -&gt; None:\n\"\"\"Run when a Function has been created.\n\n    Parameters:\n        node: The currently visited node.\n        func: The function instance.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/#griffe.Extension.on_function_node","title":"on_function_node","text":"<pre><code>on_function_node(*, node: AST | ObjectNode) -&gt; None\n</code></pre> <p>Run when visiting a new function node during static/dynamic analysis.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_function_node(self, *, node: ast.AST | ObjectNode) -&gt; None:\n\"\"\"Run when visiting a new function node during static/dynamic analysis.\n\n    Parameters:\n        node: The currently visited node.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/#griffe.Extension.on_instance","title":"on_instance","text":"<pre><code>on_instance(*, node: AST | ObjectNode, obj: Object) -&gt; None\n</code></pre> <p>Run when an Object has been created.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> <li> obj             (<code>Object</code>)         \u2013          <p>The object instance.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_instance(self, *, node: ast.AST | ObjectNode, obj: Object) -&gt; None:\n\"\"\"Run when an Object has been created.\n\n    Parameters:\n        node: The currently visited node.\n        obj: The object instance.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/#griffe.Extension.on_members","title":"on_members","text":"<pre><code>on_members(*, node: AST | ObjectNode, obj: Object) -&gt; None\n</code></pre> <p>Run when members of an Object have been loaded.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> <li> obj             (<code>Object</code>)         \u2013          <p>The object instance.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_members(self, *, node: ast.AST | ObjectNode, obj: Object) -&gt; None:\n\"\"\"Run when members of an Object have been loaded.\n\n    Parameters:\n        node: The currently visited node.\n        obj: The object instance.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/#griffe.Extension.on_module_instance","title":"on_module_instance","text":"<pre><code>on_module_instance(\n    *, node: AST | ObjectNode, mod: Module\n) -&gt; None\n</code></pre> <p>Run when a Module has been created.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> <li> mod             (<code>Module</code>)         \u2013          <p>The module instance.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_module_instance(self, *, node: ast.AST | ObjectNode, mod: Module) -&gt; None:\n\"\"\"Run when a Module has been created.\n\n    Parameters:\n        node: The currently visited node.\n        mod: The module instance.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/#griffe.Extension.on_module_members","title":"on_module_members","text":"<pre><code>on_module_members(\n    *, node: AST | ObjectNode, mod: Module\n) -&gt; None\n</code></pre> <p>Run when members of a Module have been loaded.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> <li> mod             (<code>Module</code>)         \u2013          <p>The module instance.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_module_members(self, *, node: ast.AST | ObjectNode, mod: Module) -&gt; None:\n\"\"\"Run when members of a Module have been loaded.\n\n    Parameters:\n        node: The currently visited node.\n        mod: The module instance.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/#griffe.Extension.on_module_node","title":"on_module_node","text":"<pre><code>on_module_node(*, node: AST | ObjectNode) -&gt; None\n</code></pre> <p>Run when visiting a new module node during static/dynamic analysis.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_module_node(self, *, node: ast.AST | ObjectNode) -&gt; None:\n\"\"\"Run when visiting a new module node during static/dynamic analysis.\n\n    Parameters:\n        node: The currently visited node.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/#griffe.Extension.on_node","title":"on_node","text":"<pre><code>on_node(*, node: AST | ObjectNode) -&gt; None\n</code></pre> <p>Run when visiting a new node during static/dynamic analysis.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_node(self, *, node: ast.AST | ObjectNode) -&gt; None:\n\"\"\"Run when visiting a new node during static/dynamic analysis.\n\n    Parameters:\n        node: The currently visited node.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/#griffe.Extension.visit","title":"visit","text":"<pre><code>visit(node: AST) -&gt; None\n</code></pre> <p>Visit a node.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST</code>)         \u2013          <p>The node to visit.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def visit(self, node: ast.AST) -&gt; None:\n\"\"\"Visit a node.\n\n    Parameters:\n        node: The node to visit.\n    \"\"\"\n    getattr(self, f\"visit_{ast_kind(node)}\", lambda _: None)(node)\n</code></pre>"},{"location":"reference/griffe/#griffe.Function","title":"Function","text":"<pre><code>Function(\n    *args: Any,\n    parameters: Parameters | None = None,\n    returns: str | Expr | None = None,\n    decorators: list[Decorator] | None = None,\n    **kwargs: Any\n)\n</code></pre> <p>             Bases: <code>Object</code></p> <p>The class representing a Python function.</p> <p>Parameters:</p> <ul> <li> *args             (<code>Any</code>, default:                 <code>()</code> )         \u2013          <p>See <code>griffe.dataclasses.Object</code>.</p> </li> <li> parameters             (<code>Parameters | None</code>, default:                 <code>None</code> )         \u2013          <p>The function parameters.</p> </li> <li> returns             (<code>str | Expr | None</code>, default:                 <code>None</code> )         \u2013          <p>The function return annotation.</p> </li> <li> decorators             (<code>list[Decorator] | None</code>, default:                 <code>None</code> )         \u2013          <p>The function decorators, if any.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>See <code>griffe.dataclasses.Object</code>.</p> </li> </ul> <p>Methods:</p> <ul> <li> __delitem__           \u2013            <p>Delete a member with its name or path.</p> </li> <li> __getitem__           \u2013            <p>Get a member with its name or path.</p> </li> <li> __setitem__           \u2013            <p>Set a member with its name or path.</p> </li> <li> as_dict           \u2013            <p>Return this function's data as a dictionary.</p> </li> <li> as_json           \u2013            <p>Return this object's data as a JSON string.</p> </li> <li> del_member           \u2013            <p>Delete a member with its name or path.</p> </li> <li> filter_members           \u2013            <p>Filter and return members based on predicates.</p> </li> <li> from_json           \u2013            <p>Create an instance of this class from a JSON string.</p> </li> <li> get_member           \u2013            <p>Get a member with its name or path.</p> </li> <li> has_labels           \u2013            <p>Tell if this object has all the given labels.</p> </li> <li> is_exported           \u2013            <p>Tell if this object/alias is implicitely exported by its parent.</p> </li> <li> is_kind           \u2013            <p>Tell if this object is of the given kind.</p> </li> <li> is_public           \u2013            <p>Whether this object is considered public.</p> </li> <li> member_is_exported           \u2013            <p>Tell if a member of this object is \"exported\".</p> </li> <li> resolve           \u2013            <p>Resolve a name within this object's and parents' scope.</p> </li> <li> set_member           \u2013            <p>Set a member with its name or path.</p> </li> </ul> <p>Attributes:</p> <ul> <li> all_members             (<code>dict[str, Object | Alias]</code>)         \u2013          <p>All members (declared and inherited).</p> </li> <li> annotation             (<code>str | Expr | None</code>)         \u2013          <p>Return the return annotation.</p> </li> <li> attributes             (<code>dict[str, Attribute]</code>)         \u2013          <p>Return the attribute members.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Return the full dotted path of this object.</p> </li> <li> classes             (<code>dict[str, Class]</code>)         \u2013          <p>Return the class members.</p> </li> <li> filepath             (<code>Path | list[Path]</code>)         \u2013          <p>Return the file path where this object was defined.</p> </li> <li> functions             (<code>dict[str, Function]</code>)         \u2013          <p>Return the function members.</p> </li> <li> has_docstring             (<code>bool</code>)         \u2013          <p>Tell if this object has a non-empty docstring.</p> </li> <li> has_docstrings             (<code>bool</code>)         \u2013          <p>Tell if this object or any of its members has a non-empty docstring.</p> </li> <li> inherited_members             (<code>dict[str, Alias]</code>)         \u2013          <p>Members that are inherited from base classes.</p> </li> <li> is_attribute             (<code>bool</code>)         \u2013          <p>Tell if this object is an attribute.</p> </li> <li> is_class             (<code>bool</code>)         \u2013          <p>Tell if this object is a class.</p> </li> <li> is_explicitely_exported             (<code>bool</code>)         \u2013          <p>Tell if this object/alias is explicitely exported by its parent.</p> </li> <li> is_function             (<code>bool</code>)         \u2013          <p>Tell if this object is a function.</p> </li> <li> is_implicitely_exported             (<code>bool</code>)         \u2013          <p>Tell if this object/alias is implicitely exported by its parent.</p> </li> <li> is_module             (<code>bool</code>)         \u2013          <p>Tell if this object is a module.</p> </li> <li> lines             (<code>list[str]</code>)         \u2013          <p>Return the lines containing the source of this object.</p> </li> <li> lines_collection             (<code>LinesCollection</code>)         \u2013          <p>Return the lines collection attached to this object or its parents.</p> </li> <li> module             (<code>Module</code>)         \u2013          <p>Return the parent module of this object.</p> </li> <li> modules             (<code>dict[str, Module]</code>)         \u2013          <p>Return the module members.</p> </li> <li> modules_collection             (<code>ModulesCollection</code>)         \u2013          <p>Return the modules collection attached to this object or its parents.</p> </li> <li> package             (<code>Module</code>)         \u2013          <p>Return the absolute top module (the package) of this object.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Return the dotted path of this object.</p> </li> <li> relative_filepath             (<code>Path</code>)         \u2013          <p>Return the file path where this object was defined, relative to the current working directory.</p> </li> <li> relative_package_filepath             (<code>Path</code>)         \u2013          <p>Return the file path where this object was defined, relative to the top module path.</p> </li> <li> source             (<code>str</code>)         \u2013          <p>Return the source code of this object.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def __init__(\n    self,\n    *args: Any,\n    parameters: Parameters | None = None,\n    returns: str | Expr | None = None,\n    decorators: list[Decorator] | None = None,\n    **kwargs: Any,\n) -&gt; None:\n\"\"\"Initialize the function.\n\n    Parameters:\n        *args: See [`griffe.dataclasses.Object`][].\n        parameters: The function parameters.\n        returns: The function return annotation.\n        decorators: The function decorators, if any.\n        **kwargs: See [`griffe.dataclasses.Object`][].\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.parameters: Parameters = parameters or Parameters()\n    self.returns: str | Expr | None = returns\n    self.decorators: list[Decorator] = decorators or []\n    self.setter: Function | None = None\n    self.deleter: Function | None = None\n    self.overloads: list[Function] | None = None\n</code></pre>"},{"location":"reference/griffe/#griffe.Function.all_members","title":"all_members  <code>property</code>","text":"<pre><code>all_members: dict[str, Object | Alias]\n</code></pre> <p>All members (declared and inherited).</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p>"},{"location":"reference/griffe/#griffe.Function.annotation","title":"annotation  <code>property</code>","text":"<pre><code>annotation: str | Expr | None\n</code></pre> <p>Return the return annotation.</p> <p>Returns:</p> <ul> <li> <code>str | Expr | None</code>         \u2013          <p>The function return annotation.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Function.attributes","title":"attributes  <code>property</code>","text":"<pre><code>attributes: dict[str, Attribute]\n</code></pre> <p>Return the attribute members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Attribute]</code>         \u2013          <p>A dictionary of attributes.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Function.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Return the full dotted path of this object.</p> <p>The canonical path is the path where the object was defined (not imported).</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>A dotted path.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Function.classes","title":"classes  <code>property</code>","text":"<pre><code>classes: dict[str, Class]\n</code></pre> <p>Return the class members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Class]</code>         \u2013          <p>A dictionary of classes.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Function.filepath","title":"filepath  <code>property</code>","text":"<pre><code>filepath: Path | list[Path]\n</code></pre> <p>Return the file path where this object was defined.</p> <p>Returns:</p> <ul> <li> <code>Path | list[Path]</code>         \u2013          <p>A file path or a list of directories.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Function.functions","title":"functions  <code>property</code>","text":"<pre><code>functions: dict[str, Function]\n</code></pre> <p>Return the function members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Function]</code>         \u2013          <p>A dictionary of functions.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Function.has_docstring","title":"has_docstring  <code>property</code>","text":"<pre><code>has_docstring: bool\n</code></pre> <p>Tell if this object has a non-empty docstring.</p>"},{"location":"reference/griffe/#griffe.Function.has_docstrings","title":"has_docstrings  <code>property</code>","text":"<pre><code>has_docstrings: bool\n</code></pre> <p>Tell if this object or any of its members has a non-empty docstring.</p>"},{"location":"reference/griffe/#griffe.Function.inherited_members","title":"inherited_members  <code>cached</code> <code>property</code>","text":"<pre><code>inherited_members: dict[str, Alias]\n</code></pre> <p>Members that are inherited from base classes.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p>"},{"location":"reference/griffe/#griffe.Function.is_attribute","title":"is_attribute  <code>property</code>","text":"<pre><code>is_attribute: bool\n</code></pre> <p>Tell if this object is an attribute.</p>"},{"location":"reference/griffe/#griffe.Function.is_class","title":"is_class  <code>property</code>","text":"<pre><code>is_class: bool\n</code></pre> <p>Tell if this object is a class.</p>"},{"location":"reference/griffe/#griffe.Function.is_explicitely_exported","title":"is_explicitely_exported  <code>property</code>","text":"<pre><code>is_explicitely_exported: bool\n</code></pre> <p>Tell if this object/alias is explicitely exported by its parent.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Function.is_function","title":"is_function  <code>property</code>","text":"<pre><code>is_function: bool\n</code></pre> <p>Tell if this object is a function.</p>"},{"location":"reference/griffe/#griffe.Function.is_implicitely_exported","title":"is_implicitely_exported  <code>property</code>","text":"<pre><code>is_implicitely_exported: bool\n</code></pre> <p>Tell if this object/alias is implicitely exported by its parent.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Function.is_module","title":"is_module  <code>property</code>","text":"<pre><code>is_module: bool\n</code></pre> <p>Tell if this object is a module.</p>"},{"location":"reference/griffe/#griffe.Function.lines","title":"lines  <code>property</code>","text":"<pre><code>lines: list[str]\n</code></pre> <p>Return the lines containing the source of this object.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>         \u2013          <p>A list of lines.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Function.lines_collection","title":"lines_collection  <code>property</code>","text":"<pre><code>lines_collection: LinesCollection\n</code></pre> <p>Return the lines collection attached to this object or its parents.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When no modules collection can be found in the object or its parents.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>LinesCollection</code>         \u2013          <p>A lines collection.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Function.module","title":"module  <code>property</code>","text":"<pre><code>module: Module\n</code></pre> <p>Return the parent module of this object.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When the object is not a module and does not have a parent.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013          <p>The parent module.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Function.modules","title":"modules  <code>property</code>","text":"<pre><code>modules: dict[str, Module]\n</code></pre> <p>Return the module members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Module]</code>         \u2013          <p>A dictionary of modules.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Function.modules_collection","title":"modules_collection  <code>property</code>","text":"<pre><code>modules_collection: ModulesCollection\n</code></pre> <p>Return the modules collection attached to this object or its parents.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When no modules collection can be found in the object or its parents.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ModulesCollection</code>         \u2013          <p>A modules collection.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Function.package","title":"package  <code>property</code>","text":"<pre><code>package: Module\n</code></pre> <p>Return the absolute top module (the package) of this object.</p> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013          <p>The parent module.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Function.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Return the dotted path of this object.</p> <p>On regular objects (not aliases), the path is the canonical path.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>A dotted path.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Function.relative_filepath","title":"relative_filepath  <code>property</code>","text":"<pre><code>relative_filepath: Path\n</code></pre> <p>Return the file path where this object was defined, relative to the current working directory.</p> <p>If this object's file path is not relative to the current working directory, return its absolute path.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When the relative path could not be computed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code>         \u2013          <p>A file path.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Function.relative_package_filepath","title":"relative_package_filepath  <code>property</code>","text":"<pre><code>relative_package_filepath: Path\n</code></pre> <p>Return the file path where this object was defined, relative to the top module path.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When the relative path could not be computed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code>         \u2013          <p>A file path.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Function.source","title":"source  <code>property</code>","text":"<pre><code>source: str\n</code></pre> <p>Return the source code of this object.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The source code.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Function.__delitem__","title":"__delitem__","text":"<pre><code>__delitem__(key: str | Sequence[str]) -&gt; None\n</code></pre> <p>Delete a member with its name or path.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Members will be looked up in both declared members and inherited ones, triggering computation of the latter.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; del griffe_object[\"foo\"]\n&gt;&gt;&gt; del griffe_object[\"path.to.bar\"]\n&gt;&gt;&gt; del griffe_object[(\"path\", \"to\", \"qux\")]\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def __delitem__(self, key: str | Sequence[str]) -&gt; None:\n\"\"\"Delete a member with its name or path.\n\n    This method is part of the consumer API:\n    do not use when producing Griffe trees!\n\n    Members will be looked up in both declared members and inherited ones,\n    triggering computation of the latter.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; del griffe_object[\"foo\"]\n        &gt;&gt;&gt; del griffe_object[\"path.to.bar\"]\n        &gt;&gt;&gt; del griffe_object[(\"path\", \"to\", \"qux\")]\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        try:\n            del self.members[name]  # type: ignore[attr-defined]\n        except KeyError:\n            del self.inherited_members[name]  # type: ignore[attr-defined]\n    else:\n        del self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/#griffe.Function.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key: str | Sequence[str]) -&gt; Any\n</code></pre> <p>Get a member with its name or path.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Members will be looked up in both declared members and inherited ones, triggering computation of the latter.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; foo = griffe_object[\"foo\"]\n&gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n&gt;&gt;&gt; qux = griffe_object[(\"path\", \"to\", \"qux\")]\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def __getitem__(self, key: str | Sequence[str]) -&gt; Any:\n\"\"\"Get a member with its name or path.\n\n    This method is part of the consumer API:\n    do not use when producing Griffe trees!\n\n    Members will be looked up in both declared members and inherited ones,\n    triggering computation of the latter.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; foo = griffe_object[\"foo\"]\n        &gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n        &gt;&gt;&gt; qux = griffe_object[(\"path\", \"to\", \"qux\")]\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        return self.all_members[parts[0]]  # type: ignore[attr-defined]\n    return self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/#griffe.Function.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(\n    key: str | Sequence[str], value: Object | Alias\n) -&gt; None\n</code></pre> <p>Set a member with its name or path.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> <li> value             (<code>Object | Alias</code>)         \u2013          <p>The member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; griffe_object[\"foo\"] = foo\n&gt;&gt;&gt; griffe_object[\"path.to.bar\"] = bar\n&gt;&gt;&gt; griffe_object[(\"path\", \"to\", \"qux\")] = qux\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def __setitem__(self, key: str | Sequence[str], value: Object | Alias) -&gt; None:\n\"\"\"Set a member with its name or path.\n\n    This method is part of the consumer API:\n    do not use when producing Griffe trees!\n\n    Parameters:\n        key: The name or path of the member.\n        value: The member.\n\n    Examples:\n        &gt;&gt;&gt; griffe_object[\"foo\"] = foo\n        &gt;&gt;&gt; griffe_object[\"path.to.bar\"] = bar\n        &gt;&gt;&gt; griffe_object[(\"path\", \"to\", \"qux\")] = qux\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        self.members[name] = value  # type: ignore[attr-defined]\n        if self.is_collection:  # type: ignore[attr-defined]\n            value._modules_collection = self  # type: ignore[union-attr]\n        else:\n            value.parent = self  # type: ignore[assignment]\n    else:\n        self.members[parts[0]][parts[1:]] = value  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/#griffe.Function.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return this function's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return this function's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    base = super().as_dict(**kwargs)\n    base[\"decorators\"] = [dec.as_dict(**kwargs) for dec in self.decorators]\n    base[\"parameters\"] = [param.as_dict(**kwargs) for param in self.parameters]\n    base[\"returns\"] = self.returns\n    return base\n</code></pre>"},{"location":"reference/griffe/#griffe.Function.as_json","title":"as_json","text":"<pre><code>as_json(*, full: bool = False, **kwargs: Any) -&gt; str\n</code></pre> <p>Return this object's data as a JSON string.</p> <p>Parameters:</p> <ul> <li> full             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to return full info, or just base info.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options passed to encoder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>A JSON string.</p> </li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>def as_json(self, *, full: bool = False, **kwargs: Any) -&gt; str:\n\"\"\"Return this object's data as a JSON string.\n\n    Parameters:\n        full: Whether to return full info, or just base info.\n        **kwargs: Additional serialization options passed to encoder.\n\n    Returns:\n        A JSON string.\n    \"\"\"\n    from griffe.encoders import JSONEncoder  # avoid circular import\n\n    return json.dumps(self, cls=JSONEncoder, full=full, **kwargs)\n</code></pre>"},{"location":"reference/griffe/#griffe.Function.del_member","title":"del_member","text":"<pre><code>del_member(key: str | Sequence[str]) -&gt; None\n</code></pre> <p>Delete a member with its name or path.</p> <p>This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).</p> <p>Members will be looked up in declared members only, not inherited ones.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; griffe_object.del_member(\"foo\")\n&gt;&gt;&gt; griffe_object.del_member(\"path.to.bar\")\n&gt;&gt;&gt; griffe_object.del_member((\"path\", \"to\", \"qux\"))\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def del_member(self, key: str | Sequence[str]) -&gt; None:\n\"\"\"Delete a member with its name or path.\n\n    This method is part of the producer API:\n    you can use it safely while building Griffe trees\n    (for example in Griffe extensions).\n\n    Members will be looked up in declared members only, not inherited ones.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; griffe_object.del_member(\"foo\")\n        &gt;&gt;&gt; griffe_object.del_member(\"path.to.bar\")\n        &gt;&gt;&gt; griffe_object.del_member((\"path\", \"to\", \"qux\"))\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        del self.members[name]  # type: ignore[attr-defined]\n    else:\n        self.members[parts[0]].del_member(parts[1:])  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/#griffe.Function.filter_members","title":"filter_members","text":"<pre><code>filter_members(\n    *predicates: Callable[[Object | Alias], bool]\n) -&gt; dict[str, Object | Alias]\n</code></pre> <p>Filter and return members based on predicates.</p> <p>Parameters:</p> <ul> <li> *predicates             (<code>Callable[[Object | Alias], bool]</code>, default:                 <code>()</code> )         \u2013          <p>A list of predicates, i.e. callables accepting a member as argument and returning a boolean.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Object | Alias]</code>         \u2013          <p>A dictionary of members.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def filter_members(self, *predicates: Callable[[Object | Alias], bool]) -&gt; dict[str, Object | Alias]:\n\"\"\"Filter and return members based on predicates.\n\n    Parameters:\n        *predicates: A list of predicates, i.e. callables accepting a member as argument and returning a boolean.\n\n    Returns:\n        A dictionary of members.\n    \"\"\"\n    if not predicates:\n        return self.members\n    members: dict[str, Object | Alias] = {}\n    for name, member in self.members.items():\n        if all(predicate(member) for predicate in predicates):\n            members[name] = member\n    return members\n</code></pre>"},{"location":"reference/griffe/#griffe.Function.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_string: str, **kwargs: Any) -&gt; _ObjType\n</code></pre> <p>Create an instance of this class from a JSON string.</p> <p>Parameters:</p> <ul> <li> json_string             (<code>str</code>)         \u2013          <p>JSON to decode into Object.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional options passed to decoder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_ObjType</code>         \u2013          <p>An Object instance.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>           \u2013          <p>When the json_string does not represent and object of the class from which this classmethod has been called.</p> </li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>@classmethod\ndef from_json(cls: type[_ObjType], json_string: str, **kwargs: Any) -&gt; _ObjType:  # noqa: PYI019\n\"\"\"Create an instance of this class from a JSON string.\n\n    Parameters:\n        json_string: JSON to decode into Object.\n        **kwargs: Additional options passed to decoder.\n\n    Returns:\n        An Object instance.\n\n    Raises:\n        TypeError: When the json_string does not represent and object\n            of the class from which this classmethod has been called.\n    \"\"\"\n    from griffe.encoders import json_decoder  # avoid circular import\n\n    kwargs.setdefault(\"object_hook\", json_decoder)\n    obj = json.loads(json_string, **kwargs)\n    if not isinstance(obj, cls):\n        raise TypeError(f\"provided JSON object is not of type {cls}\")\n    return obj\n</code></pre>"},{"location":"reference/griffe/#griffe.Function.get_member","title":"get_member","text":"<pre><code>get_member(key: str | Sequence[str]) -&gt; Any\n</code></pre> <p>Get a member with its name or path.</p> <p>This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).</p> <p>Members will be looked up in declared members only, not inherited ones.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; foo = griffe_object[\"foo\"]\n&gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n&gt;&gt;&gt; bar = griffe_object[(\"path\", \"to\", \"bar\")]\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def get_member(self, key: str | Sequence[str]) -&gt; Any:\n\"\"\"Get a member with its name or path.\n\n    This method is part of the producer API:\n    you can use it safely while building Griffe trees\n    (for example in Griffe extensions).\n\n    Members will be looked up in declared members only, not inherited ones.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; foo = griffe_object[\"foo\"]\n        &gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n        &gt;&gt;&gt; bar = griffe_object[(\"path\", \"to\", \"bar\")]\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        return self.members[parts[0]]  # type: ignore[attr-defined]\n    return self.members[parts[0]].get_member(parts[1:])  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/#griffe.Function.has_labels","title":"has_labels","text":"<pre><code>has_labels(labels: set[str]) -&gt; bool\n</code></pre> <p>Tell if this object has all the given labels.</p> <p>Parameters:</p> <ul> <li> labels             (<code>set[str]</code>)         \u2013          <p>A set of labels.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def has_labels(self, labels: set[str]) -&gt; bool:\n\"\"\"Tell if this object has all the given labels.\n\n    Parameters:\n        labels: A set of labels.\n\n    Returns:\n        True or False.\n    \"\"\"\n    return all(label in self.labels for label in labels)\n</code></pre>"},{"location":"reference/griffe/#griffe.Function.is_exported","title":"is_exported","text":"<pre><code>is_exported(*, explicitely: bool = True) -&gt; bool\n</code></pre> <p>Tell if this object/alias is implicitely exported by its parent.</p> <p>Parameters:</p> <ul> <li> explicitely             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to only return True when <code>__all__</code> is defined.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>def is_exported(self, *, explicitely: bool = True) -&gt; bool:\n\"\"\"Tell if this object/alias is implicitely exported by its parent.\n\n    Parameters:\n        explicitely: Whether to only return True when `__all__` is defined.\n\n    Returns:\n        True or False.\n    \"\"\"\n    return self.parent.member_is_exported(self, explicitely=explicitely)  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/#griffe.Function.is_kind","title":"is_kind","text":"<pre><code>is_kind(kind: str | Kind | set[str | Kind]) -&gt; bool\n</code></pre> <p>Tell if this object is of the given kind.</p> <p>Parameters:</p> <ul> <li> kind             (<code>str | Kind | set[str | Kind]</code>)         \u2013          <p>An instance or set of kinds (strings or enumerations).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When an empty set is given as argument.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def is_kind(self, kind: str | Kind | set[str | Kind]) -&gt; bool:\n\"\"\"Tell if this object is of the given kind.\n\n    Parameters:\n        kind: An instance or set of kinds (strings or enumerations).\n\n    Raises:\n        ValueError: When an empty set is given as argument.\n\n    Returns:\n        True or False.\n    \"\"\"\n    if isinstance(kind, set):\n        if not kind:\n            raise ValueError(\"kind must not be an empty set\")\n        return self.kind in (knd if isinstance(knd, Kind) else Kind(knd) for knd in kind)\n    if isinstance(kind, str):\n        kind = Kind(kind)\n    return self.kind is kind\n</code></pre>"},{"location":"reference/griffe/#griffe.Function.is_public","title":"is_public","text":"<pre><code>is_public(\n    *, strict: bool = False, check_name: bool = True\n) -&gt; bool\n</code></pre> <p>Whether this object is considered public.</p> <p>In modules, developers can mark objects as public thanks to the <code>__all__</code> variable. In classes however, there is no convention or standard to do so.</p> <p>Therefore, to decide whether an object is public, we follow this algorithm:</p> <ul> <li>If the object's <code>public</code> attribute is set (boolean), return its value.</li> <li>In strict mode, the object is public only if it is explicitely exported (listed in <code>__all__</code>).     Strict mode should only be used for module members.</li> <li>Otherwise, if name checks are enabled, the object is private if its name starts with an underscore.</li> <li>Otherwise, if the object is an alias, and is neither inherited from a base class,     nor a member of a parent alias, it is not public.</li> <li>Otherwise, the object is public.</li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>def is_public(\n    self,\n    *,\n    strict: bool = False,\n    check_name: bool = True,\n) -&gt; bool:\n\"\"\"Whether this object is considered public.\n\n    In modules, developers can mark objects as public thanks to the `__all__` variable.\n    In classes however, there is no convention or standard to do so.\n\n    Therefore, to decide whether an object is public, we follow this algorithm:\n\n    - If the object's `public` attribute is set (boolean), return its value.\n    - In strict mode, the object is public only if it is explicitely exported (listed in `__all__`).\n        Strict mode should only be used for module members.\n    - Otherwise, if name checks are enabled, the object is private if its name starts with an underscore.\n    - Otherwise, if the object is an alias, and is neither inherited from a base class,\n        nor a member of a parent alias, it is not public.\n    - Otherwise, the object is public.\n    \"\"\"\n    if self.public is not None:  # type: ignore[attr-defined]\n        return self.public  # type: ignore[attr-defined]\n    if self.is_explicitely_exported:\n        return True\n    if strict:\n        return False\n    if check_name and self.name.startswith(\"_\"):  # type: ignore[attr-defined]\n        return False\n    if self.is_alias and not (self.inherited or self.parent.is_alias):  # type: ignore[attr-defined]\n        return False\n    return True\n</code></pre>"},{"location":"reference/griffe/#griffe.Function.member_is_exported","title":"member_is_exported","text":"<pre><code>member_is_exported(\n    member: Object | Alias, *, explicitely: bool = True\n) -&gt; bool\n</code></pre> <p>Tell if a member of this object is \"exported\".</p> <p>By exported, we mean that the object is included in the <code>__all__</code> attribute of its parent module or class. When <code>__all__</code> is not defined, we consider the member to be implicitely exported, unless it's a module and it was not imported, and unless it's not defined at runtime.</p> <p>Parameters:</p> <ul> <li> member             (<code>Object | Alias</code>)         \u2013          <p>The member to verify.</p> </li> <li> explicitely             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to only return True when <code>__all__</code> is defined.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def member_is_exported(self, member: Object | Alias, *, explicitely: bool = True) -&gt; bool:\n\"\"\"Tell if a member of this object is \"exported\".\n\n    By exported, we mean that the object is included in the `__all__` attribute\n    of its parent module or class. When `__all__` is not defined,\n    we consider the member to be *implicitely* exported,\n    unless it's a module and it was not imported,\n    and unless it's not defined at runtime.\n\n    Parameters:\n        member: The member to verify.\n        explicitely: Whether to only return True when `__all__` is defined.\n\n    Returns:\n        True or False.\n    \"\"\"\n    if not member.runtime:\n        return False\n    if self.exports is None:\n        return not explicitely and (member.is_alias or not member.is_module or member.name in self.imports)\n    return member.name in self.exports\n</code></pre>"},{"location":"reference/griffe/#griffe.Function.resolve","title":"resolve","text":"<pre><code>resolve(name: str) -&gt; str\n</code></pre> <p>Resolve a name within this object's and parents' scope.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013          <p>The name to resolve.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NameResolutionError</code>           \u2013          <p>When the name could not be resolved.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The resolved name.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def resolve(self, name: str) -&gt; str:\n\"\"\"Resolve a name within this object's and parents' scope.\n\n    Parameters:\n        name: The name to resolve.\n\n    Raises:\n        NameResolutionError: When the name could not be resolved.\n\n    Returns:\n        The resolved name.\n    \"\"\"\n    if name in self.members:\n        if self.members[name].is_alias:\n            return self.members[name].target_path  # type: ignore[union-attr]\n        return self.members[name].path\n    if name in self.imports:\n        return self.imports[name]\n    if self.parent is None:\n        # could be a built-in\n        raise NameResolutionError(f\"{name} could not be resolved in the scope of {self.path}\")\n    if name == self.parent.name and not self.parent.is_module:\n        return self.parent.path\n    return self.parent.resolve(name)\n</code></pre>"},{"location":"reference/griffe/#griffe.Function.set_member","title":"set_member","text":"<pre><code>set_member(\n    key: str | Sequence[str], value: Object | Alias\n) -&gt; None\n</code></pre> <p>Set a member with its name or path.</p> <p>This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> <li> value             (<code>Object | Alias</code>)         \u2013          <p>The member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; griffe_object.set_member(\"foo\", foo)\n&gt;&gt;&gt; griffe_object.set_member(\"path.to.bar\", bar)\n&gt;&gt;&gt; griffe_object.set_member((\"path\", \"to\", \"qux\", qux)\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def set_member(self, key: str | Sequence[str], value: Object | Alias) -&gt; None:\n\"\"\"Set a member with its name or path.\n\n    This method is part of the producer API:\n    you can use it safely while building Griffe trees\n    (for example in Griffe extensions).\n\n    Parameters:\n        key: The name or path of the member.\n        value: The member.\n\n    Examples:\n        &gt;&gt;&gt; griffe_object.set_member(\"foo\", foo)\n        &gt;&gt;&gt; griffe_object.set_member(\"path.to.bar\", bar)\n        &gt;&gt;&gt; griffe_object.set_member((\"path\", \"to\", \"qux\", qux)\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        if name in self.members:  # type: ignore[attr-defined]\n            member = self.members[name]  # type: ignore[attr-defined]\n            if not member.is_alias:\n                # when reassigning a module to an existing one,\n                # try to merge them as one regular and one stubs module\n                # (implicit support for .pyi modules)\n                if member.is_module and not (member.is_namespace_package or member.is_namespace_subpackage):\n                    with suppress(AliasResolutionError, CyclicAliasError):\n                        if value.is_module and value.filepath != member.filepath:\n                            with suppress(ValueError):\n                                value = merge_stubs(member, value)  # type: ignore[arg-type]\n                for alias in member.aliases.values():\n                    with suppress(CyclicAliasError):\n                        alias.target = value\n        self.members[name] = value  # type: ignore[attr-defined]\n        if self.is_collection:  # type: ignore[attr-defined]\n            value._modules_collection = self  # type: ignore[union-attr]\n        else:\n            value.parent = self  # type: ignore[assignment]\n    else:\n        self.members[parts[0]].set_member(parts[1:], value)  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/#griffe.Module","title":"Module","text":"<pre><code>Module(\n    *args: Any,\n    filepath: Path | list[Path] | None = None,\n    **kwargs: Any\n)\n</code></pre> <p>             Bases: <code>Object</code></p> <p>The class representing a Python module.</p> <p>Parameters:</p> <ul> <li> *args             (<code>Any</code>, default:                 <code>()</code> )         \u2013          <p>See <code>griffe.dataclasses.Object</code>.</p> </li> <li> filepath             (<code>Path | list[Path] | None</code>, default:                 <code>None</code> )         \u2013          <p>The module file path (directory for namespace [sub]packages, none for builtin modules).</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>See <code>griffe.dataclasses.Object</code>.</p> </li> </ul> <p>Methods:</p> <ul> <li> __delitem__           \u2013            <p>Delete a member with its name or path.</p> </li> <li> __getitem__           \u2013            <p>Get a member with its name or path.</p> </li> <li> __setitem__           \u2013            <p>Set a member with its name or path.</p> </li> <li> as_dict           \u2013            <p>Return this module's data as a dictionary.</p> </li> <li> as_json           \u2013            <p>Return this object's data as a JSON string.</p> </li> <li> del_member           \u2013            <p>Delete a member with its name or path.</p> </li> <li> filter_members           \u2013            <p>Filter and return members based on predicates.</p> </li> <li> from_json           \u2013            <p>Create an instance of this class from a JSON string.</p> </li> <li> get_member           \u2013            <p>Get a member with its name or path.</p> </li> <li> has_labels           \u2013            <p>Tell if this object has all the given labels.</p> </li> <li> is_exported           \u2013            <p>Tell if this object/alias is implicitely exported by its parent.</p> </li> <li> is_kind           \u2013            <p>Tell if this object is of the given kind.</p> </li> <li> is_public           \u2013            <p>Whether this object is considered public.</p> </li> <li> member_is_exported           \u2013            <p>Tell if a member of this object is \"exported\".</p> </li> <li> resolve           \u2013            <p>Resolve a name within this object's and parents' scope.</p> </li> <li> set_member           \u2013            <p>Set a member with its name or path.</p> </li> </ul> <p>Attributes:</p> <ul> <li> all_members             (<code>dict[str, Object | Alias]</code>)         \u2013          <p>All members (declared and inherited).</p> </li> <li> attributes             (<code>dict[str, Attribute]</code>)         \u2013          <p>Return the attribute members.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Return the full dotted path of this object.</p> </li> <li> classes             (<code>dict[str, Class]</code>)         \u2013          <p>Return the class members.</p> </li> <li> filepath             (<code>Path | list[Path]</code>)         \u2013          <p>Get the file path of this module.</p> </li> <li> functions             (<code>dict[str, Function]</code>)         \u2013          <p>Return the function members.</p> </li> <li> has_docstring             (<code>bool</code>)         \u2013          <p>Tell if this object has a non-empty docstring.</p> </li> <li> has_docstrings             (<code>bool</code>)         \u2013          <p>Tell if this object or any of its members has a non-empty docstring.</p> </li> <li> imports_future_annotations             (<code>bool</code>)         \u2013          <p>Tell whether this module import future annotations.</p> </li> <li> inherited_members             (<code>dict[str, Alias]</code>)         \u2013          <p>Members that are inherited from base classes.</p> </li> <li> is_attribute             (<code>bool</code>)         \u2013          <p>Tell if this object is an attribute.</p> </li> <li> is_class             (<code>bool</code>)         \u2013          <p>Tell if this object is a class.</p> </li> <li> is_explicitely_exported             (<code>bool</code>)         \u2013          <p>Tell if this object/alias is explicitely exported by its parent.</p> </li> <li> is_function             (<code>bool</code>)         \u2013          <p>Tell if this object is a function.</p> </li> <li> is_implicitely_exported             (<code>bool</code>)         \u2013          <p>Tell if this object/alias is implicitely exported by its parent.</p> </li> <li> is_init_module             (<code>bool</code>)         \u2013          <p>Tell if this module is an <code>__init__.py</code> module.</p> </li> <li> is_module             (<code>bool</code>)         \u2013          <p>Tell if this object is a module.</p> </li> <li> is_namespace_package             (<code>bool</code>)         \u2013          <p>Tell if this module is a namespace package (top folder, no <code>__init__.py</code>).</p> </li> <li> is_namespace_subpackage             (<code>bool</code>)         \u2013          <p>Tell if this module is a namespace subpackage.</p> </li> <li> is_package             (<code>bool</code>)         \u2013          <p>Tell if this module is a package (top module).</p> </li> <li> is_subpackage             (<code>bool</code>)         \u2013          <p>Tell if this module is a subpackage.</p> </li> <li> lines             (<code>list[str]</code>)         \u2013          <p>Return the lines containing the source of this object.</p> </li> <li> lines_collection             (<code>LinesCollection</code>)         \u2013          <p>Return the lines collection attached to this object or its parents.</p> </li> <li> module             (<code>Module</code>)         \u2013          <p>Return the parent module of this object.</p> </li> <li> modules             (<code>dict[str, Module]</code>)         \u2013          <p>Return the module members.</p> </li> <li> modules_collection             (<code>ModulesCollection</code>)         \u2013          <p>Return the modules collection attached to this object or its parents.</p> </li> <li> package             (<code>Module</code>)         \u2013          <p>Return the absolute top module (the package) of this object.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Return the dotted path of this object.</p> </li> <li> relative_filepath             (<code>Path</code>)         \u2013          <p>Return the file path where this object was defined, relative to the current working directory.</p> </li> <li> relative_package_filepath             (<code>Path</code>)         \u2013          <p>Return the file path where this object was defined, relative to the top module path.</p> </li> <li> source             (<code>str</code>)         \u2013          <p>Return the source code of this object.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def __init__(self, *args: Any, filepath: Path | list[Path] | None = None, **kwargs: Any) -&gt; None:\n\"\"\"Initialize the module.\n\n    Parameters:\n        *args: See [`griffe.dataclasses.Object`][].\n        filepath: The module file path (directory for namespace [sub]packages, none for builtin modules).\n        **kwargs: See [`griffe.dataclasses.Object`][].\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self._filepath: Path | list[Path] | None = filepath\n    self.overloads: dict[str, list[Function]] = defaultdict(list)\n</code></pre>"},{"location":"reference/griffe/#griffe.Module.all_members","title":"all_members  <code>property</code>","text":"<pre><code>all_members: dict[str, Object | Alias]\n</code></pre> <p>All members (declared and inherited).</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p>"},{"location":"reference/griffe/#griffe.Module.attributes","title":"attributes  <code>property</code>","text":"<pre><code>attributes: dict[str, Attribute]\n</code></pre> <p>Return the attribute members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Attribute]</code>         \u2013          <p>A dictionary of attributes.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Module.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Return the full dotted path of this object.</p> <p>The canonical path is the path where the object was defined (not imported).</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>A dotted path.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Module.classes","title":"classes  <code>property</code>","text":"<pre><code>classes: dict[str, Class]\n</code></pre> <p>Return the class members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Class]</code>         \u2013          <p>A dictionary of classes.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Module.filepath","title":"filepath  <code>property</code>","text":"<pre><code>filepath: Path | list[Path]\n</code></pre> <p>Get the file path of this module.</p> <p>Raises:</p> <ul> <li> <code>BuiltinModuleError</code>           \u2013          <p>When the instance filepath is None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path | list[Path]</code>         \u2013          <p>The module's file path.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Module.functions","title":"functions  <code>property</code>","text":"<pre><code>functions: dict[str, Function]\n</code></pre> <p>Return the function members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Function]</code>         \u2013          <p>A dictionary of functions.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Module.has_docstring","title":"has_docstring  <code>property</code>","text":"<pre><code>has_docstring: bool\n</code></pre> <p>Tell if this object has a non-empty docstring.</p>"},{"location":"reference/griffe/#griffe.Module.has_docstrings","title":"has_docstrings  <code>property</code>","text":"<pre><code>has_docstrings: bool\n</code></pre> <p>Tell if this object or any of its members has a non-empty docstring.</p>"},{"location":"reference/griffe/#griffe.Module.imports_future_annotations","title":"imports_future_annotations  <code>property</code>","text":"<pre><code>imports_future_annotations: bool\n</code></pre> <p>Tell whether this module import future annotations.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or false.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Module.inherited_members","title":"inherited_members  <code>cached</code> <code>property</code>","text":"<pre><code>inherited_members: dict[str, Alias]\n</code></pre> <p>Members that are inherited from base classes.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p>"},{"location":"reference/griffe/#griffe.Module.is_attribute","title":"is_attribute  <code>property</code>","text":"<pre><code>is_attribute: bool\n</code></pre> <p>Tell if this object is an attribute.</p>"},{"location":"reference/griffe/#griffe.Module.is_class","title":"is_class  <code>property</code>","text":"<pre><code>is_class: bool\n</code></pre> <p>Tell if this object is a class.</p>"},{"location":"reference/griffe/#griffe.Module.is_explicitely_exported","title":"is_explicitely_exported  <code>property</code>","text":"<pre><code>is_explicitely_exported: bool\n</code></pre> <p>Tell if this object/alias is explicitely exported by its parent.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Module.is_function","title":"is_function  <code>property</code>","text":"<pre><code>is_function: bool\n</code></pre> <p>Tell if this object is a function.</p>"},{"location":"reference/griffe/#griffe.Module.is_implicitely_exported","title":"is_implicitely_exported  <code>property</code>","text":"<pre><code>is_implicitely_exported: bool\n</code></pre> <p>Tell if this object/alias is implicitely exported by its parent.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Module.is_init_module","title":"is_init_module  <code>property</code>","text":"<pre><code>is_init_module: bool\n</code></pre> <p>Tell if this module is an <code>__init__.py</code> module.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Module.is_module","title":"is_module  <code>property</code>","text":"<pre><code>is_module: bool\n</code></pre> <p>Tell if this object is a module.</p>"},{"location":"reference/griffe/#griffe.Module.is_namespace_package","title":"is_namespace_package  <code>property</code>","text":"<pre><code>is_namespace_package: bool\n</code></pre> <p>Tell if this module is a namespace package (top folder, no <code>__init__.py</code>).</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Module.is_namespace_subpackage","title":"is_namespace_subpackage  <code>property</code>","text":"<pre><code>is_namespace_subpackage: bool\n</code></pre> <p>Tell if this module is a namespace subpackage.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Module.is_package","title":"is_package  <code>property</code>","text":"<pre><code>is_package: bool\n</code></pre> <p>Tell if this module is a package (top module).</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Module.is_subpackage","title":"is_subpackage  <code>property</code>","text":"<pre><code>is_subpackage: bool\n</code></pre> <p>Tell if this module is a subpackage.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Module.lines","title":"lines  <code>property</code>","text":"<pre><code>lines: list[str]\n</code></pre> <p>Return the lines containing the source of this object.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>         \u2013          <p>A list of lines.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Module.lines_collection","title":"lines_collection  <code>property</code>","text":"<pre><code>lines_collection: LinesCollection\n</code></pre> <p>Return the lines collection attached to this object or its parents.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When no modules collection can be found in the object or its parents.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>LinesCollection</code>         \u2013          <p>A lines collection.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Module.module","title":"module  <code>property</code>","text":"<pre><code>module: Module\n</code></pre> <p>Return the parent module of this object.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When the object is not a module and does not have a parent.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013          <p>The parent module.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Module.modules","title":"modules  <code>property</code>","text":"<pre><code>modules: dict[str, Module]\n</code></pre> <p>Return the module members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Module]</code>         \u2013          <p>A dictionary of modules.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Module.modules_collection","title":"modules_collection  <code>property</code>","text":"<pre><code>modules_collection: ModulesCollection\n</code></pre> <p>Return the modules collection attached to this object or its parents.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When no modules collection can be found in the object or its parents.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ModulesCollection</code>         \u2013          <p>A modules collection.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Module.package","title":"package  <code>property</code>","text":"<pre><code>package: Module\n</code></pre> <p>Return the absolute top module (the package) of this object.</p> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013          <p>The parent module.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Module.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Return the dotted path of this object.</p> <p>On regular objects (not aliases), the path is the canonical path.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>A dotted path.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Module.relative_filepath","title":"relative_filepath  <code>property</code>","text":"<pre><code>relative_filepath: Path\n</code></pre> <p>Return the file path where this object was defined, relative to the current working directory.</p> <p>If this object's file path is not relative to the current working directory, return its absolute path.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When the relative path could not be computed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code>         \u2013          <p>A file path.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Module.relative_package_filepath","title":"relative_package_filepath  <code>property</code>","text":"<pre><code>relative_package_filepath: Path\n</code></pre> <p>Return the file path where this object was defined, relative to the top module path.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When the relative path could not be computed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code>         \u2013          <p>A file path.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Module.source","title":"source  <code>property</code>","text":"<pre><code>source: str\n</code></pre> <p>Return the source code of this object.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The source code.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Module.__delitem__","title":"__delitem__","text":"<pre><code>__delitem__(key: str | Sequence[str]) -&gt; None\n</code></pre> <p>Delete a member with its name or path.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Members will be looked up in both declared members and inherited ones, triggering computation of the latter.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; del griffe_object[\"foo\"]\n&gt;&gt;&gt; del griffe_object[\"path.to.bar\"]\n&gt;&gt;&gt; del griffe_object[(\"path\", \"to\", \"qux\")]\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def __delitem__(self, key: str | Sequence[str]) -&gt; None:\n\"\"\"Delete a member with its name or path.\n\n    This method is part of the consumer API:\n    do not use when producing Griffe trees!\n\n    Members will be looked up in both declared members and inherited ones,\n    triggering computation of the latter.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; del griffe_object[\"foo\"]\n        &gt;&gt;&gt; del griffe_object[\"path.to.bar\"]\n        &gt;&gt;&gt; del griffe_object[(\"path\", \"to\", \"qux\")]\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        try:\n            del self.members[name]  # type: ignore[attr-defined]\n        except KeyError:\n            del self.inherited_members[name]  # type: ignore[attr-defined]\n    else:\n        del self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/#griffe.Module.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key: str | Sequence[str]) -&gt; Any\n</code></pre> <p>Get a member with its name or path.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Members will be looked up in both declared members and inherited ones, triggering computation of the latter.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; foo = griffe_object[\"foo\"]\n&gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n&gt;&gt;&gt; qux = griffe_object[(\"path\", \"to\", \"qux\")]\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def __getitem__(self, key: str | Sequence[str]) -&gt; Any:\n\"\"\"Get a member with its name or path.\n\n    This method is part of the consumer API:\n    do not use when producing Griffe trees!\n\n    Members will be looked up in both declared members and inherited ones,\n    triggering computation of the latter.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; foo = griffe_object[\"foo\"]\n        &gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n        &gt;&gt;&gt; qux = griffe_object[(\"path\", \"to\", \"qux\")]\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        return self.all_members[parts[0]]  # type: ignore[attr-defined]\n    return self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/#griffe.Module.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(\n    key: str | Sequence[str], value: Object | Alias\n) -&gt; None\n</code></pre> <p>Set a member with its name or path.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> <li> value             (<code>Object | Alias</code>)         \u2013          <p>The member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; griffe_object[\"foo\"] = foo\n&gt;&gt;&gt; griffe_object[\"path.to.bar\"] = bar\n&gt;&gt;&gt; griffe_object[(\"path\", \"to\", \"qux\")] = qux\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def __setitem__(self, key: str | Sequence[str], value: Object | Alias) -&gt; None:\n\"\"\"Set a member with its name or path.\n\n    This method is part of the consumer API:\n    do not use when producing Griffe trees!\n\n    Parameters:\n        key: The name or path of the member.\n        value: The member.\n\n    Examples:\n        &gt;&gt;&gt; griffe_object[\"foo\"] = foo\n        &gt;&gt;&gt; griffe_object[\"path.to.bar\"] = bar\n        &gt;&gt;&gt; griffe_object[(\"path\", \"to\", \"qux\")] = qux\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        self.members[name] = value  # type: ignore[attr-defined]\n        if self.is_collection:  # type: ignore[attr-defined]\n            value._modules_collection = self  # type: ignore[union-attr]\n        else:\n            value.parent = self  # type: ignore[assignment]\n    else:\n        self.members[parts[0]][parts[1:]] = value  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/#griffe.Module.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return this module's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return this module's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    base = super().as_dict(**kwargs)\n    base[\"filepath\"] = str(self._filepath) if self._filepath else None\n    return base\n</code></pre>"},{"location":"reference/griffe/#griffe.Module.as_json","title":"as_json","text":"<pre><code>as_json(*, full: bool = False, **kwargs: Any) -&gt; str\n</code></pre> <p>Return this object's data as a JSON string.</p> <p>Parameters:</p> <ul> <li> full             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to return full info, or just base info.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options passed to encoder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>A JSON string.</p> </li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>def as_json(self, *, full: bool = False, **kwargs: Any) -&gt; str:\n\"\"\"Return this object's data as a JSON string.\n\n    Parameters:\n        full: Whether to return full info, or just base info.\n        **kwargs: Additional serialization options passed to encoder.\n\n    Returns:\n        A JSON string.\n    \"\"\"\n    from griffe.encoders import JSONEncoder  # avoid circular import\n\n    return json.dumps(self, cls=JSONEncoder, full=full, **kwargs)\n</code></pre>"},{"location":"reference/griffe/#griffe.Module.del_member","title":"del_member","text":"<pre><code>del_member(key: str | Sequence[str]) -&gt; None\n</code></pre> <p>Delete a member with its name or path.</p> <p>This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).</p> <p>Members will be looked up in declared members only, not inherited ones.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; griffe_object.del_member(\"foo\")\n&gt;&gt;&gt; griffe_object.del_member(\"path.to.bar\")\n&gt;&gt;&gt; griffe_object.del_member((\"path\", \"to\", \"qux\"))\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def del_member(self, key: str | Sequence[str]) -&gt; None:\n\"\"\"Delete a member with its name or path.\n\n    This method is part of the producer API:\n    you can use it safely while building Griffe trees\n    (for example in Griffe extensions).\n\n    Members will be looked up in declared members only, not inherited ones.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; griffe_object.del_member(\"foo\")\n        &gt;&gt;&gt; griffe_object.del_member(\"path.to.bar\")\n        &gt;&gt;&gt; griffe_object.del_member((\"path\", \"to\", \"qux\"))\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        del self.members[name]  # type: ignore[attr-defined]\n    else:\n        self.members[parts[0]].del_member(parts[1:])  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/#griffe.Module.filter_members","title":"filter_members","text":"<pre><code>filter_members(\n    *predicates: Callable[[Object | Alias], bool]\n) -&gt; dict[str, Object | Alias]\n</code></pre> <p>Filter and return members based on predicates.</p> <p>Parameters:</p> <ul> <li> *predicates             (<code>Callable[[Object | Alias], bool]</code>, default:                 <code>()</code> )         \u2013          <p>A list of predicates, i.e. callables accepting a member as argument and returning a boolean.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Object | Alias]</code>         \u2013          <p>A dictionary of members.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def filter_members(self, *predicates: Callable[[Object | Alias], bool]) -&gt; dict[str, Object | Alias]:\n\"\"\"Filter and return members based on predicates.\n\n    Parameters:\n        *predicates: A list of predicates, i.e. callables accepting a member as argument and returning a boolean.\n\n    Returns:\n        A dictionary of members.\n    \"\"\"\n    if not predicates:\n        return self.members\n    members: dict[str, Object | Alias] = {}\n    for name, member in self.members.items():\n        if all(predicate(member) for predicate in predicates):\n            members[name] = member\n    return members\n</code></pre>"},{"location":"reference/griffe/#griffe.Module.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_string: str, **kwargs: Any) -&gt; _ObjType\n</code></pre> <p>Create an instance of this class from a JSON string.</p> <p>Parameters:</p> <ul> <li> json_string             (<code>str</code>)         \u2013          <p>JSON to decode into Object.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional options passed to decoder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_ObjType</code>         \u2013          <p>An Object instance.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>           \u2013          <p>When the json_string does not represent and object of the class from which this classmethod has been called.</p> </li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>@classmethod\ndef from_json(cls: type[_ObjType], json_string: str, **kwargs: Any) -&gt; _ObjType:  # noqa: PYI019\n\"\"\"Create an instance of this class from a JSON string.\n\n    Parameters:\n        json_string: JSON to decode into Object.\n        **kwargs: Additional options passed to decoder.\n\n    Returns:\n        An Object instance.\n\n    Raises:\n        TypeError: When the json_string does not represent and object\n            of the class from which this classmethod has been called.\n    \"\"\"\n    from griffe.encoders import json_decoder  # avoid circular import\n\n    kwargs.setdefault(\"object_hook\", json_decoder)\n    obj = json.loads(json_string, **kwargs)\n    if not isinstance(obj, cls):\n        raise TypeError(f\"provided JSON object is not of type {cls}\")\n    return obj\n</code></pre>"},{"location":"reference/griffe/#griffe.Module.get_member","title":"get_member","text":"<pre><code>get_member(key: str | Sequence[str]) -&gt; Any\n</code></pre> <p>Get a member with its name or path.</p> <p>This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).</p> <p>Members will be looked up in declared members only, not inherited ones.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; foo = griffe_object[\"foo\"]\n&gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n&gt;&gt;&gt; bar = griffe_object[(\"path\", \"to\", \"bar\")]\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def get_member(self, key: str | Sequence[str]) -&gt; Any:\n\"\"\"Get a member with its name or path.\n\n    This method is part of the producer API:\n    you can use it safely while building Griffe trees\n    (for example in Griffe extensions).\n\n    Members will be looked up in declared members only, not inherited ones.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; foo = griffe_object[\"foo\"]\n        &gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n        &gt;&gt;&gt; bar = griffe_object[(\"path\", \"to\", \"bar\")]\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        return self.members[parts[0]]  # type: ignore[attr-defined]\n    return self.members[parts[0]].get_member(parts[1:])  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/#griffe.Module.has_labels","title":"has_labels","text":"<pre><code>has_labels(labels: set[str]) -&gt; bool\n</code></pre> <p>Tell if this object has all the given labels.</p> <p>Parameters:</p> <ul> <li> labels             (<code>set[str]</code>)         \u2013          <p>A set of labels.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def has_labels(self, labels: set[str]) -&gt; bool:\n\"\"\"Tell if this object has all the given labels.\n\n    Parameters:\n        labels: A set of labels.\n\n    Returns:\n        True or False.\n    \"\"\"\n    return all(label in self.labels for label in labels)\n</code></pre>"},{"location":"reference/griffe/#griffe.Module.is_exported","title":"is_exported","text":"<pre><code>is_exported(*, explicitely: bool = True) -&gt; bool\n</code></pre> <p>Tell if this object/alias is implicitely exported by its parent.</p> <p>Parameters:</p> <ul> <li> explicitely             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to only return True when <code>__all__</code> is defined.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>def is_exported(self, *, explicitely: bool = True) -&gt; bool:\n\"\"\"Tell if this object/alias is implicitely exported by its parent.\n\n    Parameters:\n        explicitely: Whether to only return True when `__all__` is defined.\n\n    Returns:\n        True or False.\n    \"\"\"\n    return self.parent.member_is_exported(self, explicitely=explicitely)  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/#griffe.Module.is_kind","title":"is_kind","text":"<pre><code>is_kind(kind: str | Kind | set[str | Kind]) -&gt; bool\n</code></pre> <p>Tell if this object is of the given kind.</p> <p>Parameters:</p> <ul> <li> kind             (<code>str | Kind | set[str | Kind]</code>)         \u2013          <p>An instance or set of kinds (strings or enumerations).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When an empty set is given as argument.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def is_kind(self, kind: str | Kind | set[str | Kind]) -&gt; bool:\n\"\"\"Tell if this object is of the given kind.\n\n    Parameters:\n        kind: An instance or set of kinds (strings or enumerations).\n\n    Raises:\n        ValueError: When an empty set is given as argument.\n\n    Returns:\n        True or False.\n    \"\"\"\n    if isinstance(kind, set):\n        if not kind:\n            raise ValueError(\"kind must not be an empty set\")\n        return self.kind in (knd if isinstance(knd, Kind) else Kind(knd) for knd in kind)\n    if isinstance(kind, str):\n        kind = Kind(kind)\n    return self.kind is kind\n</code></pre>"},{"location":"reference/griffe/#griffe.Module.is_public","title":"is_public","text":"<pre><code>is_public(\n    *, strict: bool = False, check_name: bool = True\n) -&gt; bool\n</code></pre> <p>Whether this object is considered public.</p> <p>In modules, developers can mark objects as public thanks to the <code>__all__</code> variable. In classes however, there is no convention or standard to do so.</p> <p>Therefore, to decide whether an object is public, we follow this algorithm:</p> <ul> <li>If the object's <code>public</code> attribute is set (boolean), return its value.</li> <li>In strict mode, the object is public only if it is explicitely exported (listed in <code>__all__</code>).     Strict mode should only be used for module members.</li> <li>Otherwise, if name checks are enabled, the object is private if its name starts with an underscore.</li> <li>Otherwise, if the object is an alias, and is neither inherited from a base class,     nor a member of a parent alias, it is not public.</li> <li>Otherwise, the object is public.</li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>def is_public(\n    self,\n    *,\n    strict: bool = False,\n    check_name: bool = True,\n) -&gt; bool:\n\"\"\"Whether this object is considered public.\n\n    In modules, developers can mark objects as public thanks to the `__all__` variable.\n    In classes however, there is no convention or standard to do so.\n\n    Therefore, to decide whether an object is public, we follow this algorithm:\n\n    - If the object's `public` attribute is set (boolean), return its value.\n    - In strict mode, the object is public only if it is explicitely exported (listed in `__all__`).\n        Strict mode should only be used for module members.\n    - Otherwise, if name checks are enabled, the object is private if its name starts with an underscore.\n    - Otherwise, if the object is an alias, and is neither inherited from a base class,\n        nor a member of a parent alias, it is not public.\n    - Otherwise, the object is public.\n    \"\"\"\n    if self.public is not None:  # type: ignore[attr-defined]\n        return self.public  # type: ignore[attr-defined]\n    if self.is_explicitely_exported:\n        return True\n    if strict:\n        return False\n    if check_name and self.name.startswith(\"_\"):  # type: ignore[attr-defined]\n        return False\n    if self.is_alias and not (self.inherited or self.parent.is_alias):  # type: ignore[attr-defined]\n        return False\n    return True\n</code></pre>"},{"location":"reference/griffe/#griffe.Module.member_is_exported","title":"member_is_exported","text":"<pre><code>member_is_exported(\n    member: Object | Alias, *, explicitely: bool = True\n) -&gt; bool\n</code></pre> <p>Tell if a member of this object is \"exported\".</p> <p>By exported, we mean that the object is included in the <code>__all__</code> attribute of its parent module or class. When <code>__all__</code> is not defined, we consider the member to be implicitely exported, unless it's a module and it was not imported, and unless it's not defined at runtime.</p> <p>Parameters:</p> <ul> <li> member             (<code>Object | Alias</code>)         \u2013          <p>The member to verify.</p> </li> <li> explicitely             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to only return True when <code>__all__</code> is defined.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def member_is_exported(self, member: Object | Alias, *, explicitely: bool = True) -&gt; bool:\n\"\"\"Tell if a member of this object is \"exported\".\n\n    By exported, we mean that the object is included in the `__all__` attribute\n    of its parent module or class. When `__all__` is not defined,\n    we consider the member to be *implicitely* exported,\n    unless it's a module and it was not imported,\n    and unless it's not defined at runtime.\n\n    Parameters:\n        member: The member to verify.\n        explicitely: Whether to only return True when `__all__` is defined.\n\n    Returns:\n        True or False.\n    \"\"\"\n    if not member.runtime:\n        return False\n    if self.exports is None:\n        return not explicitely and (member.is_alias or not member.is_module or member.name in self.imports)\n    return member.name in self.exports\n</code></pre>"},{"location":"reference/griffe/#griffe.Module.resolve","title":"resolve","text":"<pre><code>resolve(name: str) -&gt; str\n</code></pre> <p>Resolve a name within this object's and parents' scope.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013          <p>The name to resolve.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NameResolutionError</code>           \u2013          <p>When the name could not be resolved.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The resolved name.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def resolve(self, name: str) -&gt; str:\n\"\"\"Resolve a name within this object's and parents' scope.\n\n    Parameters:\n        name: The name to resolve.\n\n    Raises:\n        NameResolutionError: When the name could not be resolved.\n\n    Returns:\n        The resolved name.\n    \"\"\"\n    if name in self.members:\n        if self.members[name].is_alias:\n            return self.members[name].target_path  # type: ignore[union-attr]\n        return self.members[name].path\n    if name in self.imports:\n        return self.imports[name]\n    if self.parent is None:\n        # could be a built-in\n        raise NameResolutionError(f\"{name} could not be resolved in the scope of {self.path}\")\n    if name == self.parent.name and not self.parent.is_module:\n        return self.parent.path\n    return self.parent.resolve(name)\n</code></pre>"},{"location":"reference/griffe/#griffe.Module.set_member","title":"set_member","text":"<pre><code>set_member(\n    key: str | Sequence[str], value: Object | Alias\n) -&gt; None\n</code></pre> <p>Set a member with its name or path.</p> <p>This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> <li> value             (<code>Object | Alias</code>)         \u2013          <p>The member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; griffe_object.set_member(\"foo\", foo)\n&gt;&gt;&gt; griffe_object.set_member(\"path.to.bar\", bar)\n&gt;&gt;&gt; griffe_object.set_member((\"path\", \"to\", \"qux\", qux)\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def set_member(self, key: str | Sequence[str], value: Object | Alias) -&gt; None:\n\"\"\"Set a member with its name or path.\n\n    This method is part of the producer API:\n    you can use it safely while building Griffe trees\n    (for example in Griffe extensions).\n\n    Parameters:\n        key: The name or path of the member.\n        value: The member.\n\n    Examples:\n        &gt;&gt;&gt; griffe_object.set_member(\"foo\", foo)\n        &gt;&gt;&gt; griffe_object.set_member(\"path.to.bar\", bar)\n        &gt;&gt;&gt; griffe_object.set_member((\"path\", \"to\", \"qux\", qux)\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        if name in self.members:  # type: ignore[attr-defined]\n            member = self.members[name]  # type: ignore[attr-defined]\n            if not member.is_alias:\n                # when reassigning a module to an existing one,\n                # try to merge them as one regular and one stubs module\n                # (implicit support for .pyi modules)\n                if member.is_module and not (member.is_namespace_package or member.is_namespace_subpackage):\n                    with suppress(AliasResolutionError, CyclicAliasError):\n                        if value.is_module and value.filepath != member.filepath:\n                            with suppress(ValueError):\n                                value = merge_stubs(member, value)  # type: ignore[arg-type]\n                for alias in member.aliases.values():\n                    with suppress(CyclicAliasError):\n                        alias.target = value\n        self.members[name] = value  # type: ignore[attr-defined]\n        if self.is_collection:  # type: ignore[attr-defined]\n            value._modules_collection = self  # type: ignore[union-attr]\n        else:\n            value.parent = self  # type: ignore[assignment]\n    else:\n        self.members[parts[0]].set_member(parts[1:], value)  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/#griffe.Object","title":"Object","text":"<pre><code>Object(\n    name: str,\n    *,\n    lineno: int | None = None,\n    endlineno: int | None = None,\n    runtime: bool = True,\n    docstring: Docstring | None = None,\n    parent: Module | Class | None = None,\n    lines_collection: LinesCollection | None = None,\n    modules_collection: ModulesCollection | None = None\n)\n</code></pre> <p>             Bases: <code>GetMembersMixin</code>, <code>SetMembersMixin</code>, <code>ObjectAliasMixin</code>, <code>SerializationMixin</code></p> <p>An abstract class representing a Python object.</p> <p>Attributes:</p> <ul> <li> kind             (<code>Kind</code>)         \u2013          <p>The object kind.</p> </li> <li> name             (<code>str</code>)         \u2013          <p>The object name.</p> </li> <li> lineno             (<code>int | None</code>)         \u2013          <p>The object starting line, or None for modules. Lines start at 1.</p> </li> <li> endlineno             (<code>int | None</code>)         \u2013          <p>The object ending line (inclusive), or None for modules.</p> </li> <li> docstring             (<code>Docstring | None</code>)         \u2013          <p>The object docstring.</p> </li> <li> parent             (<code>Module | Class | None</code>)         \u2013          <p>The object parent, or None if it is the top module.</p> </li> <li> members             (<code>dict[str, Object | Alias]</code>)         \u2013          <p>The object members.</p> </li> <li> labels             (<code>set[str]</code>)         \u2013          <p>The object labels.</p> </li> </ul> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013          <p>The object name, as declared in the code.</p> </li> <li> lineno             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>The object starting line, or None for modules. Lines start at 1.</p> </li> <li> endlineno             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>The object ending line (inclusive), or None for modules.</p> </li> <li> runtime             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether this object is present at runtime or not.</p> </li> <li> docstring             (<code>Docstring | None</code>, default:                 <code>None</code> )         \u2013          <p>The object docstring.</p> </li> <li> parent             (<code>Module | Class | None</code>, default:                 <code>None</code> )         \u2013          <p>The object parent.</p> </li> <li> lines_collection             (<code>LinesCollection | None</code>, default:                 <code>None</code> )         \u2013          <p>A collection of source code lines.</p> </li> <li> modules_collection             (<code>ModulesCollection | None</code>, default:                 <code>None</code> )         \u2013          <p>A collection of modules.</p> </li> </ul> <p>Methods:</p> <ul> <li> __delitem__           \u2013            <p>Delete a member with its name or path.</p> </li> <li> __getitem__           \u2013            <p>Get a member with its name or path.</p> </li> <li> __setitem__           \u2013            <p>Set a member with its name or path.</p> </li> <li> as_dict           \u2013            <p>Return this object's data as a dictionary.</p> </li> <li> as_json           \u2013            <p>Return this object's data as a JSON string.</p> </li> <li> del_member           \u2013            <p>Delete a member with its name or path.</p> </li> <li> filter_members           \u2013            <p>Filter and return members based on predicates.</p> </li> <li> from_json           \u2013            <p>Create an instance of this class from a JSON string.</p> </li> <li> get_member           \u2013            <p>Get a member with its name or path.</p> </li> <li> has_labels           \u2013            <p>Tell if this object has all the given labels.</p> </li> <li> is_exported           \u2013            <p>Tell if this object/alias is implicitely exported by its parent.</p> </li> <li> is_kind           \u2013            <p>Tell if this object is of the given kind.</p> </li> <li> is_public           \u2013            <p>Whether this object is considered public.</p> </li> <li> member_is_exported           \u2013            <p>Tell if a member of this object is \"exported\".</p> </li> <li> resolve           \u2013            <p>Resolve a name within this object's and parents' scope.</p> </li> <li> set_member           \u2013            <p>Set a member with its name or path.</p> </li> </ul> <p>Attributes:</p> <ul> <li> all_members             (<code>dict[str, Object | Alias]</code>)         \u2013          <p>All members (declared and inherited).</p> </li> <li> attributes             (<code>dict[str, Attribute]</code>)         \u2013          <p>Return the attribute members.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Return the full dotted path of this object.</p> </li> <li> classes             (<code>dict[str, Class]</code>)         \u2013          <p>Return the class members.</p> </li> <li> filepath             (<code>Path | list[Path]</code>)         \u2013          <p>Return the file path where this object was defined.</p> </li> <li> functions             (<code>dict[str, Function]</code>)         \u2013          <p>Return the function members.</p> </li> <li> has_docstring             (<code>bool</code>)         \u2013          <p>Tell if this object has a non-empty docstring.</p> </li> <li> has_docstrings             (<code>bool</code>)         \u2013          <p>Tell if this object or any of its members has a non-empty docstring.</p> </li> <li> inherited_members             (<code>dict[str, Alias]</code>)         \u2013          <p>Members that are inherited from base classes.</p> </li> <li> is_attribute             (<code>bool</code>)         \u2013          <p>Tell if this object is an attribute.</p> </li> <li> is_class             (<code>bool</code>)         \u2013          <p>Tell if this object is a class.</p> </li> <li> is_explicitely_exported             (<code>bool</code>)         \u2013          <p>Tell if this object/alias is explicitely exported by its parent.</p> </li> <li> is_function             (<code>bool</code>)         \u2013          <p>Tell if this object is a function.</p> </li> <li> is_implicitely_exported             (<code>bool</code>)         \u2013          <p>Tell if this object/alias is implicitely exported by its parent.</p> </li> <li> is_module             (<code>bool</code>)         \u2013          <p>Tell if this object is a module.</p> </li> <li> lines             (<code>list[str]</code>)         \u2013          <p>Return the lines containing the source of this object.</p> </li> <li> lines_collection             (<code>LinesCollection</code>)         \u2013          <p>Return the lines collection attached to this object or its parents.</p> </li> <li> module             (<code>Module</code>)         \u2013          <p>Return the parent module of this object.</p> </li> <li> modules             (<code>dict[str, Module]</code>)         \u2013          <p>Return the module members.</p> </li> <li> modules_collection             (<code>ModulesCollection</code>)         \u2013          <p>Return the modules collection attached to this object or its parents.</p> </li> <li> package             (<code>Module</code>)         \u2013          <p>Return the absolute top module (the package) of this object.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Return the dotted path of this object.</p> </li> <li> relative_filepath             (<code>Path</code>)         \u2013          <p>Return the file path where this object was defined, relative to the current working directory.</p> </li> <li> relative_package_filepath             (<code>Path</code>)         \u2013          <p>Return the file path where this object was defined, relative to the top module path.</p> </li> <li> source             (<code>str</code>)         \u2013          <p>Return the source code of this object.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    *,\n    lineno: int | None = None,\n    endlineno: int | None = None,\n    runtime: bool = True,\n    docstring: Docstring | None = None,\n    parent: Module | Class | None = None,\n    lines_collection: LinesCollection | None = None,\n    modules_collection: ModulesCollection | None = None,\n) -&gt; None:\n\"\"\"Initialize the object.\n\n    Parameters:\n        name: The object name, as declared in the code.\n        lineno: The object starting line, or None for modules. Lines start at 1.\n        endlineno: The object ending line (inclusive), or None for modules.\n        runtime: Whether this object is present at runtime or not.\n        docstring: The object docstring.\n        parent: The object parent.\n        lines_collection: A collection of source code lines.\n        modules_collection: A collection of modules.\n    \"\"\"\n    self.name: str = name\n    self.lineno: int | None = lineno\n    self.endlineno: int | None = endlineno\n    self.docstring: Docstring | None = docstring\n    self.parent: Module | Class | None = parent\n    self.members: dict[str, Object | Alias] = {}\n    self.labels: set[str] = set()\n    self.imports: dict[str, str] = {}\n    self.exports: set[str] | list[str | ExprName] | None = None\n    self.aliases: dict[str, Alias] = {}\n    self.runtime: bool = runtime\n    self.extra: dict[str, dict[str, Any]] = defaultdict(dict)\n    self.public: bool | None = None\n    self._lines_collection: LinesCollection | None = lines_collection\n    self._modules_collection: ModulesCollection | None = modules_collection\n\n    # attach the docstring to this object\n    if docstring:\n        docstring.parent = self\n</code></pre>"},{"location":"reference/griffe/#griffe.Object.all_members","title":"all_members  <code>property</code>","text":"<pre><code>all_members: dict[str, Object | Alias]\n</code></pre> <p>All members (declared and inherited).</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p>"},{"location":"reference/griffe/#griffe.Object.attributes","title":"attributes  <code>property</code>","text":"<pre><code>attributes: dict[str, Attribute]\n</code></pre> <p>Return the attribute members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Attribute]</code>         \u2013          <p>A dictionary of attributes.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Object.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Return the full dotted path of this object.</p> <p>The canonical path is the path where the object was defined (not imported).</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>A dotted path.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Object.classes","title":"classes  <code>property</code>","text":"<pre><code>classes: dict[str, Class]\n</code></pre> <p>Return the class members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Class]</code>         \u2013          <p>A dictionary of classes.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Object.filepath","title":"filepath  <code>property</code>","text":"<pre><code>filepath: Path | list[Path]\n</code></pre> <p>Return the file path where this object was defined.</p> <p>Returns:</p> <ul> <li> <code>Path | list[Path]</code>         \u2013          <p>A file path or a list of directories.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Object.functions","title":"functions  <code>property</code>","text":"<pre><code>functions: dict[str, Function]\n</code></pre> <p>Return the function members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Function]</code>         \u2013          <p>A dictionary of functions.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Object.has_docstring","title":"has_docstring  <code>property</code>","text":"<pre><code>has_docstring: bool\n</code></pre> <p>Tell if this object has a non-empty docstring.</p>"},{"location":"reference/griffe/#griffe.Object.has_docstrings","title":"has_docstrings  <code>property</code>","text":"<pre><code>has_docstrings: bool\n</code></pre> <p>Tell if this object or any of its members has a non-empty docstring.</p>"},{"location":"reference/griffe/#griffe.Object.inherited_members","title":"inherited_members  <code>cached</code> <code>property</code>","text":"<pre><code>inherited_members: dict[str, Alias]\n</code></pre> <p>Members that are inherited from base classes.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p>"},{"location":"reference/griffe/#griffe.Object.is_attribute","title":"is_attribute  <code>property</code>","text":"<pre><code>is_attribute: bool\n</code></pre> <p>Tell if this object is an attribute.</p>"},{"location":"reference/griffe/#griffe.Object.is_class","title":"is_class  <code>property</code>","text":"<pre><code>is_class: bool\n</code></pre> <p>Tell if this object is a class.</p>"},{"location":"reference/griffe/#griffe.Object.is_explicitely_exported","title":"is_explicitely_exported  <code>property</code>","text":"<pre><code>is_explicitely_exported: bool\n</code></pre> <p>Tell if this object/alias is explicitely exported by its parent.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Object.is_function","title":"is_function  <code>property</code>","text":"<pre><code>is_function: bool\n</code></pre> <p>Tell if this object is a function.</p>"},{"location":"reference/griffe/#griffe.Object.is_implicitely_exported","title":"is_implicitely_exported  <code>property</code>","text":"<pre><code>is_implicitely_exported: bool\n</code></pre> <p>Tell if this object/alias is implicitely exported by its parent.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Object.is_module","title":"is_module  <code>property</code>","text":"<pre><code>is_module: bool\n</code></pre> <p>Tell if this object is a module.</p>"},{"location":"reference/griffe/#griffe.Object.lines","title":"lines  <code>property</code>","text":"<pre><code>lines: list[str]\n</code></pre> <p>Return the lines containing the source of this object.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>         \u2013          <p>A list of lines.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Object.lines_collection","title":"lines_collection  <code>property</code>","text":"<pre><code>lines_collection: LinesCollection\n</code></pre> <p>Return the lines collection attached to this object or its parents.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When no modules collection can be found in the object or its parents.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>LinesCollection</code>         \u2013          <p>A lines collection.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Object.module","title":"module  <code>property</code>","text":"<pre><code>module: Module\n</code></pre> <p>Return the parent module of this object.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When the object is not a module and does not have a parent.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013          <p>The parent module.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Object.modules","title":"modules  <code>property</code>","text":"<pre><code>modules: dict[str, Module]\n</code></pre> <p>Return the module members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Module]</code>         \u2013          <p>A dictionary of modules.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Object.modules_collection","title":"modules_collection  <code>property</code>","text":"<pre><code>modules_collection: ModulesCollection\n</code></pre> <p>Return the modules collection attached to this object or its parents.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When no modules collection can be found in the object or its parents.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ModulesCollection</code>         \u2013          <p>A modules collection.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Object.package","title":"package  <code>property</code>","text":"<pre><code>package: Module\n</code></pre> <p>Return the absolute top module (the package) of this object.</p> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013          <p>The parent module.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Object.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Return the dotted path of this object.</p> <p>On regular objects (not aliases), the path is the canonical path.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>A dotted path.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Object.relative_filepath","title":"relative_filepath  <code>property</code>","text":"<pre><code>relative_filepath: Path\n</code></pre> <p>Return the file path where this object was defined, relative to the current working directory.</p> <p>If this object's file path is not relative to the current working directory, return its absolute path.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When the relative path could not be computed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code>         \u2013          <p>A file path.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Object.relative_package_filepath","title":"relative_package_filepath  <code>property</code>","text":"<pre><code>relative_package_filepath: Path\n</code></pre> <p>Return the file path where this object was defined, relative to the top module path.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When the relative path could not be computed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code>         \u2013          <p>A file path.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Object.source","title":"source  <code>property</code>","text":"<pre><code>source: str\n</code></pre> <p>Return the source code of this object.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The source code.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.Object.__delitem__","title":"__delitem__","text":"<pre><code>__delitem__(key: str | Sequence[str]) -&gt; None\n</code></pre> <p>Delete a member with its name or path.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Members will be looked up in both declared members and inherited ones, triggering computation of the latter.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; del griffe_object[\"foo\"]\n&gt;&gt;&gt; del griffe_object[\"path.to.bar\"]\n&gt;&gt;&gt; del griffe_object[(\"path\", \"to\", \"qux\")]\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def __delitem__(self, key: str | Sequence[str]) -&gt; None:\n\"\"\"Delete a member with its name or path.\n\n    This method is part of the consumer API:\n    do not use when producing Griffe trees!\n\n    Members will be looked up in both declared members and inherited ones,\n    triggering computation of the latter.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; del griffe_object[\"foo\"]\n        &gt;&gt;&gt; del griffe_object[\"path.to.bar\"]\n        &gt;&gt;&gt; del griffe_object[(\"path\", \"to\", \"qux\")]\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        try:\n            del self.members[name]  # type: ignore[attr-defined]\n        except KeyError:\n            del self.inherited_members[name]  # type: ignore[attr-defined]\n    else:\n        del self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/#griffe.Object.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key: str | Sequence[str]) -&gt; Any\n</code></pre> <p>Get a member with its name or path.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Members will be looked up in both declared members and inherited ones, triggering computation of the latter.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; foo = griffe_object[\"foo\"]\n&gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n&gt;&gt;&gt; qux = griffe_object[(\"path\", \"to\", \"qux\")]\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def __getitem__(self, key: str | Sequence[str]) -&gt; Any:\n\"\"\"Get a member with its name or path.\n\n    This method is part of the consumer API:\n    do not use when producing Griffe trees!\n\n    Members will be looked up in both declared members and inherited ones,\n    triggering computation of the latter.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; foo = griffe_object[\"foo\"]\n        &gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n        &gt;&gt;&gt; qux = griffe_object[(\"path\", \"to\", \"qux\")]\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        return self.all_members[parts[0]]  # type: ignore[attr-defined]\n    return self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/#griffe.Object.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(\n    key: str | Sequence[str], value: Object | Alias\n) -&gt; None\n</code></pre> <p>Set a member with its name or path.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> <li> value             (<code>Object | Alias</code>)         \u2013          <p>The member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; griffe_object[\"foo\"] = foo\n&gt;&gt;&gt; griffe_object[\"path.to.bar\"] = bar\n&gt;&gt;&gt; griffe_object[(\"path\", \"to\", \"qux\")] = qux\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def __setitem__(self, key: str | Sequence[str], value: Object | Alias) -&gt; None:\n\"\"\"Set a member with its name or path.\n\n    This method is part of the consumer API:\n    do not use when producing Griffe trees!\n\n    Parameters:\n        key: The name or path of the member.\n        value: The member.\n\n    Examples:\n        &gt;&gt;&gt; griffe_object[\"foo\"] = foo\n        &gt;&gt;&gt; griffe_object[\"path.to.bar\"] = bar\n        &gt;&gt;&gt; griffe_object[(\"path\", \"to\", \"qux\")] = qux\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        self.members[name] = value  # type: ignore[attr-defined]\n        if self.is_collection:  # type: ignore[attr-defined]\n            value._modules_collection = self  # type: ignore[union-attr]\n        else:\n            value.parent = self  # type: ignore[assignment]\n    else:\n        self.members[parts[0]][parts[1:]] = value  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/#griffe.Object.as_dict","title":"as_dict","text":"<pre><code>as_dict(\n    *, full: bool = False, **kwargs: Any\n) -&gt; dict[str, Any]\n</code></pre> <p>Return this object's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> full             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to return full info, or just base info.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def as_dict(self, *, full: bool = False, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return this object's data as a dictionary.\n\n    Parameters:\n        full: Whether to return full info, or just base info.\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    base = {\n        \"kind\": self.kind,\n        \"name\": self.name,\n    }\n\n    if full:\n        base.update(\n            {\n                \"path\": self.path,\n                \"filepath\": self.filepath,\n                \"relative_filepath\": self.relative_filepath,\n                \"relative_package_filepath\": self.relative_package_filepath,\n            },\n        )\n\n    if self.lineno:\n        base[\"lineno\"] = self.lineno\n    if self.endlineno:\n        base[\"endlineno\"] = self.endlineno\n    if self.docstring:\n        base[\"docstring\"] = self.docstring\n\n    # doing this last for a prettier JSON dump\n    base[\"labels\"] = self.labels\n    base[\"members\"] = [member.as_dict(full=full, **kwargs) for member in self.members.values()]\n\n    return base\n</code></pre>"},{"location":"reference/griffe/#griffe.Object.as_json","title":"as_json","text":"<pre><code>as_json(*, full: bool = False, **kwargs: Any) -&gt; str\n</code></pre> <p>Return this object's data as a JSON string.</p> <p>Parameters:</p> <ul> <li> full             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to return full info, or just base info.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options passed to encoder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>A JSON string.</p> </li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>def as_json(self, *, full: bool = False, **kwargs: Any) -&gt; str:\n\"\"\"Return this object's data as a JSON string.\n\n    Parameters:\n        full: Whether to return full info, or just base info.\n        **kwargs: Additional serialization options passed to encoder.\n\n    Returns:\n        A JSON string.\n    \"\"\"\n    from griffe.encoders import JSONEncoder  # avoid circular import\n\n    return json.dumps(self, cls=JSONEncoder, full=full, **kwargs)\n</code></pre>"},{"location":"reference/griffe/#griffe.Object.del_member","title":"del_member","text":"<pre><code>del_member(key: str | Sequence[str]) -&gt; None\n</code></pre> <p>Delete a member with its name or path.</p> <p>This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).</p> <p>Members will be looked up in declared members only, not inherited ones.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; griffe_object.del_member(\"foo\")\n&gt;&gt;&gt; griffe_object.del_member(\"path.to.bar\")\n&gt;&gt;&gt; griffe_object.del_member((\"path\", \"to\", \"qux\"))\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def del_member(self, key: str | Sequence[str]) -&gt; None:\n\"\"\"Delete a member with its name or path.\n\n    This method is part of the producer API:\n    you can use it safely while building Griffe trees\n    (for example in Griffe extensions).\n\n    Members will be looked up in declared members only, not inherited ones.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; griffe_object.del_member(\"foo\")\n        &gt;&gt;&gt; griffe_object.del_member(\"path.to.bar\")\n        &gt;&gt;&gt; griffe_object.del_member((\"path\", \"to\", \"qux\"))\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        del self.members[name]  # type: ignore[attr-defined]\n    else:\n        self.members[parts[0]].del_member(parts[1:])  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/#griffe.Object.filter_members","title":"filter_members","text":"<pre><code>filter_members(\n    *predicates: Callable[[Object | Alias], bool]\n) -&gt; dict[str, Object | Alias]\n</code></pre> <p>Filter and return members based on predicates.</p> <p>Parameters:</p> <ul> <li> *predicates             (<code>Callable[[Object | Alias], bool]</code>, default:                 <code>()</code> )         \u2013          <p>A list of predicates, i.e. callables accepting a member as argument and returning a boolean.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Object | Alias]</code>         \u2013          <p>A dictionary of members.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def filter_members(self, *predicates: Callable[[Object | Alias], bool]) -&gt; dict[str, Object | Alias]:\n\"\"\"Filter and return members based on predicates.\n\n    Parameters:\n        *predicates: A list of predicates, i.e. callables accepting a member as argument and returning a boolean.\n\n    Returns:\n        A dictionary of members.\n    \"\"\"\n    if not predicates:\n        return self.members\n    members: dict[str, Object | Alias] = {}\n    for name, member in self.members.items():\n        if all(predicate(member) for predicate in predicates):\n            members[name] = member\n    return members\n</code></pre>"},{"location":"reference/griffe/#griffe.Object.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_string: str, **kwargs: Any) -&gt; _ObjType\n</code></pre> <p>Create an instance of this class from a JSON string.</p> <p>Parameters:</p> <ul> <li> json_string             (<code>str</code>)         \u2013          <p>JSON to decode into Object.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional options passed to decoder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_ObjType</code>         \u2013          <p>An Object instance.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>           \u2013          <p>When the json_string does not represent and object of the class from which this classmethod has been called.</p> </li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>@classmethod\ndef from_json(cls: type[_ObjType], json_string: str, **kwargs: Any) -&gt; _ObjType:  # noqa: PYI019\n\"\"\"Create an instance of this class from a JSON string.\n\n    Parameters:\n        json_string: JSON to decode into Object.\n        **kwargs: Additional options passed to decoder.\n\n    Returns:\n        An Object instance.\n\n    Raises:\n        TypeError: When the json_string does not represent and object\n            of the class from which this classmethod has been called.\n    \"\"\"\n    from griffe.encoders import json_decoder  # avoid circular import\n\n    kwargs.setdefault(\"object_hook\", json_decoder)\n    obj = json.loads(json_string, **kwargs)\n    if not isinstance(obj, cls):\n        raise TypeError(f\"provided JSON object is not of type {cls}\")\n    return obj\n</code></pre>"},{"location":"reference/griffe/#griffe.Object.get_member","title":"get_member","text":"<pre><code>get_member(key: str | Sequence[str]) -&gt; Any\n</code></pre> <p>Get a member with its name or path.</p> <p>This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).</p> <p>Members will be looked up in declared members only, not inherited ones.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; foo = griffe_object[\"foo\"]\n&gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n&gt;&gt;&gt; bar = griffe_object[(\"path\", \"to\", \"bar\")]\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def get_member(self, key: str | Sequence[str]) -&gt; Any:\n\"\"\"Get a member with its name or path.\n\n    This method is part of the producer API:\n    you can use it safely while building Griffe trees\n    (for example in Griffe extensions).\n\n    Members will be looked up in declared members only, not inherited ones.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; foo = griffe_object[\"foo\"]\n        &gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n        &gt;&gt;&gt; bar = griffe_object[(\"path\", \"to\", \"bar\")]\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        return self.members[parts[0]]  # type: ignore[attr-defined]\n    return self.members[parts[0]].get_member(parts[1:])  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/#griffe.Object.has_labels","title":"has_labels","text":"<pre><code>has_labels(labels: set[str]) -&gt; bool\n</code></pre> <p>Tell if this object has all the given labels.</p> <p>Parameters:</p> <ul> <li> labels             (<code>set[str]</code>)         \u2013          <p>A set of labels.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def has_labels(self, labels: set[str]) -&gt; bool:\n\"\"\"Tell if this object has all the given labels.\n\n    Parameters:\n        labels: A set of labels.\n\n    Returns:\n        True or False.\n    \"\"\"\n    return all(label in self.labels for label in labels)\n</code></pre>"},{"location":"reference/griffe/#griffe.Object.is_exported","title":"is_exported","text":"<pre><code>is_exported(*, explicitely: bool = True) -&gt; bool\n</code></pre> <p>Tell if this object/alias is implicitely exported by its parent.</p> <p>Parameters:</p> <ul> <li> explicitely             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to only return True when <code>__all__</code> is defined.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>def is_exported(self, *, explicitely: bool = True) -&gt; bool:\n\"\"\"Tell if this object/alias is implicitely exported by its parent.\n\n    Parameters:\n        explicitely: Whether to only return True when `__all__` is defined.\n\n    Returns:\n        True or False.\n    \"\"\"\n    return self.parent.member_is_exported(self, explicitely=explicitely)  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/#griffe.Object.is_kind","title":"is_kind","text":"<pre><code>is_kind(kind: str | Kind | set[str | Kind]) -&gt; bool\n</code></pre> <p>Tell if this object is of the given kind.</p> <p>Parameters:</p> <ul> <li> kind             (<code>str | Kind | set[str | Kind]</code>)         \u2013          <p>An instance or set of kinds (strings or enumerations).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When an empty set is given as argument.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def is_kind(self, kind: str | Kind | set[str | Kind]) -&gt; bool:\n\"\"\"Tell if this object is of the given kind.\n\n    Parameters:\n        kind: An instance or set of kinds (strings or enumerations).\n\n    Raises:\n        ValueError: When an empty set is given as argument.\n\n    Returns:\n        True or False.\n    \"\"\"\n    if isinstance(kind, set):\n        if not kind:\n            raise ValueError(\"kind must not be an empty set\")\n        return self.kind in (knd if isinstance(knd, Kind) else Kind(knd) for knd in kind)\n    if isinstance(kind, str):\n        kind = Kind(kind)\n    return self.kind is kind\n</code></pre>"},{"location":"reference/griffe/#griffe.Object.is_public","title":"is_public","text":"<pre><code>is_public(\n    *, strict: bool = False, check_name: bool = True\n) -&gt; bool\n</code></pre> <p>Whether this object is considered public.</p> <p>In modules, developers can mark objects as public thanks to the <code>__all__</code> variable. In classes however, there is no convention or standard to do so.</p> <p>Therefore, to decide whether an object is public, we follow this algorithm:</p> <ul> <li>If the object's <code>public</code> attribute is set (boolean), return its value.</li> <li>In strict mode, the object is public only if it is explicitely exported (listed in <code>__all__</code>).     Strict mode should only be used for module members.</li> <li>Otherwise, if name checks are enabled, the object is private if its name starts with an underscore.</li> <li>Otherwise, if the object is an alias, and is neither inherited from a base class,     nor a member of a parent alias, it is not public.</li> <li>Otherwise, the object is public.</li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>def is_public(\n    self,\n    *,\n    strict: bool = False,\n    check_name: bool = True,\n) -&gt; bool:\n\"\"\"Whether this object is considered public.\n\n    In modules, developers can mark objects as public thanks to the `__all__` variable.\n    In classes however, there is no convention or standard to do so.\n\n    Therefore, to decide whether an object is public, we follow this algorithm:\n\n    - If the object's `public` attribute is set (boolean), return its value.\n    - In strict mode, the object is public only if it is explicitely exported (listed in `__all__`).\n        Strict mode should only be used for module members.\n    - Otherwise, if name checks are enabled, the object is private if its name starts with an underscore.\n    - Otherwise, if the object is an alias, and is neither inherited from a base class,\n        nor a member of a parent alias, it is not public.\n    - Otherwise, the object is public.\n    \"\"\"\n    if self.public is not None:  # type: ignore[attr-defined]\n        return self.public  # type: ignore[attr-defined]\n    if self.is_explicitely_exported:\n        return True\n    if strict:\n        return False\n    if check_name and self.name.startswith(\"_\"):  # type: ignore[attr-defined]\n        return False\n    if self.is_alias and not (self.inherited or self.parent.is_alias):  # type: ignore[attr-defined]\n        return False\n    return True\n</code></pre>"},{"location":"reference/griffe/#griffe.Object.member_is_exported","title":"member_is_exported","text":"<pre><code>member_is_exported(\n    member: Object | Alias, *, explicitely: bool = True\n) -&gt; bool\n</code></pre> <p>Tell if a member of this object is \"exported\".</p> <p>By exported, we mean that the object is included in the <code>__all__</code> attribute of its parent module or class. When <code>__all__</code> is not defined, we consider the member to be implicitely exported, unless it's a module and it was not imported, and unless it's not defined at runtime.</p> <p>Parameters:</p> <ul> <li> member             (<code>Object | Alias</code>)         \u2013          <p>The member to verify.</p> </li> <li> explicitely             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to only return True when <code>__all__</code> is defined.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def member_is_exported(self, member: Object | Alias, *, explicitely: bool = True) -&gt; bool:\n\"\"\"Tell if a member of this object is \"exported\".\n\n    By exported, we mean that the object is included in the `__all__` attribute\n    of its parent module or class. When `__all__` is not defined,\n    we consider the member to be *implicitely* exported,\n    unless it's a module and it was not imported,\n    and unless it's not defined at runtime.\n\n    Parameters:\n        member: The member to verify.\n        explicitely: Whether to only return True when `__all__` is defined.\n\n    Returns:\n        True or False.\n    \"\"\"\n    if not member.runtime:\n        return False\n    if self.exports is None:\n        return not explicitely and (member.is_alias or not member.is_module or member.name in self.imports)\n    return member.name in self.exports\n</code></pre>"},{"location":"reference/griffe/#griffe.Object.resolve","title":"resolve","text":"<pre><code>resolve(name: str) -&gt; str\n</code></pre> <p>Resolve a name within this object's and parents' scope.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013          <p>The name to resolve.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NameResolutionError</code>           \u2013          <p>When the name could not be resolved.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The resolved name.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def resolve(self, name: str) -&gt; str:\n\"\"\"Resolve a name within this object's and parents' scope.\n\n    Parameters:\n        name: The name to resolve.\n\n    Raises:\n        NameResolutionError: When the name could not be resolved.\n\n    Returns:\n        The resolved name.\n    \"\"\"\n    if name in self.members:\n        if self.members[name].is_alias:\n            return self.members[name].target_path  # type: ignore[union-attr]\n        return self.members[name].path\n    if name in self.imports:\n        return self.imports[name]\n    if self.parent is None:\n        # could be a built-in\n        raise NameResolutionError(f\"{name} could not be resolved in the scope of {self.path}\")\n    if name == self.parent.name and not self.parent.is_module:\n        return self.parent.path\n    return self.parent.resolve(name)\n</code></pre>"},{"location":"reference/griffe/#griffe.Object.set_member","title":"set_member","text":"<pre><code>set_member(\n    key: str | Sequence[str], value: Object | Alias\n) -&gt; None\n</code></pre> <p>Set a member with its name or path.</p> <p>This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> <li> value             (<code>Object | Alias</code>)         \u2013          <p>The member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; griffe_object.set_member(\"foo\", foo)\n&gt;&gt;&gt; griffe_object.set_member(\"path.to.bar\", bar)\n&gt;&gt;&gt; griffe_object.set_member((\"path\", \"to\", \"qux\", qux)\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def set_member(self, key: str | Sequence[str], value: Object | Alias) -&gt; None:\n\"\"\"Set a member with its name or path.\n\n    This method is part of the producer API:\n    you can use it safely while building Griffe trees\n    (for example in Griffe extensions).\n\n    Parameters:\n        key: The name or path of the member.\n        value: The member.\n\n    Examples:\n        &gt;&gt;&gt; griffe_object.set_member(\"foo\", foo)\n        &gt;&gt;&gt; griffe_object.set_member(\"path.to.bar\", bar)\n        &gt;&gt;&gt; griffe_object.set_member((\"path\", \"to\", \"qux\", qux)\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        if name in self.members:  # type: ignore[attr-defined]\n            member = self.members[name]  # type: ignore[attr-defined]\n            if not member.is_alias:\n                # when reassigning a module to an existing one,\n                # try to merge them as one regular and one stubs module\n                # (implicit support for .pyi modules)\n                if member.is_module and not (member.is_namespace_package or member.is_namespace_subpackage):\n                    with suppress(AliasResolutionError, CyclicAliasError):\n                        if value.is_module and value.filepath != member.filepath:\n                            with suppress(ValueError):\n                                value = merge_stubs(member, value)  # type: ignore[arg-type]\n                for alias in member.aliases.values():\n                    with suppress(CyclicAliasError):\n                        alias.target = value\n        self.members[name] = value  # type: ignore[attr-defined]\n        if self.is_collection:  # type: ignore[attr-defined]\n            value._modules_collection = self  # type: ignore[union-attr]\n        else:\n            value.parent = self  # type: ignore[assignment]\n    else:\n        self.members[parts[0]].set_member(parts[1:], value)  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/#griffe.ObjectNode","title":"ObjectNode","text":"<pre><code>ObjectNode(\n    obj: Any, name: str, parent: ObjectNode | None = None\n)\n</code></pre> <p>Helper class to represent an object tree.</p> <p>It's not really a tree but more a backward-linked list: each node has a reference to its parent, but not to its child (for simplicity purposes and to avoid bugs).</p> <p>Each node stores an object, its name, and a reference to its parent node.</p> <p>Attributes:</p> <ul> <li> obj             (<code>Any</code>)         \u2013          <p>The actual Python object.</p> </li> <li> name             (<code>str</code>)         \u2013          <p>The Python object's name.</p> </li> <li> parent             (<code>ObjectNode | None</code>)         \u2013          <p>The parent node.</p> </li> </ul> <p>Parameters:</p> <ul> <li> obj             (<code>Any</code>)         \u2013          <p>A Python object.</p> </li> <li> name             (<code>str</code>)         \u2013          <p>The object's name.</p> </li> <li> parent             (<code>ObjectNode | None</code>, default:                 <code>None</code> )         \u2013          <p>The object's parent node.</p> </li> </ul> <p>Methods:</p> <ul> </ul> <p>Attributes:</p> <ul> <li> alias_target_path             (<code>str | None</code>)         \u2013          <p>Alias target path of this node, if the node should be an alias.</p> </li> <li> children             (<code>Sequence[ObjectNode]</code>)         \u2013          <p>Build and return the children of this node.</p> </li> <li> is_builtin_function             (<code>bool</code>)         \u2013          <p>Tell if this node's object is a builtin function.</p> </li> <li> is_builtin_method             (<code>bool</code>)         \u2013          <p>Tell if this node's object is a builtin method.</p> </li> <li> is_cached_property             (<code>bool</code>)         \u2013          <p>Tell if this node's object is a cached property.</p> </li> <li> is_class             (<code>bool</code>)         \u2013          <p>Tell if this node's object is a class.</p> </li> <li> is_classmethod             (<code>bool</code>)         \u2013          <p>Tell if this node's object is a classmethod.</p> </li> <li> is_coroutine             (<code>bool</code>)         \u2013          <p>Tell if this node's object is a coroutine.</p> </li> <li> is_function             (<code>bool</code>)         \u2013          <p>Tell if this node's object is a function.</p> </li> <li> is_method             (<code>bool</code>)         \u2013          <p>Tell if this node's object is a method.</p> </li> <li> is_method_descriptor             (<code>bool</code>)         \u2013          <p>Tell if this node's object is a method descriptor.</p> </li> <li> is_module             (<code>bool</code>)         \u2013          <p>Tell if this node's object is a module.</p> </li> <li> is_property             (<code>bool</code>)         \u2013          <p>Tell if this node's object is a property.</p> </li> <li> is_staticmethod             (<code>bool</code>)         \u2013          <p>Tell if this node's object is a staticmethod.</p> </li> <li> kind             (<code>ObjectKind</code>)         \u2013          <p>Return the kind of this node.</p> </li> <li> module             (<code>ObjectNode</code>)         \u2013          <p>The object's module.</p> </li> <li> parent_is_class             (<code>bool</code>)         \u2013          <p>Tell if the object of this node's parent is a class.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>The object's (Python) path.</p> </li> </ul> Source code in <code>src/griffe/agents/nodes/_runtime.py</code> <pre><code>def __init__(self, obj: Any, name: str, parent: ObjectNode | None = None) -&gt; None:\n\"\"\"Initialize the object.\n\n    Arguments:\n        obj: A Python object.\n        name: The object's name.\n        parent: The object's parent node.\n    \"\"\"\n    try:\n        obj = inspect.unwrap(obj)\n    except Exception as error:  # noqa: BLE001\n        # inspect.unwrap at some point runs hasattr(obj, \"__wrapped__\"),\n        # which triggers the __getattr__ method of the object, which in\n        # turn can raise various exceptions. Probably not just __getattr__.\n        # See https://github.com/pawamoy/pytkdocs/issues/45\n        logger.debug(f\"Could not unwrap {name}: {error!r}\")\n\n    self.obj: Any = obj\n    self.name: str = name\n    self.parent: ObjectNode | None = parent\n</code></pre>"},{"location":"reference/griffe/#griffe.ObjectNode.alias_target_path","title":"alias_target_path  <code>cached</code> <code>property</code>","text":"<pre><code>alias_target_path: str | None\n</code></pre> <p>Alias target path of this node, if the node should be an alias.</p>"},{"location":"reference/griffe/#griffe.ObjectNode.children","title":"children  <code>cached</code> <code>property</code>","text":"<pre><code>children: Sequence[ObjectNode]\n</code></pre> <p>Build and return the children of this node.</p> <p>Returns:</p> <ul> <li> <code>Sequence[ObjectNode]</code>         \u2013          <p>A list of children.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.ObjectNode.is_builtin_function","title":"is_builtin_function  <code>cached</code> <code>property</code>","text":"<pre><code>is_builtin_function: bool\n</code></pre> <p>Tell if this node's object is a builtin function.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>If this node's object is a builtin function.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.ObjectNode.is_builtin_method","title":"is_builtin_method  <code>cached</code> <code>property</code>","text":"<pre><code>is_builtin_method: bool\n</code></pre> <p>Tell if this node's object is a builtin method.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>If this node's object is a builtin method.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.ObjectNode.is_cached_property","title":"is_cached_property  <code>cached</code> <code>property</code>","text":"<pre><code>is_cached_property: bool\n</code></pre> <p>Tell if this node's object is a cached property.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>If this node's object is a cached property.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.ObjectNode.is_class","title":"is_class  <code>cached</code> <code>property</code>","text":"<pre><code>is_class: bool\n</code></pre> <p>Tell if this node's object is a class.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>If this node's object is a class.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.ObjectNode.is_classmethod","title":"is_classmethod  <code>cached</code> <code>property</code>","text":"<pre><code>is_classmethod: bool\n</code></pre> <p>Tell if this node's object is a classmethod.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>If this node's object is a classmethod.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.ObjectNode.is_coroutine","title":"is_coroutine  <code>cached</code> <code>property</code>","text":"<pre><code>is_coroutine: bool\n</code></pre> <p>Tell if this node's object is a coroutine.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>If this node's object is a coroutine.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.ObjectNode.is_function","title":"is_function  <code>cached</code> <code>property</code>","text":"<pre><code>is_function: bool\n</code></pre> <p>Tell if this node's object is a function.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>If this node's object is a function.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.ObjectNode.is_method","title":"is_method  <code>cached</code> <code>property</code>","text":"<pre><code>is_method: bool\n</code></pre> <p>Tell if this node's object is a method.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>If this node's object is a method.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.ObjectNode.is_method_descriptor","title":"is_method_descriptor  <code>cached</code> <code>property</code>","text":"<pre><code>is_method_descriptor: bool\n</code></pre> <p>Tell if this node's object is a method descriptor.</p> <p>Built-in methods (e.g. those implemented in C/Rust) are often method descriptors, rather than normal methods.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>If this node's object is a method descriptor.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.ObjectNode.is_module","title":"is_module  <code>cached</code> <code>property</code>","text":"<pre><code>is_module: bool\n</code></pre> <p>Tell if this node's object is a module.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>The root of the tree.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.ObjectNode.is_property","title":"is_property  <code>cached</code> <code>property</code>","text":"<pre><code>is_property: bool\n</code></pre> <p>Tell if this node's object is a property.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>If this node's object is a property.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.ObjectNode.is_staticmethod","title":"is_staticmethod  <code>cached</code> <code>property</code>","text":"<pre><code>is_staticmethod: bool\n</code></pre> <p>Tell if this node's object is a staticmethod.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>If this node's object is a staticmethod.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.ObjectNode.kind","title":"kind  <code>property</code>","text":"<pre><code>kind: ObjectKind\n</code></pre> <p>Return the kind of this node.</p> <p>Returns:</p> <ul> <li> <code>ObjectKind</code>         \u2013          <p>The node kind.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.ObjectNode.module","title":"module  <code>property</code>","text":"<pre><code>module: ObjectNode\n</code></pre> <p>The object's module.</p>"},{"location":"reference/griffe/#griffe.ObjectNode.parent_is_class","title":"parent_is_class  <code>cached</code> <code>property</code>","text":"<pre><code>parent_is_class: bool\n</code></pre> <p>Tell if the object of this node's parent is a class.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>If the object of this node's parent is a class.</p> </li> </ul>"},{"location":"reference/griffe/#griffe.ObjectNode.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>The object's (Python) path.</p>"},{"location":"reference/griffe/#griffe.dynamic_import","title":"dynamic_import","text":"<pre><code>dynamic_import(\n    import_path: str,\n    import_paths: Sequence[str | Path] | None = None,\n) -&gt; Any\n</code></pre> <p>Dynamically import the specified object.</p> <p>It can be a module, class, method, function, attribute, nested arbitrarily.</p> <p>Parameters:</p> <ul> <li> import_path             (<code>str</code>)         \u2013          <p>The path of the object to import.</p> </li> <li> import_paths             (<code>Sequence[str | Path] | None</code>, default:                 <code>None</code> )         \u2013          <p>The paths to import the object from.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ModuleNotFoundError</code>           \u2013          <p>When the object's module could not be found.</p> </li> <li> <code>ImportError</code>           \u2013          <p>When there was an import error or when couldn't get the attribute.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code>         \u2013          <p>The imported object.</p> </li> </ul> Source code in <code>src/griffe/importer.py</code> <pre><code>def dynamic_import(import_path: str, import_paths: Sequence[str | Path] | None = None) -&gt; Any:\n\"\"\"Dynamically import the specified object.\n\n    It can be a module, class, method, function, attribute,\n    nested arbitrarily.\n\n    Parameters:\n        import_path: The path of the object to import.\n        import_paths: The paths to import the object from.\n\n    Raises:\n        ModuleNotFoundError: When the object's module could not be found.\n        ImportError: When there was an import error or when couldn't get the attribute.\n\n    Returns:\n        The imported object.\n    \"\"\"\n    module_parts: list[str] = import_path.split(\".\")\n    object_parts: list[str] = []\n    errors = []\n\n    with sys_path(*(import_paths or ())):\n        while True:\n            module_path = \".\".join(module_parts)\n            try:\n                module = import_module(module_path)\n            except ModuleNotFoundError as error:\n                if len(module_parts) == 1:\n                    raise\n                errors.append(f\"{error.__class__.__name__}: {error}\")\n                object_parts.insert(0, module_parts.pop(-1))\n            except (Exception, BaseException) as error:\n                # pyo3's PanicException can only be caught with BaseException.\n                # We do want to catch base exceptions anyway (exit, interrupt, etc.),\n                errors.append(f\"{error.__class__.__name__}: {error}\")\n                raise ImportError(\"\\n\".join(errors)) from error\n            else:\n                break\n\n    # Sometimes extra dependencies are not installed,\n    # and therefore we aren't able to import the leaf module,\n    # so we end up with its parent instead, on which we can't\n    # get the attribute either. In that case we re-raise an\n    # ImportError for consistency.\n    # See https://github.com/mkdocstrings/mkdocstrings/issues/380\n\n    value = module\n    for part in object_parts:\n        try:\n            value = getattr(value, part)\n        except AttributeError as error:\n            raise ImportError(\"\\n\".join(errors)) from error\n    return value\n</code></pre>"},{"location":"reference/griffe/#griffe.find_breaking_changes","title":"find_breaking_changes","text":"<pre><code>find_breaking_changes(\n    old_obj: Object | Alias,\n    new_obj: Object | Alias,\n    *,\n    ignore_private: bool = True\n) -&gt; Iterator[Breakage]\n</code></pre> <p>Find breaking changes between two versions of the same API.</p> <p>The function will iterate recursively on all objects and yield breaking changes with detailed information.</p> <p>Parameters:</p> <ul> <li> old_obj             (<code>Object | Alias</code>)         \u2013          <p>The old version of an object.</p> </li> <li> new_obj             (<code>Object | Alias</code>)         \u2013          <p>The new version of an object.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>Breakage</code>         \u2013          <p>Breaking changes.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import sys, griffe\n&gt;&gt;&gt; new = griffe.load(\"pkg\")\n&gt;&gt;&gt; old = griffe.load_git(\"pkg\", \"1.2.3\")\n&gt;&gt;&gt; for breakage in griffe.find_breaking_changes(old, new)\n...     print(breakage.explain(style=style), file=sys.stderr)\n</code></pre> Source code in <code>src/griffe/diff.py</code> <pre><code>def find_breaking_changes(\n    old_obj: Object | Alias,\n    new_obj: Object | Alias,\n    *,\n    ignore_private: bool = True,\n) -&gt; Iterator[Breakage]:\n\"\"\"Find breaking changes between two versions of the same API.\n\n    The function will iterate recursively on all objects\n    and yield breaking changes with detailed information.\n\n    Parameters:\n        old_obj: The old version of an object.\n        new_obj: The new version of an object.\n\n    Yields:\n        Breaking changes.\n\n    Examples:\n        &gt;&gt;&gt; import sys, griffe\n        &gt;&gt;&gt; new = griffe.load(\"pkg\")\n        &gt;&gt;&gt; old = griffe.load_git(\"pkg\", \"1.2.3\")\n        &gt;&gt;&gt; for breakage in griffe.find_breaking_changes(old, new)\n        ...     print(breakage.explain(style=style), file=sys.stderr)\n    \"\"\"\n    yield from _member_incompatibilities(old_obj, new_obj, ignore_private=ignore_private)\n</code></pre>"},{"location":"reference/griffe/#griffe.get_logger","title":"get_logger","text":"<pre><code>get_logger(name: str) -&gt; _Logger\n</code></pre> <p>Create and return a new logger instance.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013          <p>The logger name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_Logger</code>         \u2013          <p>The logger.</p> </li> </ul> Source code in <code>src/griffe/logger.py</code> <pre><code>def get_logger(name: str) -&gt; _Logger:\n\"\"\"Create and return a new logger instance.\n\n    Parameters:\n        name: The logger name.\n\n    Returns:\n        The logger.\n    \"\"\"\n    return _Logger(name)\n</code></pre>"},{"location":"reference/griffe/#griffe.load","title":"load","text":"<pre><code>load(\n    module: str | Path,\n    *,\n    submodules: bool = True,\n    try_relative_path: bool = True,\n    extensions: Extensions | None = None,\n    search_paths: Sequence[str | Path] | None = None,\n    docstring_parser: Parser | None = None,\n    docstring_options: dict[str, Any] | None = None,\n    lines_collection: LinesCollection | None = None,\n    modules_collection: ModulesCollection | None = None,\n    allow_inspection: bool = True\n) -&gt; Module\n</code></pre> <p>Load and return a module.</p> <p>Example: <pre><code>import griffe\n\nmodule = griffe.load(...)\n</code></pre></p> <p>This is a shortcut for:</p> <pre><code>from griffe.loader import GriffeLoader\n\nloader = GriffeLoader(...)\nmodule = loader.load_module(...)\n</code></pre> <p>See the documentation for the loader: <code>GriffeLoader</code>.</p> <p>Parameters:</p> <ul> <li> module             (<code>str | Path</code>)         \u2013          <p>The module name or path.</p> </li> <li> submodules             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to recurse on the submodules.</p> </li> <li> try_relative_path             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to try finding the module as a relative path.</p> </li> <li> extensions             (<code>Extensions | None</code>, default:                 <code>None</code> )         \u2013          <p>The extensions to use.</p> </li> <li> search_paths             (<code>Sequence[str | Path] | None</code>, default:                 <code>None</code> )         \u2013          <p>The paths to search into.</p> </li> <li> docstring_parser             (<code>Parser | None</code>, default:                 <code>None</code> )         \u2013          <p>The docstring parser to use. By default, no parsing is done.</p> </li> <li> docstring_options             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional docstring parsing options.</p> </li> <li> lines_collection             (<code>LinesCollection | None</code>, default:                 <code>None</code> )         \u2013          <p>A collection of source code lines.</p> </li> <li> modules_collection             (<code>ModulesCollection | None</code>, default:                 <code>None</code> )         \u2013          <p>A collection of modules.</p> </li> <li> allow_inspection             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to allow inspecting modules when visiting them is not possible.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013          <p>A loaded module.</p> </li> </ul> Source code in <code>src/griffe/loader.py</code> <pre><code>def load(\n    module: str | Path,\n    *,\n    submodules: bool = True,\n    try_relative_path: bool = True,\n    extensions: Extensions | None = None,\n    search_paths: Sequence[str | Path] | None = None,\n    docstring_parser: Parser | None = None,\n    docstring_options: dict[str, Any] | None = None,\n    lines_collection: LinesCollection | None = None,\n    modules_collection: ModulesCollection | None = None,\n    allow_inspection: bool = True,\n) -&gt; Module:\n\"\"\"Load and return a module.\n\n    Example:\n    ```python\n    import griffe\n\n    module = griffe.load(...)\n    ```\n\n    This is a shortcut for:\n\n    ```python\n    from griffe.loader import GriffeLoader\n\n    loader = GriffeLoader(...)\n    module = loader.load_module(...)\n    ```\n\n    See the documentation for the loader: [`GriffeLoader`][griffe.loader.GriffeLoader].\n\n    Parameters:\n        module: The module name or path.\n        submodules: Whether to recurse on the submodules.\n        try_relative_path: Whether to try finding the module as a relative path.\n        extensions: The extensions to use.\n        search_paths: The paths to search into.\n        docstring_parser: The docstring parser to use. By default, no parsing is done.\n        docstring_options: Additional docstring parsing options.\n        lines_collection: A collection of source code lines.\n        modules_collection: A collection of modules.\n        allow_inspection: Whether to allow inspecting modules when visiting them is not possible.\n\n    Returns:\n        A loaded module.\n    \"\"\"\n    return GriffeLoader(\n        extensions=extensions,\n        search_paths=search_paths,\n        docstring_parser=docstring_parser,\n        docstring_options=docstring_options,\n        lines_collection=lines_collection,\n        modules_collection=modules_collection,\n        allow_inspection=allow_inspection,\n    ).load_module(\n        module=module,\n        submodules=submodules,\n        try_relative_path=try_relative_path,\n    )\n</code></pre>"},{"location":"reference/griffe/#griffe.load_extensions","title":"load_extensions","text":"<pre><code>load_extensions(\n    exts: Sequence[\n        str\n        | dict[str, Any]\n        | ExtensionType\n        | type[ExtensionType]\n    ]\n) -&gt; Extensions\n</code></pre> <p>Load configured extensions.</p> <p>Parameters:</p> <ul> <li> exts             (<code>Sequence[str | dict[str, Any] | ExtensionType | type[ExtensionType]]</code>)         \u2013          <p>A sequence of extension, with potential configuration options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Extensions</code>         \u2013          <p>An extensions container.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def load_extensions(exts: Sequence[str | dict[str, Any] | ExtensionType | type[ExtensionType]]) -&gt; Extensions:\n\"\"\"Load configured extensions.\n\n    Parameters:\n        exts: A sequence of extension, with potential configuration options.\n\n    Returns:\n        An extensions container.\n    \"\"\"\n    extensions = Extensions()\n    for extension in exts:\n        ext = _load_extension(extension)\n        if isinstance(ext, list):\n            extensions.add(*ext)\n        else:\n            extensions.add(ext)\n    return extensions\n</code></pre>"},{"location":"reference/griffe/#griffe.load_git","title":"load_git","text":"<pre><code>load_git(\n    module: str | Path,\n    *,\n    ref: str = \"HEAD\",\n    repo: str | Path = \".\",\n    submodules: bool = True,\n    extensions: Extensions | None = None,\n    search_paths: Sequence[str | Path] | None = None,\n    docstring_parser: Parser | None = None,\n    docstring_options: dict[str, Any] | None = None,\n    lines_collection: LinesCollection | None = None,\n    modules_collection: ModulesCollection | None = None,\n    allow_inspection: bool = True\n) -&gt; Module\n</code></pre> <p>Load and return a module from a specific Git reference.</p> <p>This function will create a temporary git worktree at the requested reference before loading <code>module</code> with <code>griffe.load</code>.</p> <p>This function requires that the <code>git</code> executable is installed.</p> <p>Parameters:</p> <ul> <li> module             (<code>str | Path</code>)         \u2013          <p>The module path, relative to the repository root.</p> </li> <li> ref             (<code>str</code>, default:                 <code>'HEAD'</code> )         \u2013          <p>A Git reference such as a commit, tag or branch.</p> </li> <li> repo             (<code>str | Path</code>, default:                 <code>'.'</code> )         \u2013          <p>Path to the repository (i.e. the directory containing the <code>.git</code> directory)</p> </li> <li> submodules             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to recurse on the submodules.</p> </li> <li> extensions             (<code>Extensions | None</code>, default:                 <code>None</code> )         \u2013          <p>The extensions to use.</p> </li> <li> search_paths             (<code>Sequence[str | Path] | None</code>, default:                 <code>None</code> )         \u2013          <p>The paths to search into (relative to the repository root).</p> </li> <li> docstring_parser             (<code>Parser | None</code>, default:                 <code>None</code> )         \u2013          <p>The docstring parser to use. By default, no parsing is done.</p> </li> <li> docstring_options             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional docstring parsing options.</p> </li> <li> lines_collection             (<code>LinesCollection | None</code>, default:                 <code>None</code> )         \u2013          <p>A collection of source code lines.</p> </li> <li> modules_collection             (<code>ModulesCollection | None</code>, default:                 <code>None</code> )         \u2013          <p>A collection of modules.</p> </li> <li> allow_inspection             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to allow inspecting modules when visiting them is not possible.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013          <p>A loaded module.</p> </li> </ul> Source code in <code>src/griffe/git.py</code> <pre><code>def load_git(\n    module: str | Path,\n    *,\n    ref: str = \"HEAD\",\n    repo: str | Path = \".\",\n    submodules: bool = True,\n    extensions: Extensions | None = None,\n    search_paths: Sequence[str | Path] | None = None,\n    docstring_parser: Parser | None = None,\n    docstring_options: dict[str, Any] | None = None,\n    lines_collection: LinesCollection | None = None,\n    modules_collection: ModulesCollection | None = None,\n    allow_inspection: bool = True,\n) -&gt; Module:\n\"\"\"Load and return a module from a specific Git reference.\n\n    This function will create a temporary\n    [git worktree](https://git-scm.com/docs/git-worktree) at the requested reference\n    before loading `module` with [`griffe.load`][griffe.loader.load].\n\n    This function requires that the `git` executable is installed.\n\n    Parameters:\n        module: The module path, relative to the repository root.\n        ref: A Git reference such as a commit, tag or branch.\n        repo: Path to the repository (i.e. the directory *containing* the `.git` directory)\n        submodules: Whether to recurse on the submodules.\n        extensions: The extensions to use.\n        search_paths: The paths to search into (relative to the repository root).\n        docstring_parser: The docstring parser to use. By default, no parsing is done.\n        docstring_options: Additional docstring parsing options.\n        lines_collection: A collection of source code lines.\n        modules_collection: A collection of modules.\n        allow_inspection: Whether to allow inspecting modules when visiting them is not possible.\n\n    Returns:\n        A loaded module.\n    \"\"\"\n    with _tmp_worktree(repo, ref) as worktree:\n        search_paths = [worktree / path for path in search_paths or [\".\"]]\n        if isinstance(module, Path):\n            module = worktree / module\n        return loader.load(\n            module=module,\n            submodules=submodules,\n            try_relative_path=False,\n            extensions=extensions,\n            search_paths=search_paths,\n            docstring_parser=docstring_parser,\n            docstring_options=docstring_options,\n            lines_collection=lines_collection,\n            modules_collection=modules_collection,\n            allow_inspection=allow_inspection,\n        )\n</code></pre>"},{"location":"reference/griffe/c3linear/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> c3linear","text":""},{"location":"reference/griffe/c3linear/#griffe.c3linear","title":"c3linear","text":"<p>Compute method resolution order. Implements <code>Class.mro</code> attribute.</p> <p>Functions:</p> <ul> <li> c3linear_merge           \u2013            <p>Merge lists of lists in the order defined by the C3Linear algorithm.</p> </li> </ul>"},{"location":"reference/griffe/c3linear/#griffe.c3linear.c3linear_merge","title":"c3linear_merge","text":"<pre><code>c3linear_merge(*lists: list[T]) -&gt; list[T]\n</code></pre> <p>Merge lists of lists in the order defined by the C3Linear algorithm.</p> <p>Parameters:</p> <ul> <li> *lists             (<code>list[T]</code>, default:                 <code>()</code> )         \u2013          <p>Lists of items.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[T]</code>         \u2013          <p>The merged list of items.</p> </li> </ul> Source code in <code>src/griffe/c3linear.py</code> <pre><code>def c3linear_merge(*lists: list[T]) -&gt; list[T]:\n\"\"\"Merge lists of lists in the order defined by the C3Linear algorithm.\n\n    Parameters:\n        *lists: Lists of items.\n\n    Returns:\n        The merged list of items.\n    \"\"\"\n    result: list[T] = []\n    linearizations = _DependencyList(*lists)  # type: ignore[arg-type]\n\n    while True:\n        if linearizations.exhausted:\n            return result\n\n        for head in linearizations.heads:\n            if head and (head not in linearizations.tails):\n                result.append(head)  # type: ignore[arg-type]\n                linearizations.remove(head)\n\n                # Once candidate is found, continue iteration\n                # from the first element of the list.\n                break\n        else:\n            # Loop never broke, no linearization could possibly be found.\n            raise ValueError(\"Cannot compute C3 linearization\")\n</code></pre>"},{"location":"reference/griffe/cli/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> cli","text":""},{"location":"reference/griffe/cli/#griffe.cli","title":"cli","text":"<p>Module that contains the command line application.</p> <p>Functions:</p> <ul> <li> check           \u2013            <p>Load packages data and dump it as JSON.</p> </li> <li> dump           \u2013            <p>Load packages data and dump it as JSON.</p> </li> <li> get_parser           \u2013            <p>Return the CLI argument parser.</p> </li> <li> main           \u2013            <p>Run the main program.</p> </li> </ul>"},{"location":"reference/griffe/cli/#griffe.cli.check","title":"check","text":"<pre><code>check(\n    package: str | Path,\n    against: str | None = None,\n    against_path: str | Path | None = None,\n    *,\n    base_ref: str | None = None,\n    extensions: Sequence[\n        str\n        | dict[str, Any]\n        | ExtensionType\n        | type[ExtensionType]\n    ]\n    | None = None,\n    search_paths: Sequence[str | Path] | None = None,\n    allow_inspection: bool = True,\n    verbose: bool = False,\n    color: bool | None = None\n) -&gt; int\n</code></pre> <p>Load packages data and dump it as JSON.</p> <p>Parameters:</p> <ul> <li> package             (<code>str | Path</code>)         \u2013          <p>The package to load and check.</p> </li> <li> against             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Older Git reference (commit, branch, tag) to check against.</p> </li> <li> against_path             (<code>str | Path | None</code>, default:                 <code>None</code> )         \u2013          <p>Path when the \"against\" reference is checked out.</p> </li> <li> base_ref             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>Git reference (commit, branch, tag) to check.</p> </li> <li> extensions             (<code>Sequence[str | dict[str, Any] | ExtensionType | type[ExtensionType]] | None</code>, default:                 <code>None</code> )         \u2013          <p>The extensions to use.</p> </li> <li> search_paths             (<code>Sequence[str | Path] | None</code>, default:                 <code>None</code> )         \u2013          <p>The paths to search into.</p> </li> <li> allow_inspection             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to allow inspecting modules when visiting them is not possible.</p> </li> <li> verbose             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Use a verbose output.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013          <p><code>0</code> for success, <code>1</code> for failure.</p> </li> </ul> Source code in <code>src/griffe/cli.py</code> <pre><code>def check(\n    package: str | Path,\n    against: str | None = None,\n    against_path: str | Path | None = None,\n    *,\n    base_ref: str | None = None,\n    extensions: Sequence[str | dict[str, Any] | ExtensionType | type[ExtensionType]] | None = None,\n    search_paths: Sequence[str | Path] | None = None,\n    allow_inspection: bool = True,\n    verbose: bool = False,\n    color: bool | None = None,\n) -&gt; int:\n\"\"\"Load packages data and dump it as JSON.\n\n    Parameters:\n        package: The package to load and check.\n        against: Older Git reference (commit, branch, tag) to check against.\n        against_path: Path when the \"against\" reference is checked out.\n        base_ref: Git reference (commit, branch, tag) to check.\n        extensions: The extensions to use.\n        search_paths: The paths to search into.\n        allow_inspection: Whether to allow inspecting modules when visiting them is not possible.\n        verbose: Use a verbose output.\n\n    Returns:\n        `0` for success, `1` for failure.\n    \"\"\"\n    search_paths = list(search_paths) if search_paths else []\n\n    try:\n        against = against or _get_latest_tag(package)\n    except GitError as error:\n        print(f\"griffe: error: {error}\", file=sys.stderr)\n        return 2\n    against_path = against_path or package\n    repository = _get_repo_root(against_path)\n\n    try:\n        loaded_extensions = load_extensions(extensions or ())\n    except ExtensionError as error:\n        logger.exception(str(error))  # noqa: TRY401\n        return 1\n\n    old_package = load_git(\n        against_path,\n        ref=against,\n        repo=repository,\n        extensions=loaded_extensions,\n        search_paths=search_paths,\n        allow_inspection=allow_inspection,\n    )\n    if base_ref:\n        new_package = load_git(\n            package,\n            ref=base_ref,\n            repo=repository,\n            extensions=loaded_extensions,\n            search_paths=search_paths,\n            allow_inspection=allow_inspection,\n        )\n    else:\n        new_package = load(\n            package,\n            try_relative_path=True,\n            extensions=loaded_extensions,\n            search_paths=search_paths,\n            allow_inspection=allow_inspection,\n        )\n\n    breakages = list(find_breaking_changes(old_package, new_package))\n\n    colorama.deinit()\n    colorama.init(strip=color if color is None else not color)\n    style = ExplanationStyle.VERBOSE if verbose else ExplanationStyle.ONE_LINE\n    for breakage in breakages:\n        print(breakage.explain(style=style), file=sys.stderr)\n\n    if breakages:\n        return 1\n    return 0\n</code></pre>"},{"location":"reference/griffe/cli/#griffe.cli.dump","title":"dump","text":"<pre><code>dump(\n    packages: Sequence[str],\n    *,\n    output: str | IO | None = None,\n    full: bool = False,\n    docstring_parser: Parser | None = None,\n    docstring_options: dict[str, Any] | None = None,\n    extensions: Sequence[\n        str\n        | dict[str, Any]\n        | ExtensionType\n        | type[ExtensionType]\n    ]\n    | None = None,\n    resolve_aliases: bool = False,\n    resolve_implicit: bool = False,\n    resolve_external: bool = False,\n    search_paths: Sequence[str | Path] | None = None,\n    append_sys_path: bool = False,\n    allow_inspection: bool = True,\n    stats: bool = False\n) -&gt; int\n</code></pre> <p>Load packages data and dump it as JSON.</p> <p>Parameters:</p> <ul> <li> packages             (<code>Sequence[str]</code>)         \u2013          <p>The packages to load and dump.</p> </li> <li> output             (<code>str | IO | None</code>, default:                 <code>None</code> )         \u2013          <p>Where to output the JSON-serialized data.</p> </li> <li> full             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to output full or minimal data.</p> </li> <li> docstring_parser             (<code>Parser | None</code>, default:                 <code>None</code> )         \u2013          <p>The docstring parser to use. By default, no parsing is done.</p> </li> <li> docstring_options             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional docstring parsing options.</p> </li> <li> resolve_aliases             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to resolve aliases (indirect objects references).</p> </li> <li> resolve_implicit             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to resolve every alias or only the explicitly exported ones.</p> </li> <li> resolve_external             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to load additional, unspecified modules to resolve aliases.</p> </li> <li> extensions             (<code>Sequence[str | dict[str, Any] | ExtensionType | type[ExtensionType]] | None</code>, default:                 <code>None</code> )         \u2013          <p>The extensions to use.</p> </li> <li> search_paths             (<code>Sequence[str | Path] | None</code>, default:                 <code>None</code> )         \u2013          <p>The paths to search into.</p> </li> <li> append_sys_path             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to append the contents of <code>sys.path</code> to the search paths.</p> </li> <li> allow_inspection             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to allow inspecting modules when visiting them is not possible.</p> </li> <li> stats             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to compute and log stats about loading.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013          <p><code>0</code> for success, <code>1</code> for failure.</p> </li> </ul> Source code in <code>src/griffe/cli.py</code> <pre><code>def dump(\n    packages: Sequence[str],\n    *,\n    output: str | IO | None = None,\n    full: bool = False,\n    docstring_parser: Parser | None = None,\n    docstring_options: dict[str, Any] | None = None,\n    extensions: Sequence[str | dict[str, Any] | ExtensionType | type[ExtensionType]] | None = None,\n    resolve_aliases: bool = False,\n    resolve_implicit: bool = False,\n    resolve_external: bool = False,\n    search_paths: Sequence[str | Path] | None = None,\n    append_sys_path: bool = False,\n    allow_inspection: bool = True,\n    stats: bool = False,\n) -&gt; int:\n\"\"\"Load packages data and dump it as JSON.\n\n    Parameters:\n        packages: The packages to load and dump.\n        output: Where to output the JSON-serialized data.\n        full: Whether to output full or minimal data.\n        docstring_parser: The docstring parser to use. By default, no parsing is done.\n        docstring_options: Additional docstring parsing options.\n        resolve_aliases: Whether to resolve aliases (indirect objects references).\n        resolve_implicit: Whether to resolve every alias or only the explicitly exported ones.\n        resolve_external: Whether to load additional, unspecified modules to resolve aliases.\n        extensions: The extensions to use.\n        search_paths: The paths to search into.\n        append_sys_path: Whether to append the contents of `sys.path` to the search paths.\n        allow_inspection: Whether to allow inspecting modules when visiting them is not possible.\n        stats: Whether to compute and log stats about loading.\n\n    Returns:\n        `0` for success, `1` for failure.\n    \"\"\"\n    per_package_output = False\n    if isinstance(output, str) and output.format(package=\"package\") != output:\n        per_package_output = True\n\n    search_paths = list(search_paths) if search_paths else []\n    if append_sys_path:\n        search_paths.extend(sys.path)\n\n    try:\n        loaded_extensions = load_extensions(extensions or ())\n    except ExtensionError as error:\n        logger.exception(str(error))  # noqa: TRY401\n        return 1\n\n    loader = _load_packages(\n        packages,\n        extensions=loaded_extensions,\n        search_paths=search_paths,\n        docstring_parser=docstring_parser,\n        docstring_options=docstring_options,\n        resolve_aliases=resolve_aliases,\n        resolve_implicit=resolve_implicit,\n        resolve_external=resolve_external,\n        allow_inspection=allow_inspection,\n        store_source=False,\n    )\n    data_packages = loader.modules_collection.members\n\n    started = datetime.now(tz=timezone.utc)\n    if per_package_output:\n        for package_name, data in data_packages.items():\n            serialized = data.as_json(indent=2, full=full)\n            _print_data(serialized, output.format(package=package_name))  # type: ignore[union-attr]\n    else:\n        serialized = json.dumps(data_packages, cls=JSONEncoder, indent=2, full=full)\n        _print_data(serialized, output)\n    elapsed = datetime.now(tz=timezone.utc) - started\n\n    if stats:\n        logger.info(_format_stats({\"time_spent_serializing\": elapsed.microseconds, **loader.stats()}))\n\n    return 0 if len(data_packages) == len(packages) else 1\n</code></pre>"},{"location":"reference/griffe/cli/#griffe.cli.get_parser","title":"get_parser","text":"<pre><code>get_parser() -&gt; ArgumentParser\n</code></pre> <p>Return the CLI argument parser.</p> <p>Returns:</p> <ul> <li> <code>ArgumentParser</code>         \u2013          <p>An argparse parser.</p> </li> </ul> Source code in <code>src/griffe/cli.py</code> <pre><code>def get_parser() -&gt; argparse.ArgumentParser:\n\"\"\"Return the CLI argument parser.\n\n    Returns:\n        An argparse parser.\n    \"\"\"\n    usage = \"%(prog)s [GLOBAL_OPTS...] COMMAND [COMMAND_OPTS...]\"\n    description = \"Signatures for entire Python programs. \"\n    \"Extract the structure, the frame, the skeleton of your project, \"\n    \"to generate API documentation or find breaking changes in your API.\"\n    parser = argparse.ArgumentParser(add_help=False, usage=usage, description=description, prog=\"griffe\")\n\n    main_help = \"Show this help message and exit. Commands also accept the -h/--help option.\"\n    subcommand_help = \"Show this help message and exit.\"\n\n    global_options = parser.add_argument_group(title=\"Global options\")\n    global_options.add_argument(\"-h\", \"--help\", action=\"help\", help=main_help)\n    global_options.add_argument(\"-V\", \"--version\", action=\"version\", version=\"%(prog)s \" + _get_griffe_version())\n\n    def add_common_options(subparser: argparse.ArgumentParser) -&gt; None:\n        common_options = subparser.add_argument_group(title=\"Common options\")\n        common_options.add_argument(\"-h\", \"--help\", action=\"help\", help=subcommand_help)\n        search_options = subparser.add_argument_group(title=\"Search options\")\n        search_options.add_argument(\n            \"-s\",\n            \"--search\",\n            dest=\"search_paths\",\n            action=\"append\",\n            type=Path,\n            help=\"Paths to search packages into.\",\n        )\n        loading_options = subparser.add_argument_group(title=\"Loading options\")\n        loading_options.add_argument(\n            \"-e\",\n            \"--extensions\",\n            default={},\n            type=_extensions_type,\n            help=\"A list of extensions to use.\",\n        )\n        loading_options.add_argument(\n            \"-X\",\n            \"--no-inspection\",\n            dest=\"allow_inspection\",\n            action=\"store_false\",\n            default=True,\n            help=\"Disallow inspection of builtin/compiled/not found modules.\",\n        )\n        debug_options = subparser.add_argument_group(title=\"Debugging options\")\n        debug_options.add_argument(\n            \"-L\",\n            \"--log-level\",\n            metavar=\"LEVEL\",\n            default=DEFAULT_LOG_LEVEL,\n            choices=_level_choices,\n            type=str.upper,\n            help=\"Set the log level: `DEBUG`, `INFO`, `WARNING`, `ERROR`, `CRITICAL`.\",\n        )\n\n    # ========= SUBPARSERS ========= #\n    subparsers = parser.add_subparsers(\n        dest=\"subcommand\",\n        title=\"Commands\",\n        metavar=\"COMMAND\",\n        prog=\"griffe\",\n        required=True,\n    )\n\n    def add_subparser(command: str, text: str, **kwargs: Any) -&gt; argparse.ArgumentParser:\n        return subparsers.add_parser(command, add_help=False, help=text, description=text, **kwargs)\n\n    # ========= DUMP PARSER ========= #\n    dump_parser = add_subparser(\"dump\", \"Load package-signatures and dump them as JSON.\")\n    dump_options = dump_parser.add_argument_group(title=\"Dump options\")\n    dump_options.add_argument(\"packages\", metavar=\"PACKAGE\", nargs=\"+\", help=\"Packages to find, load and dump.\")\n    dump_options.add_argument(\n        \"-f\",\n        \"--full\",\n        action=\"store_true\",\n        default=False,\n        help=\"Whether to dump full data in JSON.\",\n    )\n    dump_options.add_argument(\n        \"-o\",\n        \"--output\",\n        default=sys.stdout,\n        help=\"Output file. Supports templating to output each package in its own file, with `{package}`.\",\n    )\n    dump_options.add_argument(\n        \"-d\",\n        \"--docstyle\",\n        dest=\"docstring_parser\",\n        default=None,\n        type=Parser,\n        help=\"The docstring style to parse.\",\n    )\n    dump_options.add_argument(\n        \"-D\",\n        \"--docopts\",\n        dest=\"docstring_options\",\n        default={},\n        type=json.loads,\n        help=\"The options for the docstring parser.\",\n    )\n    dump_options.add_argument(\n        \"-y\",\n        \"--sys-path\",\n        dest=\"append_sys_path\",\n        action=\"store_true\",\n        help=\"Whether to append `sys.path` to search paths specified with `-s`.\",\n    )\n    dump_options.add_argument(\n        \"-r\",\n        \"--resolve-aliases\",\n        action=\"store_true\",\n        help=\"Whether to resolve aliases.\",\n    )\n    dump_options.add_argument(\n        \"-I\",\n        \"--resolve-implicit\",\n        action=\"store_true\",\n        help=\"Whether to resolve implicitely exported aliases as well. \"\n        \"Aliases are explicitely exported when defined in `__all__`.\",\n    )\n    dump_options.add_argument(\n        \"-U\",\n        \"--resolve-external\",\n        action=\"store_true\",\n        help=\"Whether to resolve aliases pointing to external/unknown modules (not loaded directly).\",\n    )\n    dump_options.add_argument(\n        \"-S\",\n        \"--stats\",\n        action=\"store_true\",\n        help=\"Show statistics at the end.\",\n    )\n    add_common_options(dump_parser)\n\n    # ========= CHECK PARSER ========= #\n    check_parser = add_subparser(\"check\", \"Check for API breakages or possible improvements.\")\n    check_options = check_parser.add_argument_group(title=\"Check options\")\n    check_options.add_argument(\"package\", metavar=\"PACKAGE\", help=\"Package to find, load and check, as path.\")\n    check_options.add_argument(\n        \"-a\",\n        \"--against\",\n        metavar=\"REF\",\n        help=\"Older Git reference (commit, branch, tag) to check against. Default: load latest tag.\",\n    )\n    check_options.add_argument(\n        \"-b\",\n        \"--base-ref\",\n        metavar=\"BASE_REF\",\n        help=\"Git reference (commit, branch, tag) to check. Default: load current code.\",\n    )\n    check_options.add_argument(\n        \"--color\",\n        dest=\"color\",\n        action=\"store_true\",\n        default=None,\n        help=\"Force enable colors in the output.\",\n    )\n    check_options.add_argument(\n        \"--no-color\",\n        dest=\"color\",\n        action=\"store_false\",\n        default=None,\n        help=\"Force disable colors in the output.\",\n    )\n    check_options.add_argument(\"-v\", \"--verbose\", action=\"store_true\", help=\"Verbose output.\")\n    add_common_options(check_parser)\n\n    return parser\n</code></pre>"},{"location":"reference/griffe/cli/#griffe.cli.main","title":"main","text":"<pre><code>main(args: list[str] | None = None) -&gt; int\n</code></pre> <p>Run the main program.</p> <p>This function is executed when you type <code>griffe</code> or <code>python -m griffe</code>.</p> <p>Parameters:</p> <ul> <li> args             (<code>list[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Arguments passed from the command line.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013          <p>An exit code.</p> </li> </ul> Source code in <code>src/griffe/cli.py</code> <pre><code>def main(args: list[str] | None = None) -&gt; int:\n\"\"\"Run the main program.\n\n    This function is executed when you type `griffe` or `python -m griffe`.\n\n    Parameters:\n        args: Arguments passed from the command line.\n\n    Returns:\n        An exit code.\n    \"\"\"\n    parser = get_parser()\n    opts: argparse.Namespace = parser.parse_args(args)\n    opts_dict = opts.__dict__\n    subcommand = opts_dict.pop(\"subcommand\")\n\n    log_level = opts_dict.pop(\"log_level\", DEFAULT_LOG_LEVEL)\n    try:\n        level = getattr(logging, log_level)\n    except AttributeError:\n        choices = \"', '\".join(_level_choices)\n        print(\n            f\"griffe: error: invalid log level '{log_level}' (choose from '{choices}')\",\n            file=sys.stderr,\n        )\n        return 1\n    else:\n        logging.basicConfig(format=\"%(levelname)-10s %(message)s\", level=level)\n\n    commands: dict[str, Callable[..., int]] = {\"check\": check, \"dump\": dump}\n    return commands[subcommand](**opts_dict)\n</code></pre>"},{"location":"reference/griffe/collections/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> collections","text":""},{"location":"reference/griffe/collections/#griffe.collections","title":"collections","text":"<p>This module stores collections of data, useful during parsing.</p> <p>Classes:</p> <ul> <li> LinesCollection         \u2013          <p>A simple dictionary containing the modules source code lines.</p> </li> <li> ModulesCollection         \u2013          <p>A collection of modules, allowing easy access to members.</p> </li> </ul>"},{"location":"reference/griffe/collections/#griffe.collections.LinesCollection","title":"LinesCollection","text":"<pre><code>LinesCollection()\n</code></pre> <p>A simple dictionary containing the modules source code lines.</p> <p>Methods:</p> <ul> <li> items           \u2013            <p>Return the collection items.</p> </li> <li> keys           \u2013            <p>Return the collection keys.</p> </li> <li> values           \u2013            <p>Return the collection values.</p> </li> </ul> Source code in <code>src/griffe/collections.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Initialize the collection.\"\"\"\n    self._data: dict[Path, list[str]] = {}\n</code></pre>"},{"location":"reference/griffe/collections/#griffe.collections.LinesCollection.items","title":"items","text":"<pre><code>items() -&gt; ItemsView\n</code></pre> <p>Return the collection items.</p> <p>Returns:</p> <ul> <li> <code>ItemsView</code>         \u2013          <p>The collection items.</p> </li> </ul> Source code in <code>src/griffe/collections.py</code> <pre><code>def items(self) -&gt; ItemsView:\n\"\"\"Return the collection items.\n\n    Returns:\n        The collection items.\n    \"\"\"\n    return self._data.items()\n</code></pre>"},{"location":"reference/griffe/collections/#griffe.collections.LinesCollection.keys","title":"keys","text":"<pre><code>keys() -&gt; KeysView\n</code></pre> <p>Return the collection keys.</p> <p>Returns:</p> <ul> <li> <code>KeysView</code>         \u2013          <p>The collection keys.</p> </li> </ul> Source code in <code>src/griffe/collections.py</code> <pre><code>def keys(self) -&gt; KeysView:\n\"\"\"Return the collection keys.\n\n    Returns:\n        The collection keys.\n    \"\"\"\n    return self._data.keys()\n</code></pre>"},{"location":"reference/griffe/collections/#griffe.collections.LinesCollection.values","title":"values","text":"<pre><code>values() -&gt; ValuesView\n</code></pre> <p>Return the collection values.</p> <p>Returns:</p> <ul> <li> <code>ValuesView</code>         \u2013          <p>The collection values.</p> </li> </ul> Source code in <code>src/griffe/collections.py</code> <pre><code>def values(self) -&gt; ValuesView:\n\"\"\"Return the collection values.\n\n    Returns:\n        The collection values.\n    \"\"\"\n    return self._data.values()\n</code></pre>"},{"location":"reference/griffe/collections/#griffe.collections.ModulesCollection","title":"ModulesCollection","text":"<pre><code>ModulesCollection()\n</code></pre> <p>             Bases: <code>GetMembersMixin</code>, <code>SetMembersMixin</code></p> <p>A collection of modules, allowing easy access to members.</p> <p>Methods:</p> <ul> <li> __delitem__           \u2013            <p>Delete a member with its name or path.</p> </li> <li> __getitem__           \u2013            <p>Get a member with its name or path.</p> </li> <li> __setitem__           \u2013            <p>Set a member with its name or path.</p> </li> <li> del_member           \u2013            <p>Delete a member with its name or path.</p> </li> <li> get_member           \u2013            <p>Get a member with its name or path.</p> </li> <li> set_member           \u2013            <p>Set a member with its name or path.</p> </li> </ul> Source code in <code>src/griffe/collections.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Initialize the collection.\"\"\"\n    self.members: dict[str, Module] = {}\n</code></pre>"},{"location":"reference/griffe/collections/#griffe.collections.ModulesCollection.__delitem__","title":"__delitem__","text":"<pre><code>__delitem__(key: str | Sequence[str]) -&gt; None\n</code></pre> <p>Delete a member with its name or path.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Members will be looked up in both declared members and inherited ones, triggering computation of the latter.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; del griffe_object[\"foo\"]\n&gt;&gt;&gt; del griffe_object[\"path.to.bar\"]\n&gt;&gt;&gt; del griffe_object[(\"path\", \"to\", \"qux\")]\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def __delitem__(self, key: str | Sequence[str]) -&gt; None:\n\"\"\"Delete a member with its name or path.\n\n    This method is part of the consumer API:\n    do not use when producing Griffe trees!\n\n    Members will be looked up in both declared members and inherited ones,\n    triggering computation of the latter.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; del griffe_object[\"foo\"]\n        &gt;&gt;&gt; del griffe_object[\"path.to.bar\"]\n        &gt;&gt;&gt; del griffe_object[(\"path\", \"to\", \"qux\")]\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        try:\n            del self.members[name]  # type: ignore[attr-defined]\n        except KeyError:\n            del self.inherited_members[name]  # type: ignore[attr-defined]\n    else:\n        del self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/collections/#griffe.collections.ModulesCollection.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key: str | Sequence[str]) -&gt; Any\n</code></pre> <p>Get a member with its name or path.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Members will be looked up in both declared members and inherited ones, triggering computation of the latter.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; foo = griffe_object[\"foo\"]\n&gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n&gt;&gt;&gt; qux = griffe_object[(\"path\", \"to\", \"qux\")]\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def __getitem__(self, key: str | Sequence[str]) -&gt; Any:\n\"\"\"Get a member with its name or path.\n\n    This method is part of the consumer API:\n    do not use when producing Griffe trees!\n\n    Members will be looked up in both declared members and inherited ones,\n    triggering computation of the latter.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; foo = griffe_object[\"foo\"]\n        &gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n        &gt;&gt;&gt; qux = griffe_object[(\"path\", \"to\", \"qux\")]\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        return self.all_members[parts[0]]  # type: ignore[attr-defined]\n    return self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/collections/#griffe.collections.ModulesCollection.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(\n    key: str | Sequence[str], value: Object | Alias\n) -&gt; None\n</code></pre> <p>Set a member with its name or path.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> <li> value             (<code>Object | Alias</code>)         \u2013          <p>The member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; griffe_object[\"foo\"] = foo\n&gt;&gt;&gt; griffe_object[\"path.to.bar\"] = bar\n&gt;&gt;&gt; griffe_object[(\"path\", \"to\", \"qux\")] = qux\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def __setitem__(self, key: str | Sequence[str], value: Object | Alias) -&gt; None:\n\"\"\"Set a member with its name or path.\n\n    This method is part of the consumer API:\n    do not use when producing Griffe trees!\n\n    Parameters:\n        key: The name or path of the member.\n        value: The member.\n\n    Examples:\n        &gt;&gt;&gt; griffe_object[\"foo\"] = foo\n        &gt;&gt;&gt; griffe_object[\"path.to.bar\"] = bar\n        &gt;&gt;&gt; griffe_object[(\"path\", \"to\", \"qux\")] = qux\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        self.members[name] = value  # type: ignore[attr-defined]\n        if self.is_collection:  # type: ignore[attr-defined]\n            value._modules_collection = self  # type: ignore[union-attr]\n        else:\n            value.parent = self  # type: ignore[assignment]\n    else:\n        self.members[parts[0]][parts[1:]] = value  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/collections/#griffe.collections.ModulesCollection.del_member","title":"del_member","text":"<pre><code>del_member(key: str | Sequence[str]) -&gt; None\n</code></pre> <p>Delete a member with its name or path.</p> <p>This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).</p> <p>Members will be looked up in declared members only, not inherited ones.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; griffe_object.del_member(\"foo\")\n&gt;&gt;&gt; griffe_object.del_member(\"path.to.bar\")\n&gt;&gt;&gt; griffe_object.del_member((\"path\", \"to\", \"qux\"))\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def del_member(self, key: str | Sequence[str]) -&gt; None:\n\"\"\"Delete a member with its name or path.\n\n    This method is part of the producer API:\n    you can use it safely while building Griffe trees\n    (for example in Griffe extensions).\n\n    Members will be looked up in declared members only, not inherited ones.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; griffe_object.del_member(\"foo\")\n        &gt;&gt;&gt; griffe_object.del_member(\"path.to.bar\")\n        &gt;&gt;&gt; griffe_object.del_member((\"path\", \"to\", \"qux\"))\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        del self.members[name]  # type: ignore[attr-defined]\n    else:\n        self.members[parts[0]].del_member(parts[1:])  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/collections/#griffe.collections.ModulesCollection.get_member","title":"get_member","text":"<pre><code>get_member(key: str | Sequence[str]) -&gt; Any\n</code></pre> <p>Get a member with its name or path.</p> <p>This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).</p> <p>Members will be looked up in declared members only, not inherited ones.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; foo = griffe_object[\"foo\"]\n&gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n&gt;&gt;&gt; bar = griffe_object[(\"path\", \"to\", \"bar\")]\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def get_member(self, key: str | Sequence[str]) -&gt; Any:\n\"\"\"Get a member with its name or path.\n\n    This method is part of the producer API:\n    you can use it safely while building Griffe trees\n    (for example in Griffe extensions).\n\n    Members will be looked up in declared members only, not inherited ones.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; foo = griffe_object[\"foo\"]\n        &gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n        &gt;&gt;&gt; bar = griffe_object[(\"path\", \"to\", \"bar\")]\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        return self.members[parts[0]]  # type: ignore[attr-defined]\n    return self.members[parts[0]].get_member(parts[1:])  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/collections/#griffe.collections.ModulesCollection.set_member","title":"set_member","text":"<pre><code>set_member(\n    key: str | Sequence[str], value: Object | Alias\n) -&gt; None\n</code></pre> <p>Set a member with its name or path.</p> <p>This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> <li> value             (<code>Object | Alias</code>)         \u2013          <p>The member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; griffe_object.set_member(\"foo\", foo)\n&gt;&gt;&gt; griffe_object.set_member(\"path.to.bar\", bar)\n&gt;&gt;&gt; griffe_object.set_member((\"path\", \"to\", \"qux\", qux)\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def set_member(self, key: str | Sequence[str], value: Object | Alias) -&gt; None:\n\"\"\"Set a member with its name or path.\n\n    This method is part of the producer API:\n    you can use it safely while building Griffe trees\n    (for example in Griffe extensions).\n\n    Parameters:\n        key: The name or path of the member.\n        value: The member.\n\n    Examples:\n        &gt;&gt;&gt; griffe_object.set_member(\"foo\", foo)\n        &gt;&gt;&gt; griffe_object.set_member(\"path.to.bar\", bar)\n        &gt;&gt;&gt; griffe_object.set_member((\"path\", \"to\", \"qux\", qux)\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        if name in self.members:  # type: ignore[attr-defined]\n            member = self.members[name]  # type: ignore[attr-defined]\n            if not member.is_alias:\n                # when reassigning a module to an existing one,\n                # try to merge them as one regular and one stubs module\n                # (implicit support for .pyi modules)\n                if member.is_module and not (member.is_namespace_package or member.is_namespace_subpackage):\n                    with suppress(AliasResolutionError, CyclicAliasError):\n                        if value.is_module and value.filepath != member.filepath:\n                            with suppress(ValueError):\n                                value = merge_stubs(member, value)  # type: ignore[arg-type]\n                for alias in member.aliases.values():\n                    with suppress(CyclicAliasError):\n                        alias.target = value\n        self.members[name] = value  # type: ignore[attr-defined]\n        if self.is_collection:  # type: ignore[attr-defined]\n            value._modules_collection = self  # type: ignore[union-attr]\n        else:\n            value.parent = self  # type: ignore[assignment]\n    else:\n        self.members[parts[0]].set_member(parts[1:], value)  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/dataclasses/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> dataclasses","text":""},{"location":"reference/griffe/dataclasses/#griffe.dataclasses","title":"dataclasses","text":"<p>This module contains the data classes that represent Python objects.</p> <p>The different objects are modules, classes, functions, and attribute (variables like module/class/instance attributes).</p> <p>Classes:</p> <ul> <li> Alias         \u2013          <p>This class represents an alias, or indirection, to an object declared in another module.</p> </li> <li> Attribute         \u2013          <p>The class representing a Python module/class/instance attribute.</p> </li> <li> Class         \u2013          <p>The class representing a Python class.</p> </li> <li> Decorator         \u2013          <p>This class represents decorators.</p> </li> <li> Docstring         \u2013          <p>This class represents docstrings.</p> </li> <li> Function         \u2013          <p>The class representing a Python function.</p> </li> <li> Kind         \u2013          <p>Enumeration of the different objects kinds.</p> </li> <li> Module         \u2013          <p>The class representing a Python module.</p> </li> <li> Object         \u2013          <p>An abstract class representing a Python object.</p> </li> <li> Parameter         \u2013          <p>This class represent a function parameter.</p> </li> <li> ParameterKind         \u2013          <p>Enumeration of the different parameter kinds.</p> </li> <li> Parameters         \u2013          <p>This class is a container for parameters.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias","title":"Alias","text":"<pre><code>Alias(\n    name: str,\n    target: str | Object | Alias,\n    *,\n    lineno: int | None = None,\n    endlineno: int | None = None,\n    runtime: bool = True,\n    parent: Module | Class | Alias | None = None,\n    inherited: bool = False\n)\n</code></pre> <p>             Bases: <code>ObjectAliasMixin</code></p> <p>This class represents an alias, or indirection, to an object declared in another module.</p> <p>Aliases represent objects that are in the scope of a module or class, but were imported from another module.</p> <p>They behave almost exactly like regular objects, to a few exceptions:</p> <ul> <li>line numbers are those of the alias, not the target</li> <li>the path is the alias path, not the canonical one</li> <li>the name can be different from the target's</li> <li>if the target can be resolved, the kind is the target's kind</li> <li>if the target cannot be resolved, the kind becomes Kind.ALIAS</li> </ul> <p>Attributes:</p> <ul> <li> name             (<code>str</code>)         \u2013          <p>The alias name.</p> </li> <li> lineno             (<code>int | None</code>)         \u2013          <p>The alias starting line number.</p> </li> <li> endlineno             (<code>int | None</code>)         \u2013          <p>The alias ending line number.</p> </li> <li> parent             (<code>Module | Class | Alias | None</code>)         \u2013          <p>The alias parent.</p> </li> <li> target_path             (<code>str</code>)         \u2013          <p>The alias target path.</p> </li> </ul> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013          <p>The alias name.</p> </li> <li> target             (<code>str | Object | Alias</code>)         \u2013          <p>If it's a string, the target resolution is delayed until accessing the target property. If it's an object, or even another alias, the target is immediately set.</p> </li> <li> lineno             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>The alias starting line number.</p> </li> <li> endlineno             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>The alias ending line number.</p> </li> <li> runtime             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether this alias is present at runtime or not.</p> </li> <li> parent             (<code>Module | Class | Alias | None</code>, default:                 <code>None</code> )         \u2013          <p>The alias parent.</p> </li> <li> inherited             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether this alias wraps an inherited member.</p> </li> </ul> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this alias' data as a dictionary.</p> </li> <li> is_exported           \u2013            <p>Tell if this object/alias is implicitely exported by its parent.</p> </li> <li> is_public           \u2013            <p>Whether this object is considered public.</p> </li> <li> resolve_target           \u2013            <p>Resolve the target.</p> </li> </ul> <p>Attributes:</p> <ul> <li> all_members             (<code>dict[str, Object | Alias]</code>)         \u2013          <p>All members (declared and inherited).</p> </li> <li> attributes             (<code>dict[str, Attribute]</code>)         \u2013          <p>Return the attribute members.</p> </li> <li> classes             (<code>dict[str, Class]</code>)         \u2013          <p>Return the class members.</p> </li> <li> endlineno             (<code>int | None</code>)         \u2013          <p>Return the target endlineno or the alias endlineno.</p> </li> <li> final_target             (<code>Object</code>)         \u2013          <p>Resolve and return the final target, if possible.</p> </li> <li> functions             (<code>dict[str, Function]</code>)         \u2013          <p>Return the function members.</p> </li> <li> has_docstring             (<code>bool</code>)         \u2013          <p>Tell if this alias' target has a non-empty docstring.</p> </li> <li> has_docstrings             (<code>bool</code>)         \u2013          <p>Tell if this alias' target or any of its members has a non-empty docstring.</p> </li> <li> is_explicitely_exported             (<code>bool</code>)         \u2013          <p>Tell if this object/alias is explicitely exported by its parent.</p> </li> <li> is_implicitely_exported             (<code>bool</code>)         \u2013          <p>Tell if this object/alias is implicitely exported by its parent.</p> </li> <li> kind             (<code>Kind</code>)         \u2013          <p>Return the target's kind, or Kind.ALIAS if the target cannot be resolved.</p> </li> <li> lineno             (<code>int | None</code>)         \u2013          <p>Return the target lineno or the alias lineno.</p> </li> <li> modules             (<code>dict[str, Module]</code>)         \u2013          <p>Return the module members.</p> </li> <li> modules_collection             (<code>ModulesCollection</code>)         \u2013          <p>Return the modules collection attached to the alias parents.</p> </li> <li> parent             (<code>Module | Class | Alias | None</code>)         \u2013          <p>Return the parent of this alias.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Return the dotted path / import path of this object.</p> </li> <li> resolved             (<code>bool</code>)         \u2013          <p>Tell whether this alias' target is resolved.</p> </li> <li> target             (<code>Object | Alias</code>)         \u2013          <p>Resolve and return the target, if possible.</p> </li> <li> wildcard             (<code>str | None</code>)         \u2013          <p>Return the module on which the wildcard import is performed (if any).</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    target: str | Object | Alias,\n    *,\n    lineno: int | None = None,\n    endlineno: int | None = None,\n    runtime: bool = True,\n    parent: Module | Class | Alias | None = None,\n    inherited: bool = False,\n) -&gt; None:\n\"\"\"Initialize the alias.\n\n    Parameters:\n        name: The alias name.\n        target: If it's a string, the target resolution is delayed until accessing the target property.\n            If it's an object, or even another alias, the target is immediately set.\n        lineno: The alias starting line number.\n        endlineno: The alias ending line number.\n        runtime: Whether this alias is present at runtime or not.\n        parent: The alias parent.\n        inherited: Whether this alias wraps an inherited member.\n    \"\"\"\n    self.name: str = name\n    self.alias_lineno: int | None = lineno\n    self.alias_endlineno: int | None = endlineno\n    self.runtime: bool = runtime\n    self.inherited: bool = inherited\n    self.public: bool | None = None\n    self._parent: Module | Class | Alias | None = parent\n    self._passed_through: bool = False\n    if isinstance(target, str):\n        self._target: Object | Alias | None = None\n        self.target_path: str = target\n    else:\n        self._target = target\n        self.target_path = target.path\n        self._update_target_aliases()\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.all_members","title":"all_members  <code>property</code>","text":"<pre><code>all_members: dict[str, Object | Alias]\n</code></pre> <p>All members (declared and inherited).</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.attributes","title":"attributes  <code>property</code>","text":"<pre><code>attributes: dict[str, Attribute]\n</code></pre> <p>Return the attribute members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Attribute]</code>         \u2013          <p>A dictionary of attributes.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.classes","title":"classes  <code>property</code>","text":"<pre><code>classes: dict[str, Class]\n</code></pre> <p>Return the class members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Class]</code>         \u2013          <p>A dictionary of classes.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.endlineno","title":"endlineno  <code>property</code>","text":"<pre><code>endlineno: int | None\n</code></pre> <p>Return the target endlineno or the alias endlineno.</p> <p>Returns:</p> <ul> <li> <code>int | None</code>         \u2013          <p>The target endlineno or the alias endlineno.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.final_target","title":"final_target  <code>property</code>","text":"<pre><code>final_target: Object\n</code></pre> <p>Resolve and return the final target, if possible.</p> <p>This will iterate through the targets until a non-alias object is found.</p> <p>Returns:</p> <ul> <li> <code>Object</code>         \u2013          <p>The final target.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.functions","title":"functions  <code>property</code>","text":"<pre><code>functions: dict[str, Function]\n</code></pre> <p>Return the function members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Function]</code>         \u2013          <p>A dictionary of functions.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.has_docstring","title":"has_docstring  <code>property</code>","text":"<pre><code>has_docstring: bool\n</code></pre> <p>Tell if this alias' target has a non-empty docstring.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.has_docstrings","title":"has_docstrings  <code>property</code>","text":"<pre><code>has_docstrings: bool\n</code></pre> <p>Tell if this alias' target or any of its members has a non-empty docstring.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.is_explicitely_exported","title":"is_explicitely_exported  <code>property</code>","text":"<pre><code>is_explicitely_exported: bool\n</code></pre> <p>Tell if this object/alias is explicitely exported by its parent.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.is_implicitely_exported","title":"is_implicitely_exported  <code>property</code>","text":"<pre><code>is_implicitely_exported: bool\n</code></pre> <p>Tell if this object/alias is implicitely exported by its parent.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.kind","title":"kind  <code>property</code>","text":"<pre><code>kind: Kind\n</code></pre> <p>Return the target's kind, or Kind.ALIAS if the target cannot be resolved.</p> <p>Returns:</p> <ul> <li> <code>Kind</code>         \u2013          <p>A kind.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.lineno","title":"lineno  <code>property</code>","text":"<pre><code>lineno: int | None\n</code></pre> <p>Return the target lineno or the alias lineno.</p> <p>Returns:</p> <ul> <li> <code>int | None</code>         \u2013          <p>The target lineno or the alias lineno.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.modules","title":"modules  <code>property</code>","text":"<pre><code>modules: dict[str, Module]\n</code></pre> <p>Return the module members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Module]</code>         \u2013          <p>A dictionary of modules.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.modules_collection","title":"modules_collection  <code>property</code>","text":"<pre><code>modules_collection: ModulesCollection\n</code></pre> <p>Return the modules collection attached to the alias parents.</p> <p>Returns:</p> <ul> <li> <code>ModulesCollection</code>         \u2013          <p>A modules collection.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.parent","title":"parent  <code>property</code> <code>writable</code>","text":"<pre><code>parent: Module | Class | Alias | None\n</code></pre> <p>Return the parent of this alias.</p> <p>Returns:</p> <ul> <li> <code>Module | Class | Alias | None</code>         \u2013          <p>The parent.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Return the dotted path / import path of this object.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>A dotted path.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.resolved","title":"resolved  <code>property</code>","text":"<pre><code>resolved: bool\n</code></pre> <p>Tell whether this alias' target is resolved.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.target","title":"target  <code>property</code> <code>writable</code>","text":"<pre><code>target: Object | Alias\n</code></pre> <p>Resolve and return the target, if possible.</p> <p>Upon accessing this property, if the target is not already resolved, a lookup is done using the modules collection to find the target.</p> <p>Returns:</p> <ul> <li> <code>Object | Alias</code>         \u2013          <p>The resolved target.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.wildcard","title":"wildcard  <code>property</code>","text":"<pre><code>wildcard: str | None\n</code></pre> <p>Return the module on which the wildcard import is performed (if any).</p> <p>Returns:</p> <ul> <li> <code>str | None</code>         \u2013          <p>The wildcard imported module, or None.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.as_dict","title":"as_dict","text":"<pre><code>as_dict(\n    *, full: bool = False, **kwargs: Any\n) -&gt; dict[str, Any]\n</code></pre> <p>Return this alias' data as a dictionary.</p> <p>Parameters:</p> <ul> <li> full             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to return full info, or just base info.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def as_dict(self, *, full: bool = False, **kwargs: Any) -&gt; dict[str, Any]:  # noqa: ARG002\n\"\"\"Return this alias' data as a dictionary.\n\n    Parameters:\n        full: Whether to return full info, or just base info.\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    base = {\n        \"kind\": Kind.ALIAS,\n        \"name\": self.name,\n        \"target_path\": self.target_path,\n    }\n\n    if full:\n        base[\"path\"] = self.path\n\n    if self.alias_lineno:\n        base[\"lineno\"] = self.alias_lineno\n    if self.alias_endlineno:\n        base[\"endlineno\"] = self.alias_endlineno\n\n    return base\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.is_exported","title":"is_exported","text":"<pre><code>is_exported(*, explicitely: bool = True) -&gt; bool\n</code></pre> <p>Tell if this object/alias is implicitely exported by its parent.</p> <p>Parameters:</p> <ul> <li> explicitely             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to only return True when <code>__all__</code> is defined.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>def is_exported(self, *, explicitely: bool = True) -&gt; bool:\n\"\"\"Tell if this object/alias is implicitely exported by its parent.\n\n    Parameters:\n        explicitely: Whether to only return True when `__all__` is defined.\n\n    Returns:\n        True or False.\n    \"\"\"\n    return self.parent.member_is_exported(self, explicitely=explicitely)  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.is_public","title":"is_public","text":"<pre><code>is_public(\n    *, strict: bool = False, check_name: bool = True\n) -&gt; bool\n</code></pre> <p>Whether this object is considered public.</p> <p>In modules, developers can mark objects as public thanks to the <code>__all__</code> variable. In classes however, there is no convention or standard to do so.</p> <p>Therefore, to decide whether an object is public, we follow this algorithm:</p> <ul> <li>If the object's <code>public</code> attribute is set (boolean), return its value.</li> <li>In strict mode, the object is public only if it is explicitely exported (listed in <code>__all__</code>).     Strict mode should only be used for module members.</li> <li>Otherwise, if name checks are enabled, the object is private if its name starts with an underscore.</li> <li>Otherwise, if the object is an alias, and is neither inherited from a base class,     nor a member of a parent alias, it is not public.</li> <li>Otherwise, the object is public.</li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>def is_public(\n    self,\n    *,\n    strict: bool = False,\n    check_name: bool = True,\n) -&gt; bool:\n\"\"\"Whether this object is considered public.\n\n    In modules, developers can mark objects as public thanks to the `__all__` variable.\n    In classes however, there is no convention or standard to do so.\n\n    Therefore, to decide whether an object is public, we follow this algorithm:\n\n    - If the object's `public` attribute is set (boolean), return its value.\n    - In strict mode, the object is public only if it is explicitely exported (listed in `__all__`).\n        Strict mode should only be used for module members.\n    - Otherwise, if name checks are enabled, the object is private if its name starts with an underscore.\n    - Otherwise, if the object is an alias, and is neither inherited from a base class,\n        nor a member of a parent alias, it is not public.\n    - Otherwise, the object is public.\n    \"\"\"\n    if self.public is not None:  # type: ignore[attr-defined]\n        return self.public  # type: ignore[attr-defined]\n    if self.is_explicitely_exported:\n        return True\n    if strict:\n        return False\n    if check_name and self.name.startswith(\"_\"):  # type: ignore[attr-defined]\n        return False\n    if self.is_alias and not (self.inherited or self.parent.is_alias):  # type: ignore[attr-defined]\n        return False\n    return True\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.resolve_target","title":"resolve_target","text":"<pre><code>resolve_target() -&gt; None\n</code></pre> <p>Resolve the target.</p> <p>Raises:</p> <ul> <li> <code>AliasResolutionError</code>           \u2013          <p>When the target cannot be resolved. It happens when the target does not exist, or could not be loaded (unhandled dynamic object?), or when the target is from a module that was not loaded and added to the collection.</p> </li> <li> <code>CyclicAliasError</code>           \u2013          <p>When the resolved target is the alias itself.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def resolve_target(self) -&gt; None:\n\"\"\"Resolve the target.\n\n    Raises:\n        AliasResolutionError: When the target cannot be resolved.\n            It happens when the target does not exist,\n            or could not be loaded (unhandled dynamic object?),\n            or when the target is from a module that was not loaded\n            and added to the collection.\n        CyclicAliasError: When the resolved target is the alias itself.\n    \"\"\"\n    if self._passed_through:\n        raise CyclicAliasError([self.target_path])\n    self._passed_through = True\n    try:\n        self._resolve_target()\n    finally:\n        self._passed_through = False\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute","title":"Attribute","text":"<pre><code>Attribute(\n    *args: Any,\n    value: str | Expr | None = None,\n    annotation: str | Expr | None = None,\n    **kwargs: Any\n)\n</code></pre> <p>             Bases: <code>Object</code></p> <p>The class representing a Python module/class/instance attribute.</p> <p>Parameters:</p> <ul> <li> *args             (<code>Any</code>, default:                 <code>()</code> )         \u2013          <p>See <code>griffe.dataclasses.Object</code>.</p> </li> <li> value             (<code>str | Expr | None</code>, default:                 <code>None</code> )         \u2013          <p>The attribute value, if any.</p> </li> <li> annotation             (<code>str | Expr | None</code>, default:                 <code>None</code> )         \u2013          <p>The attribute annotation, if any.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>See <code>griffe.dataclasses.Object</code>.</p> </li> </ul> <p>Methods:</p> <ul> <li> __delitem__           \u2013            <p>Delete a member with its name or path.</p> </li> <li> __getitem__           \u2013            <p>Get a member with its name or path.</p> </li> <li> __setitem__           \u2013            <p>Set a member with its name or path.</p> </li> <li> as_dict           \u2013            <p>Return this function's data as a dictionary.</p> </li> <li> as_json           \u2013            <p>Return this object's data as a JSON string.</p> </li> <li> del_member           \u2013            <p>Delete a member with its name or path.</p> </li> <li> filter_members           \u2013            <p>Filter and return members based on predicates.</p> </li> <li> from_json           \u2013            <p>Create an instance of this class from a JSON string.</p> </li> <li> get_member           \u2013            <p>Get a member with its name or path.</p> </li> <li> has_labels           \u2013            <p>Tell if this object has all the given labels.</p> </li> <li> is_exported           \u2013            <p>Tell if this object/alias is implicitely exported by its parent.</p> </li> <li> is_kind           \u2013            <p>Tell if this object is of the given kind.</p> </li> <li> is_public           \u2013            <p>Whether this object is considered public.</p> </li> <li> member_is_exported           \u2013            <p>Tell if a member of this object is \"exported\".</p> </li> <li> resolve           \u2013            <p>Resolve a name within this object's and parents' scope.</p> </li> <li> set_member           \u2013            <p>Set a member with its name or path.</p> </li> </ul> <p>Attributes:</p> <ul> <li> all_members             (<code>dict[str, Object | Alias]</code>)         \u2013          <p>All members (declared and inherited).</p> </li> <li> attributes             (<code>dict[str, Attribute]</code>)         \u2013          <p>Return the attribute members.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Return the full dotted path of this object.</p> </li> <li> classes             (<code>dict[str, Class]</code>)         \u2013          <p>Return the class members.</p> </li> <li> filepath             (<code>Path | list[Path]</code>)         \u2013          <p>Return the file path where this object was defined.</p> </li> <li> functions             (<code>dict[str, Function]</code>)         \u2013          <p>Return the function members.</p> </li> <li> has_docstring             (<code>bool</code>)         \u2013          <p>Tell if this object has a non-empty docstring.</p> </li> <li> has_docstrings             (<code>bool</code>)         \u2013          <p>Tell if this object or any of its members has a non-empty docstring.</p> </li> <li> inherited_members             (<code>dict[str, Alias]</code>)         \u2013          <p>Members that are inherited from base classes.</p> </li> <li> is_attribute             (<code>bool</code>)         \u2013          <p>Tell if this object is an attribute.</p> </li> <li> is_class             (<code>bool</code>)         \u2013          <p>Tell if this object is a class.</p> </li> <li> is_explicitely_exported             (<code>bool</code>)         \u2013          <p>Tell if this object/alias is explicitely exported by its parent.</p> </li> <li> is_function             (<code>bool</code>)         \u2013          <p>Tell if this object is a function.</p> </li> <li> is_implicitely_exported             (<code>bool</code>)         \u2013          <p>Tell if this object/alias is implicitely exported by its parent.</p> </li> <li> is_module             (<code>bool</code>)         \u2013          <p>Tell if this object is a module.</p> </li> <li> lines             (<code>list[str]</code>)         \u2013          <p>Return the lines containing the source of this object.</p> </li> <li> lines_collection             (<code>LinesCollection</code>)         \u2013          <p>Return the lines collection attached to this object or its parents.</p> </li> <li> module             (<code>Module</code>)         \u2013          <p>Return the parent module of this object.</p> </li> <li> modules             (<code>dict[str, Module]</code>)         \u2013          <p>Return the module members.</p> </li> <li> modules_collection             (<code>ModulesCollection</code>)         \u2013          <p>Return the modules collection attached to this object or its parents.</p> </li> <li> package             (<code>Module</code>)         \u2013          <p>Return the absolute top module (the package) of this object.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Return the dotted path of this object.</p> </li> <li> relative_filepath             (<code>Path</code>)         \u2013          <p>Return the file path where this object was defined, relative to the current working directory.</p> </li> <li> relative_package_filepath             (<code>Path</code>)         \u2013          <p>Return the file path where this object was defined, relative to the top module path.</p> </li> <li> source             (<code>str</code>)         \u2013          <p>Return the source code of this object.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def __init__(\n    self,\n    *args: Any,\n    value: str | Expr | None = None,\n    annotation: str | Expr | None = None,\n    **kwargs: Any,\n) -&gt; None:\n\"\"\"Initialize the function.\n\n    Parameters:\n        *args: See [`griffe.dataclasses.Object`][].\n        value: The attribute value, if any.\n        annotation: The attribute annotation, if any.\n        **kwargs: See [`griffe.dataclasses.Object`][].\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.value: str | Expr | None = value\n    self.annotation: str | Expr | None = annotation\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.all_members","title":"all_members  <code>property</code>","text":"<pre><code>all_members: dict[str, Object | Alias]\n</code></pre> <p>All members (declared and inherited).</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.attributes","title":"attributes  <code>property</code>","text":"<pre><code>attributes: dict[str, Attribute]\n</code></pre> <p>Return the attribute members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Attribute]</code>         \u2013          <p>A dictionary of attributes.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Return the full dotted path of this object.</p> <p>The canonical path is the path where the object was defined (not imported).</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>A dotted path.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.classes","title":"classes  <code>property</code>","text":"<pre><code>classes: dict[str, Class]\n</code></pre> <p>Return the class members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Class]</code>         \u2013          <p>A dictionary of classes.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.filepath","title":"filepath  <code>property</code>","text":"<pre><code>filepath: Path | list[Path]\n</code></pre> <p>Return the file path where this object was defined.</p> <p>Returns:</p> <ul> <li> <code>Path | list[Path]</code>         \u2013          <p>A file path or a list of directories.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.functions","title":"functions  <code>property</code>","text":"<pre><code>functions: dict[str, Function]\n</code></pre> <p>Return the function members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Function]</code>         \u2013          <p>A dictionary of functions.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.has_docstring","title":"has_docstring  <code>property</code>","text":"<pre><code>has_docstring: bool\n</code></pre> <p>Tell if this object has a non-empty docstring.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.has_docstrings","title":"has_docstrings  <code>property</code>","text":"<pre><code>has_docstrings: bool\n</code></pre> <p>Tell if this object or any of its members has a non-empty docstring.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.inherited_members","title":"inherited_members  <code>cached</code> <code>property</code>","text":"<pre><code>inherited_members: dict[str, Alias]\n</code></pre> <p>Members that are inherited from base classes.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.is_attribute","title":"is_attribute  <code>property</code>","text":"<pre><code>is_attribute: bool\n</code></pre> <p>Tell if this object is an attribute.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.is_class","title":"is_class  <code>property</code>","text":"<pre><code>is_class: bool\n</code></pre> <p>Tell if this object is a class.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.is_explicitely_exported","title":"is_explicitely_exported  <code>property</code>","text":"<pre><code>is_explicitely_exported: bool\n</code></pre> <p>Tell if this object/alias is explicitely exported by its parent.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.is_function","title":"is_function  <code>property</code>","text":"<pre><code>is_function: bool\n</code></pre> <p>Tell if this object is a function.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.is_implicitely_exported","title":"is_implicitely_exported  <code>property</code>","text":"<pre><code>is_implicitely_exported: bool\n</code></pre> <p>Tell if this object/alias is implicitely exported by its parent.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.is_module","title":"is_module  <code>property</code>","text":"<pre><code>is_module: bool\n</code></pre> <p>Tell if this object is a module.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.lines","title":"lines  <code>property</code>","text":"<pre><code>lines: list[str]\n</code></pre> <p>Return the lines containing the source of this object.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>         \u2013          <p>A list of lines.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.lines_collection","title":"lines_collection  <code>property</code>","text":"<pre><code>lines_collection: LinesCollection\n</code></pre> <p>Return the lines collection attached to this object or its parents.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When no modules collection can be found in the object or its parents.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>LinesCollection</code>         \u2013          <p>A lines collection.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.module","title":"module  <code>property</code>","text":"<pre><code>module: Module\n</code></pre> <p>Return the parent module of this object.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When the object is not a module and does not have a parent.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013          <p>The parent module.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.modules","title":"modules  <code>property</code>","text":"<pre><code>modules: dict[str, Module]\n</code></pre> <p>Return the module members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Module]</code>         \u2013          <p>A dictionary of modules.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.modules_collection","title":"modules_collection  <code>property</code>","text":"<pre><code>modules_collection: ModulesCollection\n</code></pre> <p>Return the modules collection attached to this object or its parents.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When no modules collection can be found in the object or its parents.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ModulesCollection</code>         \u2013          <p>A modules collection.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.package","title":"package  <code>property</code>","text":"<pre><code>package: Module\n</code></pre> <p>Return the absolute top module (the package) of this object.</p> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013          <p>The parent module.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Return the dotted path of this object.</p> <p>On regular objects (not aliases), the path is the canonical path.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>A dotted path.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.relative_filepath","title":"relative_filepath  <code>property</code>","text":"<pre><code>relative_filepath: Path\n</code></pre> <p>Return the file path where this object was defined, relative to the current working directory.</p> <p>If this object's file path is not relative to the current working directory, return its absolute path.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When the relative path could not be computed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code>         \u2013          <p>A file path.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.relative_package_filepath","title":"relative_package_filepath  <code>property</code>","text":"<pre><code>relative_package_filepath: Path\n</code></pre> <p>Return the file path where this object was defined, relative to the top module path.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When the relative path could not be computed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code>         \u2013          <p>A file path.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.source","title":"source  <code>property</code>","text":"<pre><code>source: str\n</code></pre> <p>Return the source code of this object.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The source code.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.__delitem__","title":"__delitem__","text":"<pre><code>__delitem__(key: str | Sequence[str]) -&gt; None\n</code></pre> <p>Delete a member with its name or path.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Members will be looked up in both declared members and inherited ones, triggering computation of the latter.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; del griffe_object[\"foo\"]\n&gt;&gt;&gt; del griffe_object[\"path.to.bar\"]\n&gt;&gt;&gt; del griffe_object[(\"path\", \"to\", \"qux\")]\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def __delitem__(self, key: str | Sequence[str]) -&gt; None:\n\"\"\"Delete a member with its name or path.\n\n    This method is part of the consumer API:\n    do not use when producing Griffe trees!\n\n    Members will be looked up in both declared members and inherited ones,\n    triggering computation of the latter.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; del griffe_object[\"foo\"]\n        &gt;&gt;&gt; del griffe_object[\"path.to.bar\"]\n        &gt;&gt;&gt; del griffe_object[(\"path\", \"to\", \"qux\")]\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        try:\n            del self.members[name]  # type: ignore[attr-defined]\n        except KeyError:\n            del self.inherited_members[name]  # type: ignore[attr-defined]\n    else:\n        del self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key: str | Sequence[str]) -&gt; Any\n</code></pre> <p>Get a member with its name or path.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Members will be looked up in both declared members and inherited ones, triggering computation of the latter.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; foo = griffe_object[\"foo\"]\n&gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n&gt;&gt;&gt; qux = griffe_object[(\"path\", \"to\", \"qux\")]\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def __getitem__(self, key: str | Sequence[str]) -&gt; Any:\n\"\"\"Get a member with its name or path.\n\n    This method is part of the consumer API:\n    do not use when producing Griffe trees!\n\n    Members will be looked up in both declared members and inherited ones,\n    triggering computation of the latter.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; foo = griffe_object[\"foo\"]\n        &gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n        &gt;&gt;&gt; qux = griffe_object[(\"path\", \"to\", \"qux\")]\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        return self.all_members[parts[0]]  # type: ignore[attr-defined]\n    return self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(\n    key: str | Sequence[str], value: Object | Alias\n) -&gt; None\n</code></pre> <p>Set a member with its name or path.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> <li> value             (<code>Object | Alias</code>)         \u2013          <p>The member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; griffe_object[\"foo\"] = foo\n&gt;&gt;&gt; griffe_object[\"path.to.bar\"] = bar\n&gt;&gt;&gt; griffe_object[(\"path\", \"to\", \"qux\")] = qux\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def __setitem__(self, key: str | Sequence[str], value: Object | Alias) -&gt; None:\n\"\"\"Set a member with its name or path.\n\n    This method is part of the consumer API:\n    do not use when producing Griffe trees!\n\n    Parameters:\n        key: The name or path of the member.\n        value: The member.\n\n    Examples:\n        &gt;&gt;&gt; griffe_object[\"foo\"] = foo\n        &gt;&gt;&gt; griffe_object[\"path.to.bar\"] = bar\n        &gt;&gt;&gt; griffe_object[(\"path\", \"to\", \"qux\")] = qux\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        self.members[name] = value  # type: ignore[attr-defined]\n        if self.is_collection:  # type: ignore[attr-defined]\n            value._modules_collection = self  # type: ignore[union-attr]\n        else:\n            value.parent = self  # type: ignore[assignment]\n    else:\n        self.members[parts[0]][parts[1:]] = value  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return this function's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return this function's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    base = super().as_dict(**kwargs)\n    if self.value is not None:\n        base[\"value\"] = self.value\n    if self.annotation is not None:\n        base[\"annotation\"] = self.annotation\n    return base\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.as_json","title":"as_json","text":"<pre><code>as_json(*, full: bool = False, **kwargs: Any) -&gt; str\n</code></pre> <p>Return this object's data as a JSON string.</p> <p>Parameters:</p> <ul> <li> full             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to return full info, or just base info.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options passed to encoder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>A JSON string.</p> </li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>def as_json(self, *, full: bool = False, **kwargs: Any) -&gt; str:\n\"\"\"Return this object's data as a JSON string.\n\n    Parameters:\n        full: Whether to return full info, or just base info.\n        **kwargs: Additional serialization options passed to encoder.\n\n    Returns:\n        A JSON string.\n    \"\"\"\n    from griffe.encoders import JSONEncoder  # avoid circular import\n\n    return json.dumps(self, cls=JSONEncoder, full=full, **kwargs)\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.del_member","title":"del_member","text":"<pre><code>del_member(key: str | Sequence[str]) -&gt; None\n</code></pre> <p>Delete a member with its name or path.</p> <p>This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).</p> <p>Members will be looked up in declared members only, not inherited ones.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; griffe_object.del_member(\"foo\")\n&gt;&gt;&gt; griffe_object.del_member(\"path.to.bar\")\n&gt;&gt;&gt; griffe_object.del_member((\"path\", \"to\", \"qux\"))\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def del_member(self, key: str | Sequence[str]) -&gt; None:\n\"\"\"Delete a member with its name or path.\n\n    This method is part of the producer API:\n    you can use it safely while building Griffe trees\n    (for example in Griffe extensions).\n\n    Members will be looked up in declared members only, not inherited ones.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; griffe_object.del_member(\"foo\")\n        &gt;&gt;&gt; griffe_object.del_member(\"path.to.bar\")\n        &gt;&gt;&gt; griffe_object.del_member((\"path\", \"to\", \"qux\"))\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        del self.members[name]  # type: ignore[attr-defined]\n    else:\n        self.members[parts[0]].del_member(parts[1:])  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.filter_members","title":"filter_members","text":"<pre><code>filter_members(\n    *predicates: Callable[[Object | Alias], bool]\n) -&gt; dict[str, Object | Alias]\n</code></pre> <p>Filter and return members based on predicates.</p> <p>Parameters:</p> <ul> <li> *predicates             (<code>Callable[[Object | Alias], bool]</code>, default:                 <code>()</code> )         \u2013          <p>A list of predicates, i.e. callables accepting a member as argument and returning a boolean.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Object | Alias]</code>         \u2013          <p>A dictionary of members.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def filter_members(self, *predicates: Callable[[Object | Alias], bool]) -&gt; dict[str, Object | Alias]:\n\"\"\"Filter and return members based on predicates.\n\n    Parameters:\n        *predicates: A list of predicates, i.e. callables accepting a member as argument and returning a boolean.\n\n    Returns:\n        A dictionary of members.\n    \"\"\"\n    if not predicates:\n        return self.members\n    members: dict[str, Object | Alias] = {}\n    for name, member in self.members.items():\n        if all(predicate(member) for predicate in predicates):\n            members[name] = member\n    return members\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_string: str, **kwargs: Any) -&gt; _ObjType\n</code></pre> <p>Create an instance of this class from a JSON string.</p> <p>Parameters:</p> <ul> <li> json_string             (<code>str</code>)         \u2013          <p>JSON to decode into Object.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional options passed to decoder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_ObjType</code>         \u2013          <p>An Object instance.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>           \u2013          <p>When the json_string does not represent and object of the class from which this classmethod has been called.</p> </li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>@classmethod\ndef from_json(cls: type[_ObjType], json_string: str, **kwargs: Any) -&gt; _ObjType:  # noqa: PYI019\n\"\"\"Create an instance of this class from a JSON string.\n\n    Parameters:\n        json_string: JSON to decode into Object.\n        **kwargs: Additional options passed to decoder.\n\n    Returns:\n        An Object instance.\n\n    Raises:\n        TypeError: When the json_string does not represent and object\n            of the class from which this classmethod has been called.\n    \"\"\"\n    from griffe.encoders import json_decoder  # avoid circular import\n\n    kwargs.setdefault(\"object_hook\", json_decoder)\n    obj = json.loads(json_string, **kwargs)\n    if not isinstance(obj, cls):\n        raise TypeError(f\"provided JSON object is not of type {cls}\")\n    return obj\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.get_member","title":"get_member","text":"<pre><code>get_member(key: str | Sequence[str]) -&gt; Any\n</code></pre> <p>Get a member with its name or path.</p> <p>This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).</p> <p>Members will be looked up in declared members only, not inherited ones.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; foo = griffe_object[\"foo\"]\n&gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n&gt;&gt;&gt; bar = griffe_object[(\"path\", \"to\", \"bar\")]\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def get_member(self, key: str | Sequence[str]) -&gt; Any:\n\"\"\"Get a member with its name or path.\n\n    This method is part of the producer API:\n    you can use it safely while building Griffe trees\n    (for example in Griffe extensions).\n\n    Members will be looked up in declared members only, not inherited ones.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; foo = griffe_object[\"foo\"]\n        &gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n        &gt;&gt;&gt; bar = griffe_object[(\"path\", \"to\", \"bar\")]\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        return self.members[parts[0]]  # type: ignore[attr-defined]\n    return self.members[parts[0]].get_member(parts[1:])  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.has_labels","title":"has_labels","text":"<pre><code>has_labels(labels: set[str]) -&gt; bool\n</code></pre> <p>Tell if this object has all the given labels.</p> <p>Parameters:</p> <ul> <li> labels             (<code>set[str]</code>)         \u2013          <p>A set of labels.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def has_labels(self, labels: set[str]) -&gt; bool:\n\"\"\"Tell if this object has all the given labels.\n\n    Parameters:\n        labels: A set of labels.\n\n    Returns:\n        True or False.\n    \"\"\"\n    return all(label in self.labels for label in labels)\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.is_exported","title":"is_exported","text":"<pre><code>is_exported(*, explicitely: bool = True) -&gt; bool\n</code></pre> <p>Tell if this object/alias is implicitely exported by its parent.</p> <p>Parameters:</p> <ul> <li> explicitely             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to only return True when <code>__all__</code> is defined.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>def is_exported(self, *, explicitely: bool = True) -&gt; bool:\n\"\"\"Tell if this object/alias is implicitely exported by its parent.\n\n    Parameters:\n        explicitely: Whether to only return True when `__all__` is defined.\n\n    Returns:\n        True or False.\n    \"\"\"\n    return self.parent.member_is_exported(self, explicitely=explicitely)  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.is_kind","title":"is_kind","text":"<pre><code>is_kind(kind: str | Kind | set[str | Kind]) -&gt; bool\n</code></pre> <p>Tell if this object is of the given kind.</p> <p>Parameters:</p> <ul> <li> kind             (<code>str | Kind | set[str | Kind]</code>)         \u2013          <p>An instance or set of kinds (strings or enumerations).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When an empty set is given as argument.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def is_kind(self, kind: str | Kind | set[str | Kind]) -&gt; bool:\n\"\"\"Tell if this object is of the given kind.\n\n    Parameters:\n        kind: An instance or set of kinds (strings or enumerations).\n\n    Raises:\n        ValueError: When an empty set is given as argument.\n\n    Returns:\n        True or False.\n    \"\"\"\n    if isinstance(kind, set):\n        if not kind:\n            raise ValueError(\"kind must not be an empty set\")\n        return self.kind in (knd if isinstance(knd, Kind) else Kind(knd) for knd in kind)\n    if isinstance(kind, str):\n        kind = Kind(kind)\n    return self.kind is kind\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.is_public","title":"is_public","text":"<pre><code>is_public(\n    *, strict: bool = False, check_name: bool = True\n) -&gt; bool\n</code></pre> <p>Whether this object is considered public.</p> <p>In modules, developers can mark objects as public thanks to the <code>__all__</code> variable. In classes however, there is no convention or standard to do so.</p> <p>Therefore, to decide whether an object is public, we follow this algorithm:</p> <ul> <li>If the object's <code>public</code> attribute is set (boolean), return its value.</li> <li>In strict mode, the object is public only if it is explicitely exported (listed in <code>__all__</code>).     Strict mode should only be used for module members.</li> <li>Otherwise, if name checks are enabled, the object is private if its name starts with an underscore.</li> <li>Otherwise, if the object is an alias, and is neither inherited from a base class,     nor a member of a parent alias, it is not public.</li> <li>Otherwise, the object is public.</li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>def is_public(\n    self,\n    *,\n    strict: bool = False,\n    check_name: bool = True,\n) -&gt; bool:\n\"\"\"Whether this object is considered public.\n\n    In modules, developers can mark objects as public thanks to the `__all__` variable.\n    In classes however, there is no convention or standard to do so.\n\n    Therefore, to decide whether an object is public, we follow this algorithm:\n\n    - If the object's `public` attribute is set (boolean), return its value.\n    - In strict mode, the object is public only if it is explicitely exported (listed in `__all__`).\n        Strict mode should only be used for module members.\n    - Otherwise, if name checks are enabled, the object is private if its name starts with an underscore.\n    - Otherwise, if the object is an alias, and is neither inherited from a base class,\n        nor a member of a parent alias, it is not public.\n    - Otherwise, the object is public.\n    \"\"\"\n    if self.public is not None:  # type: ignore[attr-defined]\n        return self.public  # type: ignore[attr-defined]\n    if self.is_explicitely_exported:\n        return True\n    if strict:\n        return False\n    if check_name and self.name.startswith(\"_\"):  # type: ignore[attr-defined]\n        return False\n    if self.is_alias and not (self.inherited or self.parent.is_alias):  # type: ignore[attr-defined]\n        return False\n    return True\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.member_is_exported","title":"member_is_exported","text":"<pre><code>member_is_exported(\n    member: Object | Alias, *, explicitely: bool = True\n) -&gt; bool\n</code></pre> <p>Tell if a member of this object is \"exported\".</p> <p>By exported, we mean that the object is included in the <code>__all__</code> attribute of its parent module or class. When <code>__all__</code> is not defined, we consider the member to be implicitely exported, unless it's a module and it was not imported, and unless it's not defined at runtime.</p> <p>Parameters:</p> <ul> <li> member             (<code>Object | Alias</code>)         \u2013          <p>The member to verify.</p> </li> <li> explicitely             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to only return True when <code>__all__</code> is defined.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def member_is_exported(self, member: Object | Alias, *, explicitely: bool = True) -&gt; bool:\n\"\"\"Tell if a member of this object is \"exported\".\n\n    By exported, we mean that the object is included in the `__all__` attribute\n    of its parent module or class. When `__all__` is not defined,\n    we consider the member to be *implicitely* exported,\n    unless it's a module and it was not imported,\n    and unless it's not defined at runtime.\n\n    Parameters:\n        member: The member to verify.\n        explicitely: Whether to only return True when `__all__` is defined.\n\n    Returns:\n        True or False.\n    \"\"\"\n    if not member.runtime:\n        return False\n    if self.exports is None:\n        return not explicitely and (member.is_alias or not member.is_module or member.name in self.imports)\n    return member.name in self.exports\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.resolve","title":"resolve","text":"<pre><code>resolve(name: str) -&gt; str\n</code></pre> <p>Resolve a name within this object's and parents' scope.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013          <p>The name to resolve.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NameResolutionError</code>           \u2013          <p>When the name could not be resolved.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The resolved name.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def resolve(self, name: str) -&gt; str:\n\"\"\"Resolve a name within this object's and parents' scope.\n\n    Parameters:\n        name: The name to resolve.\n\n    Raises:\n        NameResolutionError: When the name could not be resolved.\n\n    Returns:\n        The resolved name.\n    \"\"\"\n    if name in self.members:\n        if self.members[name].is_alias:\n            return self.members[name].target_path  # type: ignore[union-attr]\n        return self.members[name].path\n    if name in self.imports:\n        return self.imports[name]\n    if self.parent is None:\n        # could be a built-in\n        raise NameResolutionError(f\"{name} could not be resolved in the scope of {self.path}\")\n    if name == self.parent.name and not self.parent.is_module:\n        return self.parent.path\n    return self.parent.resolve(name)\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.set_member","title":"set_member","text":"<pre><code>set_member(\n    key: str | Sequence[str], value: Object | Alias\n) -&gt; None\n</code></pre> <p>Set a member with its name or path.</p> <p>This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> <li> value             (<code>Object | Alias</code>)         \u2013          <p>The member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; griffe_object.set_member(\"foo\", foo)\n&gt;&gt;&gt; griffe_object.set_member(\"path.to.bar\", bar)\n&gt;&gt;&gt; griffe_object.set_member((\"path\", \"to\", \"qux\", qux)\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def set_member(self, key: str | Sequence[str], value: Object | Alias) -&gt; None:\n\"\"\"Set a member with its name or path.\n\n    This method is part of the producer API:\n    you can use it safely while building Griffe trees\n    (for example in Griffe extensions).\n\n    Parameters:\n        key: The name or path of the member.\n        value: The member.\n\n    Examples:\n        &gt;&gt;&gt; griffe_object.set_member(\"foo\", foo)\n        &gt;&gt;&gt; griffe_object.set_member(\"path.to.bar\", bar)\n        &gt;&gt;&gt; griffe_object.set_member((\"path\", \"to\", \"qux\", qux)\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        if name in self.members:  # type: ignore[attr-defined]\n            member = self.members[name]  # type: ignore[attr-defined]\n            if not member.is_alias:\n                # when reassigning a module to an existing one,\n                # try to merge them as one regular and one stubs module\n                # (implicit support for .pyi modules)\n                if member.is_module and not (member.is_namespace_package or member.is_namespace_subpackage):\n                    with suppress(AliasResolutionError, CyclicAliasError):\n                        if value.is_module and value.filepath != member.filepath:\n                            with suppress(ValueError):\n                                value = merge_stubs(member, value)  # type: ignore[arg-type]\n                for alias in member.aliases.values():\n                    with suppress(CyclicAliasError):\n                        alias.target = value\n        self.members[name] = value  # type: ignore[attr-defined]\n        if self.is_collection:  # type: ignore[attr-defined]\n            value._modules_collection = self  # type: ignore[union-attr]\n        else:\n            value.parent = self  # type: ignore[assignment]\n    else:\n        self.members[parts[0]].set_member(parts[1:], value)  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class","title":"Class","text":"<pre><code>Class(\n    *args: Any,\n    bases: Sequence[Expr | str] | None = None,\n    decorators: list[Decorator] | None = None,\n    **kwargs: Any\n)\n</code></pre> <p>             Bases: <code>Object</code></p> <p>The class representing a Python class.</p> <p>Parameters:</p> <ul> <li> *args             (<code>Any</code>, default:                 <code>()</code> )         \u2013          <p>See <code>griffe.dataclasses.Object</code>.</p> </li> <li> bases             (<code>Sequence[Expr | str] | None</code>, default:                 <code>None</code> )         \u2013          <p>The list of base classes, if any.</p> </li> <li> decorators             (<code>list[Decorator] | None</code>, default:                 <code>None</code> )         \u2013          <p>The class decorators, if any.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>See <code>griffe.dataclasses.Object</code>.</p> </li> </ul> <p>Methods:</p> <ul> <li> __delitem__           \u2013            <p>Delete a member with its name or path.</p> </li> <li> __getitem__           \u2013            <p>Get a member with its name or path.</p> </li> <li> __setitem__           \u2013            <p>Set a member with its name or path.</p> </li> <li> as_dict           \u2013            <p>Return this class' data as a dictionary.</p> </li> <li> as_json           \u2013            <p>Return this object's data as a JSON string.</p> </li> <li> del_member           \u2013            <p>Delete a member with its name or path.</p> </li> <li> filter_members           \u2013            <p>Filter and return members based on predicates.</p> </li> <li> from_json           \u2013            <p>Create an instance of this class from a JSON string.</p> </li> <li> get_member           \u2013            <p>Get a member with its name or path.</p> </li> <li> has_labels           \u2013            <p>Tell if this object has all the given labels.</p> </li> <li> is_exported           \u2013            <p>Tell if this object/alias is implicitely exported by its parent.</p> </li> <li> is_kind           \u2013            <p>Tell if this object is of the given kind.</p> </li> <li> is_public           \u2013            <p>Whether this object is considered public.</p> </li> <li> member_is_exported           \u2013            <p>Tell if a member of this object is \"exported\".</p> </li> <li> mro           \u2013            <p>Return a list of classes in order corresponding to Python's MRO.</p> </li> <li> resolve           \u2013            <p>Resolve a name within this object's and parents' scope.</p> </li> <li> set_member           \u2013            <p>Set a member with its name or path.</p> </li> </ul> <p>Attributes:</p> <ul> <li> all_members             (<code>dict[str, Object | Alias]</code>)         \u2013          <p>All members (declared and inherited).</p> </li> <li> attributes             (<code>dict[str, Attribute]</code>)         \u2013          <p>Return the attribute members.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Return the full dotted path of this object.</p> </li> <li> classes             (<code>dict[str, Class]</code>)         \u2013          <p>Return the class members.</p> </li> <li> filepath             (<code>Path | list[Path]</code>)         \u2013          <p>Return the file path where this object was defined.</p> </li> <li> functions             (<code>dict[str, Function]</code>)         \u2013          <p>Return the function members.</p> </li> <li> has_docstring             (<code>bool</code>)         \u2013          <p>Tell if this object has a non-empty docstring.</p> </li> <li> has_docstrings             (<code>bool</code>)         \u2013          <p>Tell if this object or any of its members has a non-empty docstring.</p> </li> <li> inherited_members             (<code>dict[str, Alias]</code>)         \u2013          <p>Members that are inherited from base classes.</p> </li> <li> is_attribute             (<code>bool</code>)         \u2013          <p>Tell if this object is an attribute.</p> </li> <li> is_class             (<code>bool</code>)         \u2013          <p>Tell if this object is a class.</p> </li> <li> is_explicitely_exported             (<code>bool</code>)         \u2013          <p>Tell if this object/alias is explicitely exported by its parent.</p> </li> <li> is_function             (<code>bool</code>)         \u2013          <p>Tell if this object is a function.</p> </li> <li> is_implicitely_exported             (<code>bool</code>)         \u2013          <p>Tell if this object/alias is implicitely exported by its parent.</p> </li> <li> is_module             (<code>bool</code>)         \u2013          <p>Tell if this object is a module.</p> </li> <li> lines             (<code>list[str]</code>)         \u2013          <p>Return the lines containing the source of this object.</p> </li> <li> lines_collection             (<code>LinesCollection</code>)         \u2013          <p>Return the lines collection attached to this object or its parents.</p> </li> <li> module             (<code>Module</code>)         \u2013          <p>Return the parent module of this object.</p> </li> <li> modules             (<code>dict[str, Module]</code>)         \u2013          <p>Return the module members.</p> </li> <li> modules_collection             (<code>ModulesCollection</code>)         \u2013          <p>Return the modules collection attached to this object or its parents.</p> </li> <li> package             (<code>Module</code>)         \u2013          <p>Return the absolute top module (the package) of this object.</p> </li> <li> parameters             (<code>Parameters</code>)         \u2013          <p>Return the parameters of this class' <code>__init__</code> method, if any.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Return the dotted path of this object.</p> </li> <li> relative_filepath             (<code>Path</code>)         \u2013          <p>Return the file path where this object was defined, relative to the current working directory.</p> </li> <li> relative_package_filepath             (<code>Path</code>)         \u2013          <p>Return the file path where this object was defined, relative to the top module path.</p> </li> <li> resolved_bases             (<code>list[Object]</code>)         \u2013          <p>Resolved class bases.</p> </li> <li> source             (<code>str</code>)         \u2013          <p>Return the source code of this object.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def __init__(\n    self,\n    *args: Any,\n    bases: Sequence[Expr | str] | None = None,\n    decorators: list[Decorator] | None = None,\n    **kwargs: Any,\n) -&gt; None:\n\"\"\"Initialize the class.\n\n    Parameters:\n        *args: See [`griffe.dataclasses.Object`][].\n        bases: The list of base classes, if any.\n        decorators: The class decorators, if any.\n        **kwargs: See [`griffe.dataclasses.Object`][].\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.bases: list[Expr | str] = list(bases) if bases else []\n    self.decorators: list[Decorator] = decorators or []\n    self.overloads: dict[str, list[Function]] = defaultdict(list)\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.all_members","title":"all_members  <code>property</code>","text":"<pre><code>all_members: dict[str, Object | Alias]\n</code></pre> <p>All members (declared and inherited).</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.attributes","title":"attributes  <code>property</code>","text":"<pre><code>attributes: dict[str, Attribute]\n</code></pre> <p>Return the attribute members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Attribute]</code>         \u2013          <p>A dictionary of attributes.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Return the full dotted path of this object.</p> <p>The canonical path is the path where the object was defined (not imported).</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>A dotted path.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.classes","title":"classes  <code>property</code>","text":"<pre><code>classes: dict[str, Class]\n</code></pre> <p>Return the class members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Class]</code>         \u2013          <p>A dictionary of classes.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.filepath","title":"filepath  <code>property</code>","text":"<pre><code>filepath: Path | list[Path]\n</code></pre> <p>Return the file path where this object was defined.</p> <p>Returns:</p> <ul> <li> <code>Path | list[Path]</code>         \u2013          <p>A file path or a list of directories.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.functions","title":"functions  <code>property</code>","text":"<pre><code>functions: dict[str, Function]\n</code></pre> <p>Return the function members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Function]</code>         \u2013          <p>A dictionary of functions.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.has_docstring","title":"has_docstring  <code>property</code>","text":"<pre><code>has_docstring: bool\n</code></pre> <p>Tell if this object has a non-empty docstring.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.has_docstrings","title":"has_docstrings  <code>property</code>","text":"<pre><code>has_docstrings: bool\n</code></pre> <p>Tell if this object or any of its members has a non-empty docstring.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.inherited_members","title":"inherited_members  <code>cached</code> <code>property</code>","text":"<pre><code>inherited_members: dict[str, Alias]\n</code></pre> <p>Members that are inherited from base classes.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.is_attribute","title":"is_attribute  <code>property</code>","text":"<pre><code>is_attribute: bool\n</code></pre> <p>Tell if this object is an attribute.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.is_class","title":"is_class  <code>property</code>","text":"<pre><code>is_class: bool\n</code></pre> <p>Tell if this object is a class.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.is_explicitely_exported","title":"is_explicitely_exported  <code>property</code>","text":"<pre><code>is_explicitely_exported: bool\n</code></pre> <p>Tell if this object/alias is explicitely exported by its parent.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.is_function","title":"is_function  <code>property</code>","text":"<pre><code>is_function: bool\n</code></pre> <p>Tell if this object is a function.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.is_implicitely_exported","title":"is_implicitely_exported  <code>property</code>","text":"<pre><code>is_implicitely_exported: bool\n</code></pre> <p>Tell if this object/alias is implicitely exported by its parent.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.is_module","title":"is_module  <code>property</code>","text":"<pre><code>is_module: bool\n</code></pre> <p>Tell if this object is a module.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.lines","title":"lines  <code>property</code>","text":"<pre><code>lines: list[str]\n</code></pre> <p>Return the lines containing the source of this object.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>         \u2013          <p>A list of lines.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.lines_collection","title":"lines_collection  <code>property</code>","text":"<pre><code>lines_collection: LinesCollection\n</code></pre> <p>Return the lines collection attached to this object or its parents.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When no modules collection can be found in the object or its parents.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>LinesCollection</code>         \u2013          <p>A lines collection.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.module","title":"module  <code>property</code>","text":"<pre><code>module: Module\n</code></pre> <p>Return the parent module of this object.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When the object is not a module and does not have a parent.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013          <p>The parent module.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.modules","title":"modules  <code>property</code>","text":"<pre><code>modules: dict[str, Module]\n</code></pre> <p>Return the module members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Module]</code>         \u2013          <p>A dictionary of modules.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.modules_collection","title":"modules_collection  <code>property</code>","text":"<pre><code>modules_collection: ModulesCollection\n</code></pre> <p>Return the modules collection attached to this object or its parents.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When no modules collection can be found in the object or its parents.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ModulesCollection</code>         \u2013          <p>A modules collection.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.package","title":"package  <code>property</code>","text":"<pre><code>package: Module\n</code></pre> <p>Return the absolute top module (the package) of this object.</p> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013          <p>The parent module.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.parameters","title":"parameters  <code>property</code>","text":"<pre><code>parameters: Parameters\n</code></pre> <p>Return the parameters of this class' <code>__init__</code> method, if any.</p> <p>This property fetches inherited members, and therefore is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>Parameters</code>         \u2013          <p>The parameters container.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Return the dotted path of this object.</p> <p>On regular objects (not aliases), the path is the canonical path.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>A dotted path.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.relative_filepath","title":"relative_filepath  <code>property</code>","text":"<pre><code>relative_filepath: Path\n</code></pre> <p>Return the file path where this object was defined, relative to the current working directory.</p> <p>If this object's file path is not relative to the current working directory, return its absolute path.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When the relative path could not be computed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code>         \u2013          <p>A file path.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.relative_package_filepath","title":"relative_package_filepath  <code>property</code>","text":"<pre><code>relative_package_filepath: Path\n</code></pre> <p>Return the file path where this object was defined, relative to the top module path.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When the relative path could not be computed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code>         \u2013          <p>A file path.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.resolved_bases","title":"resolved_bases  <code>cached</code> <code>property</code>","text":"<pre><code>resolved_bases: list[Object]\n</code></pre> <p>Resolved class bases.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.source","title":"source  <code>property</code>","text":"<pre><code>source: str\n</code></pre> <p>Return the source code of this object.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The source code.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.__delitem__","title":"__delitem__","text":"<pre><code>__delitem__(key: str | Sequence[str]) -&gt; None\n</code></pre> <p>Delete a member with its name or path.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Members will be looked up in both declared members and inherited ones, triggering computation of the latter.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; del griffe_object[\"foo\"]\n&gt;&gt;&gt; del griffe_object[\"path.to.bar\"]\n&gt;&gt;&gt; del griffe_object[(\"path\", \"to\", \"qux\")]\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def __delitem__(self, key: str | Sequence[str]) -&gt; None:\n\"\"\"Delete a member with its name or path.\n\n    This method is part of the consumer API:\n    do not use when producing Griffe trees!\n\n    Members will be looked up in both declared members and inherited ones,\n    triggering computation of the latter.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; del griffe_object[\"foo\"]\n        &gt;&gt;&gt; del griffe_object[\"path.to.bar\"]\n        &gt;&gt;&gt; del griffe_object[(\"path\", \"to\", \"qux\")]\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        try:\n            del self.members[name]  # type: ignore[attr-defined]\n        except KeyError:\n            del self.inherited_members[name]  # type: ignore[attr-defined]\n    else:\n        del self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key: str | Sequence[str]) -&gt; Any\n</code></pre> <p>Get a member with its name or path.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Members will be looked up in both declared members and inherited ones, triggering computation of the latter.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; foo = griffe_object[\"foo\"]\n&gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n&gt;&gt;&gt; qux = griffe_object[(\"path\", \"to\", \"qux\")]\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def __getitem__(self, key: str | Sequence[str]) -&gt; Any:\n\"\"\"Get a member with its name or path.\n\n    This method is part of the consumer API:\n    do not use when producing Griffe trees!\n\n    Members will be looked up in both declared members and inherited ones,\n    triggering computation of the latter.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; foo = griffe_object[\"foo\"]\n        &gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n        &gt;&gt;&gt; qux = griffe_object[(\"path\", \"to\", \"qux\")]\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        return self.all_members[parts[0]]  # type: ignore[attr-defined]\n    return self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(\n    key: str | Sequence[str], value: Object | Alias\n) -&gt; None\n</code></pre> <p>Set a member with its name or path.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> <li> value             (<code>Object | Alias</code>)         \u2013          <p>The member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; griffe_object[\"foo\"] = foo\n&gt;&gt;&gt; griffe_object[\"path.to.bar\"] = bar\n&gt;&gt;&gt; griffe_object[(\"path\", \"to\", \"qux\")] = qux\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def __setitem__(self, key: str | Sequence[str], value: Object | Alias) -&gt; None:\n\"\"\"Set a member with its name or path.\n\n    This method is part of the consumer API:\n    do not use when producing Griffe trees!\n\n    Parameters:\n        key: The name or path of the member.\n        value: The member.\n\n    Examples:\n        &gt;&gt;&gt; griffe_object[\"foo\"] = foo\n        &gt;&gt;&gt; griffe_object[\"path.to.bar\"] = bar\n        &gt;&gt;&gt; griffe_object[(\"path\", \"to\", \"qux\")] = qux\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        self.members[name] = value  # type: ignore[attr-defined]\n        if self.is_collection:  # type: ignore[attr-defined]\n            value._modules_collection = self  # type: ignore[union-attr]\n        else:\n            value.parent = self  # type: ignore[assignment]\n    else:\n        self.members[parts[0]][parts[1:]] = value  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return this class' data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return this class' data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    base = super().as_dict(**kwargs)\n    base[\"bases\"] = self.bases\n    base[\"decorators\"] = [dec.as_dict(**kwargs) for dec in self.decorators]\n    return base\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.as_json","title":"as_json","text":"<pre><code>as_json(*, full: bool = False, **kwargs: Any) -&gt; str\n</code></pre> <p>Return this object's data as a JSON string.</p> <p>Parameters:</p> <ul> <li> full             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to return full info, or just base info.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options passed to encoder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>A JSON string.</p> </li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>def as_json(self, *, full: bool = False, **kwargs: Any) -&gt; str:\n\"\"\"Return this object's data as a JSON string.\n\n    Parameters:\n        full: Whether to return full info, or just base info.\n        **kwargs: Additional serialization options passed to encoder.\n\n    Returns:\n        A JSON string.\n    \"\"\"\n    from griffe.encoders import JSONEncoder  # avoid circular import\n\n    return json.dumps(self, cls=JSONEncoder, full=full, **kwargs)\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.del_member","title":"del_member","text":"<pre><code>del_member(key: str | Sequence[str]) -&gt; None\n</code></pre> <p>Delete a member with its name or path.</p> <p>This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).</p> <p>Members will be looked up in declared members only, not inherited ones.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; griffe_object.del_member(\"foo\")\n&gt;&gt;&gt; griffe_object.del_member(\"path.to.bar\")\n&gt;&gt;&gt; griffe_object.del_member((\"path\", \"to\", \"qux\"))\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def del_member(self, key: str | Sequence[str]) -&gt; None:\n\"\"\"Delete a member with its name or path.\n\n    This method is part of the producer API:\n    you can use it safely while building Griffe trees\n    (for example in Griffe extensions).\n\n    Members will be looked up in declared members only, not inherited ones.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; griffe_object.del_member(\"foo\")\n        &gt;&gt;&gt; griffe_object.del_member(\"path.to.bar\")\n        &gt;&gt;&gt; griffe_object.del_member((\"path\", \"to\", \"qux\"))\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        del self.members[name]  # type: ignore[attr-defined]\n    else:\n        self.members[parts[0]].del_member(parts[1:])  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.filter_members","title":"filter_members","text":"<pre><code>filter_members(\n    *predicates: Callable[[Object | Alias], bool]\n) -&gt; dict[str, Object | Alias]\n</code></pre> <p>Filter and return members based on predicates.</p> <p>Parameters:</p> <ul> <li> *predicates             (<code>Callable[[Object | Alias], bool]</code>, default:                 <code>()</code> )         \u2013          <p>A list of predicates, i.e. callables accepting a member as argument and returning a boolean.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Object | Alias]</code>         \u2013          <p>A dictionary of members.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def filter_members(self, *predicates: Callable[[Object | Alias], bool]) -&gt; dict[str, Object | Alias]:\n\"\"\"Filter and return members based on predicates.\n\n    Parameters:\n        *predicates: A list of predicates, i.e. callables accepting a member as argument and returning a boolean.\n\n    Returns:\n        A dictionary of members.\n    \"\"\"\n    if not predicates:\n        return self.members\n    members: dict[str, Object | Alias] = {}\n    for name, member in self.members.items():\n        if all(predicate(member) for predicate in predicates):\n            members[name] = member\n    return members\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_string: str, **kwargs: Any) -&gt; _ObjType\n</code></pre> <p>Create an instance of this class from a JSON string.</p> <p>Parameters:</p> <ul> <li> json_string             (<code>str</code>)         \u2013          <p>JSON to decode into Object.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional options passed to decoder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_ObjType</code>         \u2013          <p>An Object instance.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>           \u2013          <p>When the json_string does not represent and object of the class from which this classmethod has been called.</p> </li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>@classmethod\ndef from_json(cls: type[_ObjType], json_string: str, **kwargs: Any) -&gt; _ObjType:  # noqa: PYI019\n\"\"\"Create an instance of this class from a JSON string.\n\n    Parameters:\n        json_string: JSON to decode into Object.\n        **kwargs: Additional options passed to decoder.\n\n    Returns:\n        An Object instance.\n\n    Raises:\n        TypeError: When the json_string does not represent and object\n            of the class from which this classmethod has been called.\n    \"\"\"\n    from griffe.encoders import json_decoder  # avoid circular import\n\n    kwargs.setdefault(\"object_hook\", json_decoder)\n    obj = json.loads(json_string, **kwargs)\n    if not isinstance(obj, cls):\n        raise TypeError(f\"provided JSON object is not of type {cls}\")\n    return obj\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.get_member","title":"get_member","text":"<pre><code>get_member(key: str | Sequence[str]) -&gt; Any\n</code></pre> <p>Get a member with its name or path.</p> <p>This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).</p> <p>Members will be looked up in declared members only, not inherited ones.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; foo = griffe_object[\"foo\"]\n&gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n&gt;&gt;&gt; bar = griffe_object[(\"path\", \"to\", \"bar\")]\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def get_member(self, key: str | Sequence[str]) -&gt; Any:\n\"\"\"Get a member with its name or path.\n\n    This method is part of the producer API:\n    you can use it safely while building Griffe trees\n    (for example in Griffe extensions).\n\n    Members will be looked up in declared members only, not inherited ones.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; foo = griffe_object[\"foo\"]\n        &gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n        &gt;&gt;&gt; bar = griffe_object[(\"path\", \"to\", \"bar\")]\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        return self.members[parts[0]]  # type: ignore[attr-defined]\n    return self.members[parts[0]].get_member(parts[1:])  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.has_labels","title":"has_labels","text":"<pre><code>has_labels(labels: set[str]) -&gt; bool\n</code></pre> <p>Tell if this object has all the given labels.</p> <p>Parameters:</p> <ul> <li> labels             (<code>set[str]</code>)         \u2013          <p>A set of labels.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def has_labels(self, labels: set[str]) -&gt; bool:\n\"\"\"Tell if this object has all the given labels.\n\n    Parameters:\n        labels: A set of labels.\n\n    Returns:\n        True or False.\n    \"\"\"\n    return all(label in self.labels for label in labels)\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.is_exported","title":"is_exported","text":"<pre><code>is_exported(*, explicitely: bool = True) -&gt; bool\n</code></pre> <p>Tell if this object/alias is implicitely exported by its parent.</p> <p>Parameters:</p> <ul> <li> explicitely             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to only return True when <code>__all__</code> is defined.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>def is_exported(self, *, explicitely: bool = True) -&gt; bool:\n\"\"\"Tell if this object/alias is implicitely exported by its parent.\n\n    Parameters:\n        explicitely: Whether to only return True when `__all__` is defined.\n\n    Returns:\n        True or False.\n    \"\"\"\n    return self.parent.member_is_exported(self, explicitely=explicitely)  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.is_kind","title":"is_kind","text":"<pre><code>is_kind(kind: str | Kind | set[str | Kind]) -&gt; bool\n</code></pre> <p>Tell if this object is of the given kind.</p> <p>Parameters:</p> <ul> <li> kind             (<code>str | Kind | set[str | Kind]</code>)         \u2013          <p>An instance or set of kinds (strings or enumerations).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When an empty set is given as argument.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def is_kind(self, kind: str | Kind | set[str | Kind]) -&gt; bool:\n\"\"\"Tell if this object is of the given kind.\n\n    Parameters:\n        kind: An instance or set of kinds (strings or enumerations).\n\n    Raises:\n        ValueError: When an empty set is given as argument.\n\n    Returns:\n        True or False.\n    \"\"\"\n    if isinstance(kind, set):\n        if not kind:\n            raise ValueError(\"kind must not be an empty set\")\n        return self.kind in (knd if isinstance(knd, Kind) else Kind(knd) for knd in kind)\n    if isinstance(kind, str):\n        kind = Kind(kind)\n    return self.kind is kind\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.is_public","title":"is_public","text":"<pre><code>is_public(\n    *, strict: bool = False, check_name: bool = True\n) -&gt; bool\n</code></pre> <p>Whether this object is considered public.</p> <p>In modules, developers can mark objects as public thanks to the <code>__all__</code> variable. In classes however, there is no convention or standard to do so.</p> <p>Therefore, to decide whether an object is public, we follow this algorithm:</p> <ul> <li>If the object's <code>public</code> attribute is set (boolean), return its value.</li> <li>In strict mode, the object is public only if it is explicitely exported (listed in <code>__all__</code>).     Strict mode should only be used for module members.</li> <li>Otherwise, if name checks are enabled, the object is private if its name starts with an underscore.</li> <li>Otherwise, if the object is an alias, and is neither inherited from a base class,     nor a member of a parent alias, it is not public.</li> <li>Otherwise, the object is public.</li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>def is_public(\n    self,\n    *,\n    strict: bool = False,\n    check_name: bool = True,\n) -&gt; bool:\n\"\"\"Whether this object is considered public.\n\n    In modules, developers can mark objects as public thanks to the `__all__` variable.\n    In classes however, there is no convention or standard to do so.\n\n    Therefore, to decide whether an object is public, we follow this algorithm:\n\n    - If the object's `public` attribute is set (boolean), return its value.\n    - In strict mode, the object is public only if it is explicitely exported (listed in `__all__`).\n        Strict mode should only be used for module members.\n    - Otherwise, if name checks are enabled, the object is private if its name starts with an underscore.\n    - Otherwise, if the object is an alias, and is neither inherited from a base class,\n        nor a member of a parent alias, it is not public.\n    - Otherwise, the object is public.\n    \"\"\"\n    if self.public is not None:  # type: ignore[attr-defined]\n        return self.public  # type: ignore[attr-defined]\n    if self.is_explicitely_exported:\n        return True\n    if strict:\n        return False\n    if check_name and self.name.startswith(\"_\"):  # type: ignore[attr-defined]\n        return False\n    if self.is_alias and not (self.inherited or self.parent.is_alias):  # type: ignore[attr-defined]\n        return False\n    return True\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.member_is_exported","title":"member_is_exported","text":"<pre><code>member_is_exported(\n    member: Object | Alias, *, explicitely: bool = True\n) -&gt; bool\n</code></pre> <p>Tell if a member of this object is \"exported\".</p> <p>By exported, we mean that the object is included in the <code>__all__</code> attribute of its parent module or class. When <code>__all__</code> is not defined, we consider the member to be implicitely exported, unless it's a module and it was not imported, and unless it's not defined at runtime.</p> <p>Parameters:</p> <ul> <li> member             (<code>Object | Alias</code>)         \u2013          <p>The member to verify.</p> </li> <li> explicitely             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to only return True when <code>__all__</code> is defined.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def member_is_exported(self, member: Object | Alias, *, explicitely: bool = True) -&gt; bool:\n\"\"\"Tell if a member of this object is \"exported\".\n\n    By exported, we mean that the object is included in the `__all__` attribute\n    of its parent module or class. When `__all__` is not defined,\n    we consider the member to be *implicitely* exported,\n    unless it's a module and it was not imported,\n    and unless it's not defined at runtime.\n\n    Parameters:\n        member: The member to verify.\n        explicitely: Whether to only return True when `__all__` is defined.\n\n    Returns:\n        True or False.\n    \"\"\"\n    if not member.runtime:\n        return False\n    if self.exports is None:\n        return not explicitely and (member.is_alias or not member.is_module or member.name in self.imports)\n    return member.name in self.exports\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.mro","title":"mro","text":"<pre><code>mro() -&gt; list[Class]\n</code></pre> <p>Return a list of classes in order corresponding to Python's MRO.</p> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def mro(self) -&gt; list[Class]:\n\"\"\"Return a list of classes in order corresponding to Python's MRO.\"\"\"\n    return self._mro()[1:]  # remove self\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.resolve","title":"resolve","text":"<pre><code>resolve(name: str) -&gt; str\n</code></pre> <p>Resolve a name within this object's and parents' scope.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013          <p>The name to resolve.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NameResolutionError</code>           \u2013          <p>When the name could not be resolved.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The resolved name.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def resolve(self, name: str) -&gt; str:\n\"\"\"Resolve a name within this object's and parents' scope.\n\n    Parameters:\n        name: The name to resolve.\n\n    Raises:\n        NameResolutionError: When the name could not be resolved.\n\n    Returns:\n        The resolved name.\n    \"\"\"\n    if name in self.members:\n        if self.members[name].is_alias:\n            return self.members[name].target_path  # type: ignore[union-attr]\n        return self.members[name].path\n    if name in self.imports:\n        return self.imports[name]\n    if self.parent is None:\n        # could be a built-in\n        raise NameResolutionError(f\"{name} could not be resolved in the scope of {self.path}\")\n    if name == self.parent.name and not self.parent.is_module:\n        return self.parent.path\n    return self.parent.resolve(name)\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.set_member","title":"set_member","text":"<pre><code>set_member(\n    key: str | Sequence[str], value: Object | Alias\n) -&gt; None\n</code></pre> <p>Set a member with its name or path.</p> <p>This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> <li> value             (<code>Object | Alias</code>)         \u2013          <p>The member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; griffe_object.set_member(\"foo\", foo)\n&gt;&gt;&gt; griffe_object.set_member(\"path.to.bar\", bar)\n&gt;&gt;&gt; griffe_object.set_member((\"path\", \"to\", \"qux\", qux)\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def set_member(self, key: str | Sequence[str], value: Object | Alias) -&gt; None:\n\"\"\"Set a member with its name or path.\n\n    This method is part of the producer API:\n    you can use it safely while building Griffe trees\n    (for example in Griffe extensions).\n\n    Parameters:\n        key: The name or path of the member.\n        value: The member.\n\n    Examples:\n        &gt;&gt;&gt; griffe_object.set_member(\"foo\", foo)\n        &gt;&gt;&gt; griffe_object.set_member(\"path.to.bar\", bar)\n        &gt;&gt;&gt; griffe_object.set_member((\"path\", \"to\", \"qux\", qux)\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        if name in self.members:  # type: ignore[attr-defined]\n            member = self.members[name]  # type: ignore[attr-defined]\n            if not member.is_alias:\n                # when reassigning a module to an existing one,\n                # try to merge them as one regular and one stubs module\n                # (implicit support for .pyi modules)\n                if member.is_module and not (member.is_namespace_package or member.is_namespace_subpackage):\n                    with suppress(AliasResolutionError, CyclicAliasError):\n                        if value.is_module and value.filepath != member.filepath:\n                            with suppress(ValueError):\n                                value = merge_stubs(member, value)  # type: ignore[arg-type]\n                for alias in member.aliases.values():\n                    with suppress(CyclicAliasError):\n                        alias.target = value\n        self.members[name] = value  # type: ignore[attr-defined]\n        if self.is_collection:  # type: ignore[attr-defined]\n            value._modules_collection = self  # type: ignore[union-attr]\n        else:\n            value.parent = self  # type: ignore[assignment]\n    else:\n        self.members[parts[0]].set_member(parts[1:], value)  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Decorator","title":"Decorator","text":"<pre><code>Decorator(\n    value: str | Expr,\n    *,\n    lineno: int | None,\n    endlineno: int | None\n)\n</code></pre> <p>This class represents decorators.</p> <p>Attributes:</p> <ul> <li> lineno             (<code>int | None</code>)         \u2013          <p>The starting line number.</p> </li> <li> endlineno             (<code>int | None</code>)         \u2013          <p>The ending line number.</p> </li> </ul> <p>Parameters:</p> <ul> <li> value             (<code>str | Expr</code>)         \u2013          <p>The decorator code.</p> </li> <li> lineno             (<code>int | None</code>)         \u2013          <p>The starting line number.</p> </li> <li> endlineno             (<code>int | None</code>)         \u2013          <p>The ending line number.</p> </li> </ul> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this decorator's data as a dictionary.</p> </li> </ul> <p>Attributes:</p> <ul> <li> callable_path             (<code>str</code>)         \u2013          <p>The path of the callable used as decorator.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def __init__(self, value: str | Expr, *, lineno: int | None, endlineno: int | None) -&gt; None:\n\"\"\"Initialize the decorator.\n\n    Parameters:\n        value: The decorator code.\n        lineno: The starting line number.\n        endlineno: The ending line number.\n    \"\"\"\n    self.value: str | Expr = value\n    self.lineno: int | None = lineno\n    self.endlineno: int | None = endlineno\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Decorator.callable_path","title":"callable_path  <code>property</code>","text":"<pre><code>callable_path: str\n</code></pre> <p>The path of the callable used as decorator.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Decorator.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return this decorator's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:  # noqa: ARG002\n\"\"\"Return this decorator's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return {\n        \"value\": self.value,\n        \"lineno\": self.lineno,\n        \"endlineno\": self.endlineno,\n    }\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring","title":"Docstring","text":"<pre><code>Docstring(\n    value: str,\n    *,\n    lineno: int | None = None,\n    endlineno: int | None = None,\n    parent: Object | None = None,\n    parser: Literal[\"google\", \"numpy\", \"sphinx\"]\n    | Parser\n    | None = None,\n    parser_options: dict[str, Any] | None = None\n)\n</code></pre> <p>This class represents docstrings.</p> <p>Attributes:</p> <ul> <li> value             (<code>str</code>)         \u2013          <p>The actual documentation string, cleaned up.</p> </li> <li> lineno             (<code>int | None</code>)         \u2013          <p>The starting line number.</p> </li> <li> endlineno             (<code>int | None</code>)         \u2013          <p>The ending line number.</p> </li> <li> parent             (<code>Object | None</code>)         \u2013          <p>The parent object on which this docstring is attached.</p> </li> </ul> <p>Parameters:</p> <ul> <li> value             (<code>str</code>)         \u2013          <p>The docstring value.</p> </li> <li> lineno             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>The starting line number.</p> </li> <li> endlineno             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>The ending line number.</p> </li> <li> parent             (<code>Object | None</code>, default:                 <code>None</code> )         \u2013          <p>The parent object on which this docstring is attached.</p> </li> <li> parser             (<code>Literal['google', 'numpy', 'sphinx'] | Parser | None</code>, default:                 <code>None</code> )         \u2013          <p>The docstring parser to use. By default, no parsing is done.</p> </li> <li> parser_options             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional docstring parsing options.</p> </li> </ul> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this docstring's data as a dictionary.</p> </li> <li> parse           \u2013            <p>Parse the docstring into structured data.</p> </li> </ul> <p>Attributes:</p> <ul> <li> lines             (<code>list[str]</code>)         \u2013          <p>Returns the lines of the docstring.</p> </li> <li> parsed             (<code>list[DocstringSection]</code>)         \u2013          <p>Return the docstring, parsed into structured data.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def __init__(\n    self,\n    value: str,\n    *,\n    lineno: int | None = None,\n    endlineno: int | None = None,\n    parent: Object | None = None,\n    parser: Literal[\"google\", \"numpy\", \"sphinx\"] | Parser | None = None,\n    parser_options: dict[str, Any] | None = None,\n) -&gt; None:\n\"\"\"Initialize the docstring.\n\n    Parameters:\n        value: The docstring value.\n        lineno: The starting line number.\n        endlineno: The ending line number.\n        parent: The parent object on which this docstring is attached.\n        parser: The docstring parser to use. By default, no parsing is done.\n        parser_options: Additional docstring parsing options.\n    \"\"\"\n    self.value: str = inspect.cleandoc(value.rstrip())\n    self.lineno: int | None = lineno\n    self.endlineno: int | None = endlineno\n    self.parent: Object | None = parent\n    self.parser: Literal[\"google\", \"numpy\", \"sphinx\"] | Parser | None = parser\n    self.parser_options: dict[str, Any] = parser_options or {}\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.lines","title":"lines  <code>property</code>","text":"<pre><code>lines: list[str]\n</code></pre> <p>Returns the lines of the docstring.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>         \u2013          <p>The docstring's lines.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.parsed","title":"parsed  <code>cached</code> <code>property</code>","text":"<pre><code>parsed: list[DocstringSection]\n</code></pre> <p>Return the docstring, parsed into structured data.</p> <p>Returns:</p> <ul> <li> <code>list[DocstringSection]</code>         \u2013          <p>The parsed docstring as a list of sections.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.as_dict","title":"as_dict","text":"<pre><code>as_dict(\n    *,\n    full: bool = False,\n    docstring_parser: Parser | None = None,\n    **kwargs: Any\n) -&gt; dict[str, Any]\n</code></pre> <p>Return this docstring's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> full             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to return full info, or just base info.</p> </li> <li> docstring_parser             (<code>Parser | None</code>, default:                 <code>None</code> )         \u2013          <p>The docstring parser to parse the docstring with. By default, no parsing is done.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization or docstring parsing options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def as_dict(self, *, full: bool = False, docstring_parser: Parser | None = None, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return this docstring's data as a dictionary.\n\n    Parameters:\n        full: Whether to return full info, or just base info.\n        docstring_parser: The docstring parser to parse the docstring with. By default, no parsing is done.\n        **kwargs: Additional serialization or docstring parsing options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    base: dict[str, Any] = {\n        \"value\": self.value,\n        \"lineno\": self.lineno,\n        \"endlineno\": self.endlineno,\n    }\n    if full:\n        base[\"parsed\"] = self.parse(docstring_parser, **kwargs)\n    return base\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.parse","title":"parse","text":"<pre><code>parse(\n    parser: Literal[\"google\", \"numpy\", \"sphinx\"]\n    | Parser\n    | None = None,\n    **options: Any\n) -&gt; list[DocstringSection]\n</code></pre> <p>Parse the docstring into structured data.</p> <p>Parameters:</p> <ul> <li> parser             (<code>Literal['google', 'numpy', 'sphinx'] | Parser | None</code>, default:                 <code>None</code> )         \u2013          <p>The docstring parser to use. In order: use the given parser, or the self parser, or no parser (return a single text section).</p> </li> <li> **options             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional docstring parsing options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[DocstringSection]</code>         \u2013          <p>The parsed docstring as a list of sections.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def parse(\n    self,\n    parser: Literal[\"google\", \"numpy\", \"sphinx\"] | Parser | None = None,\n    **options: Any,\n) -&gt; list[DocstringSection]:\n\"\"\"Parse the docstring into structured data.\n\n    Parameters:\n        parser: The docstring parser to use.\n            In order: use the given parser, or the self parser, or no parser (return a single text section).\n        **options: Additional docstring parsing options.\n\n    Returns:\n        The parsed docstring as a list of sections.\n    \"\"\"\n    return parse(self, parser or self.parser, **(options or self.parser_options))\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function","title":"Function","text":"<pre><code>Function(\n    *args: Any,\n    parameters: Parameters | None = None,\n    returns: str | Expr | None = None,\n    decorators: list[Decorator] | None = None,\n    **kwargs: Any\n)\n</code></pre> <p>             Bases: <code>Object</code></p> <p>The class representing a Python function.</p> <p>Parameters:</p> <ul> <li> *args             (<code>Any</code>, default:                 <code>()</code> )         \u2013          <p>See <code>griffe.dataclasses.Object</code>.</p> </li> <li> parameters             (<code>Parameters | None</code>, default:                 <code>None</code> )         \u2013          <p>The function parameters.</p> </li> <li> returns             (<code>str | Expr | None</code>, default:                 <code>None</code> )         \u2013          <p>The function return annotation.</p> </li> <li> decorators             (<code>list[Decorator] | None</code>, default:                 <code>None</code> )         \u2013          <p>The function decorators, if any.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>See <code>griffe.dataclasses.Object</code>.</p> </li> </ul> <p>Methods:</p> <ul> <li> __delitem__           \u2013            <p>Delete a member with its name or path.</p> </li> <li> __getitem__           \u2013            <p>Get a member with its name or path.</p> </li> <li> __setitem__           \u2013            <p>Set a member with its name or path.</p> </li> <li> as_dict           \u2013            <p>Return this function's data as a dictionary.</p> </li> <li> as_json           \u2013            <p>Return this object's data as a JSON string.</p> </li> <li> del_member           \u2013            <p>Delete a member with its name or path.</p> </li> <li> filter_members           \u2013            <p>Filter and return members based on predicates.</p> </li> <li> from_json           \u2013            <p>Create an instance of this class from a JSON string.</p> </li> <li> get_member           \u2013            <p>Get a member with its name or path.</p> </li> <li> has_labels           \u2013            <p>Tell if this object has all the given labels.</p> </li> <li> is_exported           \u2013            <p>Tell if this object/alias is implicitely exported by its parent.</p> </li> <li> is_kind           \u2013            <p>Tell if this object is of the given kind.</p> </li> <li> is_public           \u2013            <p>Whether this object is considered public.</p> </li> <li> member_is_exported           \u2013            <p>Tell if a member of this object is \"exported\".</p> </li> <li> resolve           \u2013            <p>Resolve a name within this object's and parents' scope.</p> </li> <li> set_member           \u2013            <p>Set a member with its name or path.</p> </li> </ul> <p>Attributes:</p> <ul> <li> all_members             (<code>dict[str, Object | Alias]</code>)         \u2013          <p>All members (declared and inherited).</p> </li> <li> annotation             (<code>str | Expr | None</code>)         \u2013          <p>Return the return annotation.</p> </li> <li> attributes             (<code>dict[str, Attribute]</code>)         \u2013          <p>Return the attribute members.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Return the full dotted path of this object.</p> </li> <li> classes             (<code>dict[str, Class]</code>)         \u2013          <p>Return the class members.</p> </li> <li> filepath             (<code>Path | list[Path]</code>)         \u2013          <p>Return the file path where this object was defined.</p> </li> <li> functions             (<code>dict[str, Function]</code>)         \u2013          <p>Return the function members.</p> </li> <li> has_docstring             (<code>bool</code>)         \u2013          <p>Tell if this object has a non-empty docstring.</p> </li> <li> has_docstrings             (<code>bool</code>)         \u2013          <p>Tell if this object or any of its members has a non-empty docstring.</p> </li> <li> inherited_members             (<code>dict[str, Alias]</code>)         \u2013          <p>Members that are inherited from base classes.</p> </li> <li> is_attribute             (<code>bool</code>)         \u2013          <p>Tell if this object is an attribute.</p> </li> <li> is_class             (<code>bool</code>)         \u2013          <p>Tell if this object is a class.</p> </li> <li> is_explicitely_exported             (<code>bool</code>)         \u2013          <p>Tell if this object/alias is explicitely exported by its parent.</p> </li> <li> is_function             (<code>bool</code>)         \u2013          <p>Tell if this object is a function.</p> </li> <li> is_implicitely_exported             (<code>bool</code>)         \u2013          <p>Tell if this object/alias is implicitely exported by its parent.</p> </li> <li> is_module             (<code>bool</code>)         \u2013          <p>Tell if this object is a module.</p> </li> <li> lines             (<code>list[str]</code>)         \u2013          <p>Return the lines containing the source of this object.</p> </li> <li> lines_collection             (<code>LinesCollection</code>)         \u2013          <p>Return the lines collection attached to this object or its parents.</p> </li> <li> module             (<code>Module</code>)         \u2013          <p>Return the parent module of this object.</p> </li> <li> modules             (<code>dict[str, Module]</code>)         \u2013          <p>Return the module members.</p> </li> <li> modules_collection             (<code>ModulesCollection</code>)         \u2013          <p>Return the modules collection attached to this object or its parents.</p> </li> <li> package             (<code>Module</code>)         \u2013          <p>Return the absolute top module (the package) of this object.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Return the dotted path of this object.</p> </li> <li> relative_filepath             (<code>Path</code>)         \u2013          <p>Return the file path where this object was defined, relative to the current working directory.</p> </li> <li> relative_package_filepath             (<code>Path</code>)         \u2013          <p>Return the file path where this object was defined, relative to the top module path.</p> </li> <li> source             (<code>str</code>)         \u2013          <p>Return the source code of this object.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def __init__(\n    self,\n    *args: Any,\n    parameters: Parameters | None = None,\n    returns: str | Expr | None = None,\n    decorators: list[Decorator] | None = None,\n    **kwargs: Any,\n) -&gt; None:\n\"\"\"Initialize the function.\n\n    Parameters:\n        *args: See [`griffe.dataclasses.Object`][].\n        parameters: The function parameters.\n        returns: The function return annotation.\n        decorators: The function decorators, if any.\n        **kwargs: See [`griffe.dataclasses.Object`][].\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.parameters: Parameters = parameters or Parameters()\n    self.returns: str | Expr | None = returns\n    self.decorators: list[Decorator] = decorators or []\n    self.setter: Function | None = None\n    self.deleter: Function | None = None\n    self.overloads: list[Function] | None = None\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.all_members","title":"all_members  <code>property</code>","text":"<pre><code>all_members: dict[str, Object | Alias]\n</code></pre> <p>All members (declared and inherited).</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.annotation","title":"annotation  <code>property</code>","text":"<pre><code>annotation: str | Expr | None\n</code></pre> <p>Return the return annotation.</p> <p>Returns:</p> <ul> <li> <code>str | Expr | None</code>         \u2013          <p>The function return annotation.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.attributes","title":"attributes  <code>property</code>","text":"<pre><code>attributes: dict[str, Attribute]\n</code></pre> <p>Return the attribute members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Attribute]</code>         \u2013          <p>A dictionary of attributes.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Return the full dotted path of this object.</p> <p>The canonical path is the path where the object was defined (not imported).</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>A dotted path.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.classes","title":"classes  <code>property</code>","text":"<pre><code>classes: dict[str, Class]\n</code></pre> <p>Return the class members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Class]</code>         \u2013          <p>A dictionary of classes.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.filepath","title":"filepath  <code>property</code>","text":"<pre><code>filepath: Path | list[Path]\n</code></pre> <p>Return the file path where this object was defined.</p> <p>Returns:</p> <ul> <li> <code>Path | list[Path]</code>         \u2013          <p>A file path or a list of directories.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.functions","title":"functions  <code>property</code>","text":"<pre><code>functions: dict[str, Function]\n</code></pre> <p>Return the function members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Function]</code>         \u2013          <p>A dictionary of functions.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.has_docstring","title":"has_docstring  <code>property</code>","text":"<pre><code>has_docstring: bool\n</code></pre> <p>Tell if this object has a non-empty docstring.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.has_docstrings","title":"has_docstrings  <code>property</code>","text":"<pre><code>has_docstrings: bool\n</code></pre> <p>Tell if this object or any of its members has a non-empty docstring.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.inherited_members","title":"inherited_members  <code>cached</code> <code>property</code>","text":"<pre><code>inherited_members: dict[str, Alias]\n</code></pre> <p>Members that are inherited from base classes.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.is_attribute","title":"is_attribute  <code>property</code>","text":"<pre><code>is_attribute: bool\n</code></pre> <p>Tell if this object is an attribute.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.is_class","title":"is_class  <code>property</code>","text":"<pre><code>is_class: bool\n</code></pre> <p>Tell if this object is a class.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.is_explicitely_exported","title":"is_explicitely_exported  <code>property</code>","text":"<pre><code>is_explicitely_exported: bool\n</code></pre> <p>Tell if this object/alias is explicitely exported by its parent.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.is_function","title":"is_function  <code>property</code>","text":"<pre><code>is_function: bool\n</code></pre> <p>Tell if this object is a function.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.is_implicitely_exported","title":"is_implicitely_exported  <code>property</code>","text":"<pre><code>is_implicitely_exported: bool\n</code></pre> <p>Tell if this object/alias is implicitely exported by its parent.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.is_module","title":"is_module  <code>property</code>","text":"<pre><code>is_module: bool\n</code></pre> <p>Tell if this object is a module.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.lines","title":"lines  <code>property</code>","text":"<pre><code>lines: list[str]\n</code></pre> <p>Return the lines containing the source of this object.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>         \u2013          <p>A list of lines.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.lines_collection","title":"lines_collection  <code>property</code>","text":"<pre><code>lines_collection: LinesCollection\n</code></pre> <p>Return the lines collection attached to this object or its parents.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When no modules collection can be found in the object or its parents.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>LinesCollection</code>         \u2013          <p>A lines collection.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.module","title":"module  <code>property</code>","text":"<pre><code>module: Module\n</code></pre> <p>Return the parent module of this object.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When the object is not a module and does not have a parent.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013          <p>The parent module.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.modules","title":"modules  <code>property</code>","text":"<pre><code>modules: dict[str, Module]\n</code></pre> <p>Return the module members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Module]</code>         \u2013          <p>A dictionary of modules.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.modules_collection","title":"modules_collection  <code>property</code>","text":"<pre><code>modules_collection: ModulesCollection\n</code></pre> <p>Return the modules collection attached to this object or its parents.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When no modules collection can be found in the object or its parents.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ModulesCollection</code>         \u2013          <p>A modules collection.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.package","title":"package  <code>property</code>","text":"<pre><code>package: Module\n</code></pre> <p>Return the absolute top module (the package) of this object.</p> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013          <p>The parent module.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Return the dotted path of this object.</p> <p>On regular objects (not aliases), the path is the canonical path.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>A dotted path.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.relative_filepath","title":"relative_filepath  <code>property</code>","text":"<pre><code>relative_filepath: Path\n</code></pre> <p>Return the file path where this object was defined, relative to the current working directory.</p> <p>If this object's file path is not relative to the current working directory, return its absolute path.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When the relative path could not be computed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code>         \u2013          <p>A file path.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.relative_package_filepath","title":"relative_package_filepath  <code>property</code>","text":"<pre><code>relative_package_filepath: Path\n</code></pre> <p>Return the file path where this object was defined, relative to the top module path.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When the relative path could not be computed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code>         \u2013          <p>A file path.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.source","title":"source  <code>property</code>","text":"<pre><code>source: str\n</code></pre> <p>Return the source code of this object.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The source code.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.__delitem__","title":"__delitem__","text":"<pre><code>__delitem__(key: str | Sequence[str]) -&gt; None\n</code></pre> <p>Delete a member with its name or path.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Members will be looked up in both declared members and inherited ones, triggering computation of the latter.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; del griffe_object[\"foo\"]\n&gt;&gt;&gt; del griffe_object[\"path.to.bar\"]\n&gt;&gt;&gt; del griffe_object[(\"path\", \"to\", \"qux\")]\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def __delitem__(self, key: str | Sequence[str]) -&gt; None:\n\"\"\"Delete a member with its name or path.\n\n    This method is part of the consumer API:\n    do not use when producing Griffe trees!\n\n    Members will be looked up in both declared members and inherited ones,\n    triggering computation of the latter.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; del griffe_object[\"foo\"]\n        &gt;&gt;&gt; del griffe_object[\"path.to.bar\"]\n        &gt;&gt;&gt; del griffe_object[(\"path\", \"to\", \"qux\")]\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        try:\n            del self.members[name]  # type: ignore[attr-defined]\n        except KeyError:\n            del self.inherited_members[name]  # type: ignore[attr-defined]\n    else:\n        del self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key: str | Sequence[str]) -&gt; Any\n</code></pre> <p>Get a member with its name or path.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Members will be looked up in both declared members and inherited ones, triggering computation of the latter.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; foo = griffe_object[\"foo\"]\n&gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n&gt;&gt;&gt; qux = griffe_object[(\"path\", \"to\", \"qux\")]\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def __getitem__(self, key: str | Sequence[str]) -&gt; Any:\n\"\"\"Get a member with its name or path.\n\n    This method is part of the consumer API:\n    do not use when producing Griffe trees!\n\n    Members will be looked up in both declared members and inherited ones,\n    triggering computation of the latter.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; foo = griffe_object[\"foo\"]\n        &gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n        &gt;&gt;&gt; qux = griffe_object[(\"path\", \"to\", \"qux\")]\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        return self.all_members[parts[0]]  # type: ignore[attr-defined]\n    return self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(\n    key: str | Sequence[str], value: Object | Alias\n) -&gt; None\n</code></pre> <p>Set a member with its name or path.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> <li> value             (<code>Object | Alias</code>)         \u2013          <p>The member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; griffe_object[\"foo\"] = foo\n&gt;&gt;&gt; griffe_object[\"path.to.bar\"] = bar\n&gt;&gt;&gt; griffe_object[(\"path\", \"to\", \"qux\")] = qux\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def __setitem__(self, key: str | Sequence[str], value: Object | Alias) -&gt; None:\n\"\"\"Set a member with its name or path.\n\n    This method is part of the consumer API:\n    do not use when producing Griffe trees!\n\n    Parameters:\n        key: The name or path of the member.\n        value: The member.\n\n    Examples:\n        &gt;&gt;&gt; griffe_object[\"foo\"] = foo\n        &gt;&gt;&gt; griffe_object[\"path.to.bar\"] = bar\n        &gt;&gt;&gt; griffe_object[(\"path\", \"to\", \"qux\")] = qux\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        self.members[name] = value  # type: ignore[attr-defined]\n        if self.is_collection:  # type: ignore[attr-defined]\n            value._modules_collection = self  # type: ignore[union-attr]\n        else:\n            value.parent = self  # type: ignore[assignment]\n    else:\n        self.members[parts[0]][parts[1:]] = value  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return this function's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return this function's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    base = super().as_dict(**kwargs)\n    base[\"decorators\"] = [dec.as_dict(**kwargs) for dec in self.decorators]\n    base[\"parameters\"] = [param.as_dict(**kwargs) for param in self.parameters]\n    base[\"returns\"] = self.returns\n    return base\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.as_json","title":"as_json","text":"<pre><code>as_json(*, full: bool = False, **kwargs: Any) -&gt; str\n</code></pre> <p>Return this object's data as a JSON string.</p> <p>Parameters:</p> <ul> <li> full             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to return full info, or just base info.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options passed to encoder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>A JSON string.</p> </li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>def as_json(self, *, full: bool = False, **kwargs: Any) -&gt; str:\n\"\"\"Return this object's data as a JSON string.\n\n    Parameters:\n        full: Whether to return full info, or just base info.\n        **kwargs: Additional serialization options passed to encoder.\n\n    Returns:\n        A JSON string.\n    \"\"\"\n    from griffe.encoders import JSONEncoder  # avoid circular import\n\n    return json.dumps(self, cls=JSONEncoder, full=full, **kwargs)\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.del_member","title":"del_member","text":"<pre><code>del_member(key: str | Sequence[str]) -&gt; None\n</code></pre> <p>Delete a member with its name or path.</p> <p>This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).</p> <p>Members will be looked up in declared members only, not inherited ones.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; griffe_object.del_member(\"foo\")\n&gt;&gt;&gt; griffe_object.del_member(\"path.to.bar\")\n&gt;&gt;&gt; griffe_object.del_member((\"path\", \"to\", \"qux\"))\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def del_member(self, key: str | Sequence[str]) -&gt; None:\n\"\"\"Delete a member with its name or path.\n\n    This method is part of the producer API:\n    you can use it safely while building Griffe trees\n    (for example in Griffe extensions).\n\n    Members will be looked up in declared members only, not inherited ones.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; griffe_object.del_member(\"foo\")\n        &gt;&gt;&gt; griffe_object.del_member(\"path.to.bar\")\n        &gt;&gt;&gt; griffe_object.del_member((\"path\", \"to\", \"qux\"))\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        del self.members[name]  # type: ignore[attr-defined]\n    else:\n        self.members[parts[0]].del_member(parts[1:])  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.filter_members","title":"filter_members","text":"<pre><code>filter_members(\n    *predicates: Callable[[Object | Alias], bool]\n) -&gt; dict[str, Object | Alias]\n</code></pre> <p>Filter and return members based on predicates.</p> <p>Parameters:</p> <ul> <li> *predicates             (<code>Callable[[Object | Alias], bool]</code>, default:                 <code>()</code> )         \u2013          <p>A list of predicates, i.e. callables accepting a member as argument and returning a boolean.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Object | Alias]</code>         \u2013          <p>A dictionary of members.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def filter_members(self, *predicates: Callable[[Object | Alias], bool]) -&gt; dict[str, Object | Alias]:\n\"\"\"Filter and return members based on predicates.\n\n    Parameters:\n        *predicates: A list of predicates, i.e. callables accepting a member as argument and returning a boolean.\n\n    Returns:\n        A dictionary of members.\n    \"\"\"\n    if not predicates:\n        return self.members\n    members: dict[str, Object | Alias] = {}\n    for name, member in self.members.items():\n        if all(predicate(member) for predicate in predicates):\n            members[name] = member\n    return members\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_string: str, **kwargs: Any) -&gt; _ObjType\n</code></pre> <p>Create an instance of this class from a JSON string.</p> <p>Parameters:</p> <ul> <li> json_string             (<code>str</code>)         \u2013          <p>JSON to decode into Object.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional options passed to decoder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_ObjType</code>         \u2013          <p>An Object instance.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>           \u2013          <p>When the json_string does not represent and object of the class from which this classmethod has been called.</p> </li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>@classmethod\ndef from_json(cls: type[_ObjType], json_string: str, **kwargs: Any) -&gt; _ObjType:  # noqa: PYI019\n\"\"\"Create an instance of this class from a JSON string.\n\n    Parameters:\n        json_string: JSON to decode into Object.\n        **kwargs: Additional options passed to decoder.\n\n    Returns:\n        An Object instance.\n\n    Raises:\n        TypeError: When the json_string does not represent and object\n            of the class from which this classmethod has been called.\n    \"\"\"\n    from griffe.encoders import json_decoder  # avoid circular import\n\n    kwargs.setdefault(\"object_hook\", json_decoder)\n    obj = json.loads(json_string, **kwargs)\n    if not isinstance(obj, cls):\n        raise TypeError(f\"provided JSON object is not of type {cls}\")\n    return obj\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.get_member","title":"get_member","text":"<pre><code>get_member(key: str | Sequence[str]) -&gt; Any\n</code></pre> <p>Get a member with its name or path.</p> <p>This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).</p> <p>Members will be looked up in declared members only, not inherited ones.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; foo = griffe_object[\"foo\"]\n&gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n&gt;&gt;&gt; bar = griffe_object[(\"path\", \"to\", \"bar\")]\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def get_member(self, key: str | Sequence[str]) -&gt; Any:\n\"\"\"Get a member with its name or path.\n\n    This method is part of the producer API:\n    you can use it safely while building Griffe trees\n    (for example in Griffe extensions).\n\n    Members will be looked up in declared members only, not inherited ones.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; foo = griffe_object[\"foo\"]\n        &gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n        &gt;&gt;&gt; bar = griffe_object[(\"path\", \"to\", \"bar\")]\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        return self.members[parts[0]]  # type: ignore[attr-defined]\n    return self.members[parts[0]].get_member(parts[1:])  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.has_labels","title":"has_labels","text":"<pre><code>has_labels(labels: set[str]) -&gt; bool\n</code></pre> <p>Tell if this object has all the given labels.</p> <p>Parameters:</p> <ul> <li> labels             (<code>set[str]</code>)         \u2013          <p>A set of labels.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def has_labels(self, labels: set[str]) -&gt; bool:\n\"\"\"Tell if this object has all the given labels.\n\n    Parameters:\n        labels: A set of labels.\n\n    Returns:\n        True or False.\n    \"\"\"\n    return all(label in self.labels for label in labels)\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.is_exported","title":"is_exported","text":"<pre><code>is_exported(*, explicitely: bool = True) -&gt; bool\n</code></pre> <p>Tell if this object/alias is implicitely exported by its parent.</p> <p>Parameters:</p> <ul> <li> explicitely             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to only return True when <code>__all__</code> is defined.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>def is_exported(self, *, explicitely: bool = True) -&gt; bool:\n\"\"\"Tell if this object/alias is implicitely exported by its parent.\n\n    Parameters:\n        explicitely: Whether to only return True when `__all__` is defined.\n\n    Returns:\n        True or False.\n    \"\"\"\n    return self.parent.member_is_exported(self, explicitely=explicitely)  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.is_kind","title":"is_kind","text":"<pre><code>is_kind(kind: str | Kind | set[str | Kind]) -&gt; bool\n</code></pre> <p>Tell if this object is of the given kind.</p> <p>Parameters:</p> <ul> <li> kind             (<code>str | Kind | set[str | Kind]</code>)         \u2013          <p>An instance or set of kinds (strings or enumerations).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When an empty set is given as argument.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def is_kind(self, kind: str | Kind | set[str | Kind]) -&gt; bool:\n\"\"\"Tell if this object is of the given kind.\n\n    Parameters:\n        kind: An instance or set of kinds (strings or enumerations).\n\n    Raises:\n        ValueError: When an empty set is given as argument.\n\n    Returns:\n        True or False.\n    \"\"\"\n    if isinstance(kind, set):\n        if not kind:\n            raise ValueError(\"kind must not be an empty set\")\n        return self.kind in (knd if isinstance(knd, Kind) else Kind(knd) for knd in kind)\n    if isinstance(kind, str):\n        kind = Kind(kind)\n    return self.kind is kind\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.is_public","title":"is_public","text":"<pre><code>is_public(\n    *, strict: bool = False, check_name: bool = True\n) -&gt; bool\n</code></pre> <p>Whether this object is considered public.</p> <p>In modules, developers can mark objects as public thanks to the <code>__all__</code> variable. In classes however, there is no convention or standard to do so.</p> <p>Therefore, to decide whether an object is public, we follow this algorithm:</p> <ul> <li>If the object's <code>public</code> attribute is set (boolean), return its value.</li> <li>In strict mode, the object is public only if it is explicitely exported (listed in <code>__all__</code>).     Strict mode should only be used for module members.</li> <li>Otherwise, if name checks are enabled, the object is private if its name starts with an underscore.</li> <li>Otherwise, if the object is an alias, and is neither inherited from a base class,     nor a member of a parent alias, it is not public.</li> <li>Otherwise, the object is public.</li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>def is_public(\n    self,\n    *,\n    strict: bool = False,\n    check_name: bool = True,\n) -&gt; bool:\n\"\"\"Whether this object is considered public.\n\n    In modules, developers can mark objects as public thanks to the `__all__` variable.\n    In classes however, there is no convention or standard to do so.\n\n    Therefore, to decide whether an object is public, we follow this algorithm:\n\n    - If the object's `public` attribute is set (boolean), return its value.\n    - In strict mode, the object is public only if it is explicitely exported (listed in `__all__`).\n        Strict mode should only be used for module members.\n    - Otherwise, if name checks are enabled, the object is private if its name starts with an underscore.\n    - Otherwise, if the object is an alias, and is neither inherited from a base class,\n        nor a member of a parent alias, it is not public.\n    - Otherwise, the object is public.\n    \"\"\"\n    if self.public is not None:  # type: ignore[attr-defined]\n        return self.public  # type: ignore[attr-defined]\n    if self.is_explicitely_exported:\n        return True\n    if strict:\n        return False\n    if check_name and self.name.startswith(\"_\"):  # type: ignore[attr-defined]\n        return False\n    if self.is_alias and not (self.inherited or self.parent.is_alias):  # type: ignore[attr-defined]\n        return False\n    return True\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.member_is_exported","title":"member_is_exported","text":"<pre><code>member_is_exported(\n    member: Object | Alias, *, explicitely: bool = True\n) -&gt; bool\n</code></pre> <p>Tell if a member of this object is \"exported\".</p> <p>By exported, we mean that the object is included in the <code>__all__</code> attribute of its parent module or class. When <code>__all__</code> is not defined, we consider the member to be implicitely exported, unless it's a module and it was not imported, and unless it's not defined at runtime.</p> <p>Parameters:</p> <ul> <li> member             (<code>Object | Alias</code>)         \u2013          <p>The member to verify.</p> </li> <li> explicitely             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to only return True when <code>__all__</code> is defined.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def member_is_exported(self, member: Object | Alias, *, explicitely: bool = True) -&gt; bool:\n\"\"\"Tell if a member of this object is \"exported\".\n\n    By exported, we mean that the object is included in the `__all__` attribute\n    of its parent module or class. When `__all__` is not defined,\n    we consider the member to be *implicitely* exported,\n    unless it's a module and it was not imported,\n    and unless it's not defined at runtime.\n\n    Parameters:\n        member: The member to verify.\n        explicitely: Whether to only return True when `__all__` is defined.\n\n    Returns:\n        True or False.\n    \"\"\"\n    if not member.runtime:\n        return False\n    if self.exports is None:\n        return not explicitely and (member.is_alias or not member.is_module or member.name in self.imports)\n    return member.name in self.exports\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.resolve","title":"resolve","text":"<pre><code>resolve(name: str) -&gt; str\n</code></pre> <p>Resolve a name within this object's and parents' scope.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013          <p>The name to resolve.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NameResolutionError</code>           \u2013          <p>When the name could not be resolved.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The resolved name.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def resolve(self, name: str) -&gt; str:\n\"\"\"Resolve a name within this object's and parents' scope.\n\n    Parameters:\n        name: The name to resolve.\n\n    Raises:\n        NameResolutionError: When the name could not be resolved.\n\n    Returns:\n        The resolved name.\n    \"\"\"\n    if name in self.members:\n        if self.members[name].is_alias:\n            return self.members[name].target_path  # type: ignore[union-attr]\n        return self.members[name].path\n    if name in self.imports:\n        return self.imports[name]\n    if self.parent is None:\n        # could be a built-in\n        raise NameResolutionError(f\"{name} could not be resolved in the scope of {self.path}\")\n    if name == self.parent.name and not self.parent.is_module:\n        return self.parent.path\n    return self.parent.resolve(name)\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.set_member","title":"set_member","text":"<pre><code>set_member(\n    key: str | Sequence[str], value: Object | Alias\n) -&gt; None\n</code></pre> <p>Set a member with its name or path.</p> <p>This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> <li> value             (<code>Object | Alias</code>)         \u2013          <p>The member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; griffe_object.set_member(\"foo\", foo)\n&gt;&gt;&gt; griffe_object.set_member(\"path.to.bar\", bar)\n&gt;&gt;&gt; griffe_object.set_member((\"path\", \"to\", \"qux\", qux)\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def set_member(self, key: str | Sequence[str], value: Object | Alias) -&gt; None:\n\"\"\"Set a member with its name or path.\n\n    This method is part of the producer API:\n    you can use it safely while building Griffe trees\n    (for example in Griffe extensions).\n\n    Parameters:\n        key: The name or path of the member.\n        value: The member.\n\n    Examples:\n        &gt;&gt;&gt; griffe_object.set_member(\"foo\", foo)\n        &gt;&gt;&gt; griffe_object.set_member(\"path.to.bar\", bar)\n        &gt;&gt;&gt; griffe_object.set_member((\"path\", \"to\", \"qux\", qux)\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        if name in self.members:  # type: ignore[attr-defined]\n            member = self.members[name]  # type: ignore[attr-defined]\n            if not member.is_alias:\n                # when reassigning a module to an existing one,\n                # try to merge them as one regular and one stubs module\n                # (implicit support for .pyi modules)\n                if member.is_module and not (member.is_namespace_package or member.is_namespace_subpackage):\n                    with suppress(AliasResolutionError, CyclicAliasError):\n                        if value.is_module and value.filepath != member.filepath:\n                            with suppress(ValueError):\n                                value = merge_stubs(member, value)  # type: ignore[arg-type]\n                for alias in member.aliases.values():\n                    with suppress(CyclicAliasError):\n                        alias.target = value\n        self.members[name] = value  # type: ignore[attr-defined]\n        if self.is_collection:  # type: ignore[attr-defined]\n            value._modules_collection = self  # type: ignore[union-attr]\n        else:\n            value.parent = self  # type: ignore[assignment]\n    else:\n        self.members[parts[0]].set_member(parts[1:], value)  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Kind","title":"Kind","text":"<p>             Bases: <code>Enum</code></p> <p>Enumeration of the different objects kinds.</p> <p>Attributes:</p> <ul> <li> MODULE             (<code>str</code>)         \u2013          <p>The module kind.</p> </li> <li> CLASS             (<code>str</code>)         \u2013          <p>The class kind.</p> </li> <li> FUNCTION             (<code>str</code>)         \u2013          <p>The function kind.</p> </li> <li> ATTRIBUTE             (<code>str</code>)         \u2013          <p>The attribute kind.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module","title":"Module","text":"<pre><code>Module(\n    *args: Any,\n    filepath: Path | list[Path] | None = None,\n    **kwargs: Any\n)\n</code></pre> <p>             Bases: <code>Object</code></p> <p>The class representing a Python module.</p> <p>Parameters:</p> <ul> <li> *args             (<code>Any</code>, default:                 <code>()</code> )         \u2013          <p>See <code>griffe.dataclasses.Object</code>.</p> </li> <li> filepath             (<code>Path | list[Path] | None</code>, default:                 <code>None</code> )         \u2013          <p>The module file path (directory for namespace [sub]packages, none for builtin modules).</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>See <code>griffe.dataclasses.Object</code>.</p> </li> </ul> <p>Methods:</p> <ul> <li> __delitem__           \u2013            <p>Delete a member with its name or path.</p> </li> <li> __getitem__           \u2013            <p>Get a member with its name or path.</p> </li> <li> __setitem__           \u2013            <p>Set a member with its name or path.</p> </li> <li> as_dict           \u2013            <p>Return this module's data as a dictionary.</p> </li> <li> as_json           \u2013            <p>Return this object's data as a JSON string.</p> </li> <li> del_member           \u2013            <p>Delete a member with its name or path.</p> </li> <li> filter_members           \u2013            <p>Filter and return members based on predicates.</p> </li> <li> from_json           \u2013            <p>Create an instance of this class from a JSON string.</p> </li> <li> get_member           \u2013            <p>Get a member with its name or path.</p> </li> <li> has_labels           \u2013            <p>Tell if this object has all the given labels.</p> </li> <li> is_exported           \u2013            <p>Tell if this object/alias is implicitely exported by its parent.</p> </li> <li> is_kind           \u2013            <p>Tell if this object is of the given kind.</p> </li> <li> is_public           \u2013            <p>Whether this object is considered public.</p> </li> <li> member_is_exported           \u2013            <p>Tell if a member of this object is \"exported\".</p> </li> <li> resolve           \u2013            <p>Resolve a name within this object's and parents' scope.</p> </li> <li> set_member           \u2013            <p>Set a member with its name or path.</p> </li> </ul> <p>Attributes:</p> <ul> <li> all_members             (<code>dict[str, Object | Alias]</code>)         \u2013          <p>All members (declared and inherited).</p> </li> <li> attributes             (<code>dict[str, Attribute]</code>)         \u2013          <p>Return the attribute members.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Return the full dotted path of this object.</p> </li> <li> classes             (<code>dict[str, Class]</code>)         \u2013          <p>Return the class members.</p> </li> <li> filepath             (<code>Path | list[Path]</code>)         \u2013          <p>Get the file path of this module.</p> </li> <li> functions             (<code>dict[str, Function]</code>)         \u2013          <p>Return the function members.</p> </li> <li> has_docstring             (<code>bool</code>)         \u2013          <p>Tell if this object has a non-empty docstring.</p> </li> <li> has_docstrings             (<code>bool</code>)         \u2013          <p>Tell if this object or any of its members has a non-empty docstring.</p> </li> <li> imports_future_annotations             (<code>bool</code>)         \u2013          <p>Tell whether this module import future annotations.</p> </li> <li> inherited_members             (<code>dict[str, Alias]</code>)         \u2013          <p>Members that are inherited from base classes.</p> </li> <li> is_attribute             (<code>bool</code>)         \u2013          <p>Tell if this object is an attribute.</p> </li> <li> is_class             (<code>bool</code>)         \u2013          <p>Tell if this object is a class.</p> </li> <li> is_explicitely_exported             (<code>bool</code>)         \u2013          <p>Tell if this object/alias is explicitely exported by its parent.</p> </li> <li> is_function             (<code>bool</code>)         \u2013          <p>Tell if this object is a function.</p> </li> <li> is_implicitely_exported             (<code>bool</code>)         \u2013          <p>Tell if this object/alias is implicitely exported by its parent.</p> </li> <li> is_init_module             (<code>bool</code>)         \u2013          <p>Tell if this module is an <code>__init__.py</code> module.</p> </li> <li> is_module             (<code>bool</code>)         \u2013          <p>Tell if this object is a module.</p> </li> <li> is_namespace_package             (<code>bool</code>)         \u2013          <p>Tell if this module is a namespace package (top folder, no <code>__init__.py</code>).</p> </li> <li> is_namespace_subpackage             (<code>bool</code>)         \u2013          <p>Tell if this module is a namespace subpackage.</p> </li> <li> is_package             (<code>bool</code>)         \u2013          <p>Tell if this module is a package (top module).</p> </li> <li> is_subpackage             (<code>bool</code>)         \u2013          <p>Tell if this module is a subpackage.</p> </li> <li> lines             (<code>list[str]</code>)         \u2013          <p>Return the lines containing the source of this object.</p> </li> <li> lines_collection             (<code>LinesCollection</code>)         \u2013          <p>Return the lines collection attached to this object or its parents.</p> </li> <li> module             (<code>Module</code>)         \u2013          <p>Return the parent module of this object.</p> </li> <li> modules             (<code>dict[str, Module]</code>)         \u2013          <p>Return the module members.</p> </li> <li> modules_collection             (<code>ModulesCollection</code>)         \u2013          <p>Return the modules collection attached to this object or its parents.</p> </li> <li> package             (<code>Module</code>)         \u2013          <p>Return the absolute top module (the package) of this object.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Return the dotted path of this object.</p> </li> <li> relative_filepath             (<code>Path</code>)         \u2013          <p>Return the file path where this object was defined, relative to the current working directory.</p> </li> <li> relative_package_filepath             (<code>Path</code>)         \u2013          <p>Return the file path where this object was defined, relative to the top module path.</p> </li> <li> source             (<code>str</code>)         \u2013          <p>Return the source code of this object.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def __init__(self, *args: Any, filepath: Path | list[Path] | None = None, **kwargs: Any) -&gt; None:\n\"\"\"Initialize the module.\n\n    Parameters:\n        *args: See [`griffe.dataclasses.Object`][].\n        filepath: The module file path (directory for namespace [sub]packages, none for builtin modules).\n        **kwargs: See [`griffe.dataclasses.Object`][].\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self._filepath: Path | list[Path] | None = filepath\n    self.overloads: dict[str, list[Function]] = defaultdict(list)\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.all_members","title":"all_members  <code>property</code>","text":"<pre><code>all_members: dict[str, Object | Alias]\n</code></pre> <p>All members (declared and inherited).</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.attributes","title":"attributes  <code>property</code>","text":"<pre><code>attributes: dict[str, Attribute]\n</code></pre> <p>Return the attribute members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Attribute]</code>         \u2013          <p>A dictionary of attributes.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Return the full dotted path of this object.</p> <p>The canonical path is the path where the object was defined (not imported).</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>A dotted path.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.classes","title":"classes  <code>property</code>","text":"<pre><code>classes: dict[str, Class]\n</code></pre> <p>Return the class members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Class]</code>         \u2013          <p>A dictionary of classes.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.filepath","title":"filepath  <code>property</code>","text":"<pre><code>filepath: Path | list[Path]\n</code></pre> <p>Get the file path of this module.</p> <p>Raises:</p> <ul> <li> <code>BuiltinModuleError</code>           \u2013          <p>When the instance filepath is None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path | list[Path]</code>         \u2013          <p>The module's file path.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.functions","title":"functions  <code>property</code>","text":"<pre><code>functions: dict[str, Function]\n</code></pre> <p>Return the function members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Function]</code>         \u2013          <p>A dictionary of functions.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.has_docstring","title":"has_docstring  <code>property</code>","text":"<pre><code>has_docstring: bool\n</code></pre> <p>Tell if this object has a non-empty docstring.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.has_docstrings","title":"has_docstrings  <code>property</code>","text":"<pre><code>has_docstrings: bool\n</code></pre> <p>Tell if this object or any of its members has a non-empty docstring.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.imports_future_annotations","title":"imports_future_annotations  <code>property</code>","text":"<pre><code>imports_future_annotations: bool\n</code></pre> <p>Tell whether this module import future annotations.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or false.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.inherited_members","title":"inherited_members  <code>cached</code> <code>property</code>","text":"<pre><code>inherited_members: dict[str, Alias]\n</code></pre> <p>Members that are inherited from base classes.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_attribute","title":"is_attribute  <code>property</code>","text":"<pre><code>is_attribute: bool\n</code></pre> <p>Tell if this object is an attribute.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_class","title":"is_class  <code>property</code>","text":"<pre><code>is_class: bool\n</code></pre> <p>Tell if this object is a class.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_explicitely_exported","title":"is_explicitely_exported  <code>property</code>","text":"<pre><code>is_explicitely_exported: bool\n</code></pre> <p>Tell if this object/alias is explicitely exported by its parent.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_function","title":"is_function  <code>property</code>","text":"<pre><code>is_function: bool\n</code></pre> <p>Tell if this object is a function.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_implicitely_exported","title":"is_implicitely_exported  <code>property</code>","text":"<pre><code>is_implicitely_exported: bool\n</code></pre> <p>Tell if this object/alias is implicitely exported by its parent.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_init_module","title":"is_init_module  <code>property</code>","text":"<pre><code>is_init_module: bool\n</code></pre> <p>Tell if this module is an <code>__init__.py</code> module.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_module","title":"is_module  <code>property</code>","text":"<pre><code>is_module: bool\n</code></pre> <p>Tell if this object is a module.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_namespace_package","title":"is_namespace_package  <code>property</code>","text":"<pre><code>is_namespace_package: bool\n</code></pre> <p>Tell if this module is a namespace package (top folder, no <code>__init__.py</code>).</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_namespace_subpackage","title":"is_namespace_subpackage  <code>property</code>","text":"<pre><code>is_namespace_subpackage: bool\n</code></pre> <p>Tell if this module is a namespace subpackage.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_package","title":"is_package  <code>property</code>","text":"<pre><code>is_package: bool\n</code></pre> <p>Tell if this module is a package (top module).</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_subpackage","title":"is_subpackage  <code>property</code>","text":"<pre><code>is_subpackage: bool\n</code></pre> <p>Tell if this module is a subpackage.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.lines","title":"lines  <code>property</code>","text":"<pre><code>lines: list[str]\n</code></pre> <p>Return the lines containing the source of this object.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>         \u2013          <p>A list of lines.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.lines_collection","title":"lines_collection  <code>property</code>","text":"<pre><code>lines_collection: LinesCollection\n</code></pre> <p>Return the lines collection attached to this object or its parents.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When no modules collection can be found in the object or its parents.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>LinesCollection</code>         \u2013          <p>A lines collection.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.module","title":"module  <code>property</code>","text":"<pre><code>module: Module\n</code></pre> <p>Return the parent module of this object.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When the object is not a module and does not have a parent.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013          <p>The parent module.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.modules","title":"modules  <code>property</code>","text":"<pre><code>modules: dict[str, Module]\n</code></pre> <p>Return the module members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Module]</code>         \u2013          <p>A dictionary of modules.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.modules_collection","title":"modules_collection  <code>property</code>","text":"<pre><code>modules_collection: ModulesCollection\n</code></pre> <p>Return the modules collection attached to this object or its parents.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When no modules collection can be found in the object or its parents.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ModulesCollection</code>         \u2013          <p>A modules collection.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.package","title":"package  <code>property</code>","text":"<pre><code>package: Module\n</code></pre> <p>Return the absolute top module (the package) of this object.</p> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013          <p>The parent module.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Return the dotted path of this object.</p> <p>On regular objects (not aliases), the path is the canonical path.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>A dotted path.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.relative_filepath","title":"relative_filepath  <code>property</code>","text":"<pre><code>relative_filepath: Path\n</code></pre> <p>Return the file path where this object was defined, relative to the current working directory.</p> <p>If this object's file path is not relative to the current working directory, return its absolute path.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When the relative path could not be computed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code>         \u2013          <p>A file path.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.relative_package_filepath","title":"relative_package_filepath  <code>property</code>","text":"<pre><code>relative_package_filepath: Path\n</code></pre> <p>Return the file path where this object was defined, relative to the top module path.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When the relative path could not be computed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code>         \u2013          <p>A file path.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.source","title":"source  <code>property</code>","text":"<pre><code>source: str\n</code></pre> <p>Return the source code of this object.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The source code.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.__delitem__","title":"__delitem__","text":"<pre><code>__delitem__(key: str | Sequence[str]) -&gt; None\n</code></pre> <p>Delete a member with its name or path.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Members will be looked up in both declared members and inherited ones, triggering computation of the latter.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; del griffe_object[\"foo\"]\n&gt;&gt;&gt; del griffe_object[\"path.to.bar\"]\n&gt;&gt;&gt; del griffe_object[(\"path\", \"to\", \"qux\")]\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def __delitem__(self, key: str | Sequence[str]) -&gt; None:\n\"\"\"Delete a member with its name or path.\n\n    This method is part of the consumer API:\n    do not use when producing Griffe trees!\n\n    Members will be looked up in both declared members and inherited ones,\n    triggering computation of the latter.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; del griffe_object[\"foo\"]\n        &gt;&gt;&gt; del griffe_object[\"path.to.bar\"]\n        &gt;&gt;&gt; del griffe_object[(\"path\", \"to\", \"qux\")]\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        try:\n            del self.members[name]  # type: ignore[attr-defined]\n        except KeyError:\n            del self.inherited_members[name]  # type: ignore[attr-defined]\n    else:\n        del self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key: str | Sequence[str]) -&gt; Any\n</code></pre> <p>Get a member with its name or path.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Members will be looked up in both declared members and inherited ones, triggering computation of the latter.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; foo = griffe_object[\"foo\"]\n&gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n&gt;&gt;&gt; qux = griffe_object[(\"path\", \"to\", \"qux\")]\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def __getitem__(self, key: str | Sequence[str]) -&gt; Any:\n\"\"\"Get a member with its name or path.\n\n    This method is part of the consumer API:\n    do not use when producing Griffe trees!\n\n    Members will be looked up in both declared members and inherited ones,\n    triggering computation of the latter.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; foo = griffe_object[\"foo\"]\n        &gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n        &gt;&gt;&gt; qux = griffe_object[(\"path\", \"to\", \"qux\")]\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        return self.all_members[parts[0]]  # type: ignore[attr-defined]\n    return self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(\n    key: str | Sequence[str], value: Object | Alias\n) -&gt; None\n</code></pre> <p>Set a member with its name or path.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> <li> value             (<code>Object | Alias</code>)         \u2013          <p>The member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; griffe_object[\"foo\"] = foo\n&gt;&gt;&gt; griffe_object[\"path.to.bar\"] = bar\n&gt;&gt;&gt; griffe_object[(\"path\", \"to\", \"qux\")] = qux\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def __setitem__(self, key: str | Sequence[str], value: Object | Alias) -&gt; None:\n\"\"\"Set a member with its name or path.\n\n    This method is part of the consumer API:\n    do not use when producing Griffe trees!\n\n    Parameters:\n        key: The name or path of the member.\n        value: The member.\n\n    Examples:\n        &gt;&gt;&gt; griffe_object[\"foo\"] = foo\n        &gt;&gt;&gt; griffe_object[\"path.to.bar\"] = bar\n        &gt;&gt;&gt; griffe_object[(\"path\", \"to\", \"qux\")] = qux\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        self.members[name] = value  # type: ignore[attr-defined]\n        if self.is_collection:  # type: ignore[attr-defined]\n            value._modules_collection = self  # type: ignore[union-attr]\n        else:\n            value.parent = self  # type: ignore[assignment]\n    else:\n        self.members[parts[0]][parts[1:]] = value  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return this module's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return this module's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    base = super().as_dict(**kwargs)\n    base[\"filepath\"] = str(self._filepath) if self._filepath else None\n    return base\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.as_json","title":"as_json","text":"<pre><code>as_json(*, full: bool = False, **kwargs: Any) -&gt; str\n</code></pre> <p>Return this object's data as a JSON string.</p> <p>Parameters:</p> <ul> <li> full             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to return full info, or just base info.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options passed to encoder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>A JSON string.</p> </li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>def as_json(self, *, full: bool = False, **kwargs: Any) -&gt; str:\n\"\"\"Return this object's data as a JSON string.\n\n    Parameters:\n        full: Whether to return full info, or just base info.\n        **kwargs: Additional serialization options passed to encoder.\n\n    Returns:\n        A JSON string.\n    \"\"\"\n    from griffe.encoders import JSONEncoder  # avoid circular import\n\n    return json.dumps(self, cls=JSONEncoder, full=full, **kwargs)\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.del_member","title":"del_member","text":"<pre><code>del_member(key: str | Sequence[str]) -&gt; None\n</code></pre> <p>Delete a member with its name or path.</p> <p>This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).</p> <p>Members will be looked up in declared members only, not inherited ones.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; griffe_object.del_member(\"foo\")\n&gt;&gt;&gt; griffe_object.del_member(\"path.to.bar\")\n&gt;&gt;&gt; griffe_object.del_member((\"path\", \"to\", \"qux\"))\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def del_member(self, key: str | Sequence[str]) -&gt; None:\n\"\"\"Delete a member with its name or path.\n\n    This method is part of the producer API:\n    you can use it safely while building Griffe trees\n    (for example in Griffe extensions).\n\n    Members will be looked up in declared members only, not inherited ones.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; griffe_object.del_member(\"foo\")\n        &gt;&gt;&gt; griffe_object.del_member(\"path.to.bar\")\n        &gt;&gt;&gt; griffe_object.del_member((\"path\", \"to\", \"qux\"))\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        del self.members[name]  # type: ignore[attr-defined]\n    else:\n        self.members[parts[0]].del_member(parts[1:])  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.filter_members","title":"filter_members","text":"<pre><code>filter_members(\n    *predicates: Callable[[Object | Alias], bool]\n) -&gt; dict[str, Object | Alias]\n</code></pre> <p>Filter and return members based on predicates.</p> <p>Parameters:</p> <ul> <li> *predicates             (<code>Callable[[Object | Alias], bool]</code>, default:                 <code>()</code> )         \u2013          <p>A list of predicates, i.e. callables accepting a member as argument and returning a boolean.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Object | Alias]</code>         \u2013          <p>A dictionary of members.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def filter_members(self, *predicates: Callable[[Object | Alias], bool]) -&gt; dict[str, Object | Alias]:\n\"\"\"Filter and return members based on predicates.\n\n    Parameters:\n        *predicates: A list of predicates, i.e. callables accepting a member as argument and returning a boolean.\n\n    Returns:\n        A dictionary of members.\n    \"\"\"\n    if not predicates:\n        return self.members\n    members: dict[str, Object | Alias] = {}\n    for name, member in self.members.items():\n        if all(predicate(member) for predicate in predicates):\n            members[name] = member\n    return members\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_string: str, **kwargs: Any) -&gt; _ObjType\n</code></pre> <p>Create an instance of this class from a JSON string.</p> <p>Parameters:</p> <ul> <li> json_string             (<code>str</code>)         \u2013          <p>JSON to decode into Object.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional options passed to decoder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_ObjType</code>         \u2013          <p>An Object instance.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>           \u2013          <p>When the json_string does not represent and object of the class from which this classmethod has been called.</p> </li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>@classmethod\ndef from_json(cls: type[_ObjType], json_string: str, **kwargs: Any) -&gt; _ObjType:  # noqa: PYI019\n\"\"\"Create an instance of this class from a JSON string.\n\n    Parameters:\n        json_string: JSON to decode into Object.\n        **kwargs: Additional options passed to decoder.\n\n    Returns:\n        An Object instance.\n\n    Raises:\n        TypeError: When the json_string does not represent and object\n            of the class from which this classmethod has been called.\n    \"\"\"\n    from griffe.encoders import json_decoder  # avoid circular import\n\n    kwargs.setdefault(\"object_hook\", json_decoder)\n    obj = json.loads(json_string, **kwargs)\n    if not isinstance(obj, cls):\n        raise TypeError(f\"provided JSON object is not of type {cls}\")\n    return obj\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.get_member","title":"get_member","text":"<pre><code>get_member(key: str | Sequence[str]) -&gt; Any\n</code></pre> <p>Get a member with its name or path.</p> <p>This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).</p> <p>Members will be looked up in declared members only, not inherited ones.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; foo = griffe_object[\"foo\"]\n&gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n&gt;&gt;&gt; bar = griffe_object[(\"path\", \"to\", \"bar\")]\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def get_member(self, key: str | Sequence[str]) -&gt; Any:\n\"\"\"Get a member with its name or path.\n\n    This method is part of the producer API:\n    you can use it safely while building Griffe trees\n    (for example in Griffe extensions).\n\n    Members will be looked up in declared members only, not inherited ones.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; foo = griffe_object[\"foo\"]\n        &gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n        &gt;&gt;&gt; bar = griffe_object[(\"path\", \"to\", \"bar\")]\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        return self.members[parts[0]]  # type: ignore[attr-defined]\n    return self.members[parts[0]].get_member(parts[1:])  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.has_labels","title":"has_labels","text":"<pre><code>has_labels(labels: set[str]) -&gt; bool\n</code></pre> <p>Tell if this object has all the given labels.</p> <p>Parameters:</p> <ul> <li> labels             (<code>set[str]</code>)         \u2013          <p>A set of labels.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def has_labels(self, labels: set[str]) -&gt; bool:\n\"\"\"Tell if this object has all the given labels.\n\n    Parameters:\n        labels: A set of labels.\n\n    Returns:\n        True or False.\n    \"\"\"\n    return all(label in self.labels for label in labels)\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_exported","title":"is_exported","text":"<pre><code>is_exported(*, explicitely: bool = True) -&gt; bool\n</code></pre> <p>Tell if this object/alias is implicitely exported by its parent.</p> <p>Parameters:</p> <ul> <li> explicitely             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to only return True when <code>__all__</code> is defined.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>def is_exported(self, *, explicitely: bool = True) -&gt; bool:\n\"\"\"Tell if this object/alias is implicitely exported by its parent.\n\n    Parameters:\n        explicitely: Whether to only return True when `__all__` is defined.\n\n    Returns:\n        True or False.\n    \"\"\"\n    return self.parent.member_is_exported(self, explicitely=explicitely)  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_kind","title":"is_kind","text":"<pre><code>is_kind(kind: str | Kind | set[str | Kind]) -&gt; bool\n</code></pre> <p>Tell if this object is of the given kind.</p> <p>Parameters:</p> <ul> <li> kind             (<code>str | Kind | set[str | Kind]</code>)         \u2013          <p>An instance or set of kinds (strings or enumerations).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When an empty set is given as argument.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def is_kind(self, kind: str | Kind | set[str | Kind]) -&gt; bool:\n\"\"\"Tell if this object is of the given kind.\n\n    Parameters:\n        kind: An instance or set of kinds (strings or enumerations).\n\n    Raises:\n        ValueError: When an empty set is given as argument.\n\n    Returns:\n        True or False.\n    \"\"\"\n    if isinstance(kind, set):\n        if not kind:\n            raise ValueError(\"kind must not be an empty set\")\n        return self.kind in (knd if isinstance(knd, Kind) else Kind(knd) for knd in kind)\n    if isinstance(kind, str):\n        kind = Kind(kind)\n    return self.kind is kind\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_public","title":"is_public","text":"<pre><code>is_public(\n    *, strict: bool = False, check_name: bool = True\n) -&gt; bool\n</code></pre> <p>Whether this object is considered public.</p> <p>In modules, developers can mark objects as public thanks to the <code>__all__</code> variable. In classes however, there is no convention or standard to do so.</p> <p>Therefore, to decide whether an object is public, we follow this algorithm:</p> <ul> <li>If the object's <code>public</code> attribute is set (boolean), return its value.</li> <li>In strict mode, the object is public only if it is explicitely exported (listed in <code>__all__</code>).     Strict mode should only be used for module members.</li> <li>Otherwise, if name checks are enabled, the object is private if its name starts with an underscore.</li> <li>Otherwise, if the object is an alias, and is neither inherited from a base class,     nor a member of a parent alias, it is not public.</li> <li>Otherwise, the object is public.</li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>def is_public(\n    self,\n    *,\n    strict: bool = False,\n    check_name: bool = True,\n) -&gt; bool:\n\"\"\"Whether this object is considered public.\n\n    In modules, developers can mark objects as public thanks to the `__all__` variable.\n    In classes however, there is no convention or standard to do so.\n\n    Therefore, to decide whether an object is public, we follow this algorithm:\n\n    - If the object's `public` attribute is set (boolean), return its value.\n    - In strict mode, the object is public only if it is explicitely exported (listed in `__all__`).\n        Strict mode should only be used for module members.\n    - Otherwise, if name checks are enabled, the object is private if its name starts with an underscore.\n    - Otherwise, if the object is an alias, and is neither inherited from a base class,\n        nor a member of a parent alias, it is not public.\n    - Otherwise, the object is public.\n    \"\"\"\n    if self.public is not None:  # type: ignore[attr-defined]\n        return self.public  # type: ignore[attr-defined]\n    if self.is_explicitely_exported:\n        return True\n    if strict:\n        return False\n    if check_name and self.name.startswith(\"_\"):  # type: ignore[attr-defined]\n        return False\n    if self.is_alias and not (self.inherited or self.parent.is_alias):  # type: ignore[attr-defined]\n        return False\n    return True\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.member_is_exported","title":"member_is_exported","text":"<pre><code>member_is_exported(\n    member: Object | Alias, *, explicitely: bool = True\n) -&gt; bool\n</code></pre> <p>Tell if a member of this object is \"exported\".</p> <p>By exported, we mean that the object is included in the <code>__all__</code> attribute of its parent module or class. When <code>__all__</code> is not defined, we consider the member to be implicitely exported, unless it's a module and it was not imported, and unless it's not defined at runtime.</p> <p>Parameters:</p> <ul> <li> member             (<code>Object | Alias</code>)         \u2013          <p>The member to verify.</p> </li> <li> explicitely             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to only return True when <code>__all__</code> is defined.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def member_is_exported(self, member: Object | Alias, *, explicitely: bool = True) -&gt; bool:\n\"\"\"Tell if a member of this object is \"exported\".\n\n    By exported, we mean that the object is included in the `__all__` attribute\n    of its parent module or class. When `__all__` is not defined,\n    we consider the member to be *implicitely* exported,\n    unless it's a module and it was not imported,\n    and unless it's not defined at runtime.\n\n    Parameters:\n        member: The member to verify.\n        explicitely: Whether to only return True when `__all__` is defined.\n\n    Returns:\n        True or False.\n    \"\"\"\n    if not member.runtime:\n        return False\n    if self.exports is None:\n        return not explicitely and (member.is_alias or not member.is_module or member.name in self.imports)\n    return member.name in self.exports\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.resolve","title":"resolve","text":"<pre><code>resolve(name: str) -&gt; str\n</code></pre> <p>Resolve a name within this object's and parents' scope.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013          <p>The name to resolve.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NameResolutionError</code>           \u2013          <p>When the name could not be resolved.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The resolved name.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def resolve(self, name: str) -&gt; str:\n\"\"\"Resolve a name within this object's and parents' scope.\n\n    Parameters:\n        name: The name to resolve.\n\n    Raises:\n        NameResolutionError: When the name could not be resolved.\n\n    Returns:\n        The resolved name.\n    \"\"\"\n    if name in self.members:\n        if self.members[name].is_alias:\n            return self.members[name].target_path  # type: ignore[union-attr]\n        return self.members[name].path\n    if name in self.imports:\n        return self.imports[name]\n    if self.parent is None:\n        # could be a built-in\n        raise NameResolutionError(f\"{name} could not be resolved in the scope of {self.path}\")\n    if name == self.parent.name and not self.parent.is_module:\n        return self.parent.path\n    return self.parent.resolve(name)\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.set_member","title":"set_member","text":"<pre><code>set_member(\n    key: str | Sequence[str], value: Object | Alias\n) -&gt; None\n</code></pre> <p>Set a member with its name or path.</p> <p>This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> <li> value             (<code>Object | Alias</code>)         \u2013          <p>The member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; griffe_object.set_member(\"foo\", foo)\n&gt;&gt;&gt; griffe_object.set_member(\"path.to.bar\", bar)\n&gt;&gt;&gt; griffe_object.set_member((\"path\", \"to\", \"qux\", qux)\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def set_member(self, key: str | Sequence[str], value: Object | Alias) -&gt; None:\n\"\"\"Set a member with its name or path.\n\n    This method is part of the producer API:\n    you can use it safely while building Griffe trees\n    (for example in Griffe extensions).\n\n    Parameters:\n        key: The name or path of the member.\n        value: The member.\n\n    Examples:\n        &gt;&gt;&gt; griffe_object.set_member(\"foo\", foo)\n        &gt;&gt;&gt; griffe_object.set_member(\"path.to.bar\", bar)\n        &gt;&gt;&gt; griffe_object.set_member((\"path\", \"to\", \"qux\", qux)\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        if name in self.members:  # type: ignore[attr-defined]\n            member = self.members[name]  # type: ignore[attr-defined]\n            if not member.is_alias:\n                # when reassigning a module to an existing one,\n                # try to merge them as one regular and one stubs module\n                # (implicit support for .pyi modules)\n                if member.is_module and not (member.is_namespace_package or member.is_namespace_subpackage):\n                    with suppress(AliasResolutionError, CyclicAliasError):\n                        if value.is_module and value.filepath != member.filepath:\n                            with suppress(ValueError):\n                                value = merge_stubs(member, value)  # type: ignore[arg-type]\n                for alias in member.aliases.values():\n                    with suppress(CyclicAliasError):\n                        alias.target = value\n        self.members[name] = value  # type: ignore[attr-defined]\n        if self.is_collection:  # type: ignore[attr-defined]\n            value._modules_collection = self  # type: ignore[union-attr]\n        else:\n            value.parent = self  # type: ignore[assignment]\n    else:\n        self.members[parts[0]].set_member(parts[1:], value)  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object","title":"Object","text":"<pre><code>Object(\n    name: str,\n    *,\n    lineno: int | None = None,\n    endlineno: int | None = None,\n    runtime: bool = True,\n    docstring: Docstring | None = None,\n    parent: Module | Class | None = None,\n    lines_collection: LinesCollection | None = None,\n    modules_collection: ModulesCollection | None = None\n)\n</code></pre> <p>             Bases: <code>GetMembersMixin</code>, <code>SetMembersMixin</code>, <code>ObjectAliasMixin</code>, <code>SerializationMixin</code></p> <p>An abstract class representing a Python object.</p> <p>Attributes:</p> <ul> <li> kind             (<code>Kind</code>)         \u2013          <p>The object kind.</p> </li> <li> name             (<code>str</code>)         \u2013          <p>The object name.</p> </li> <li> lineno             (<code>int | None</code>)         \u2013          <p>The object starting line, or None for modules. Lines start at 1.</p> </li> <li> endlineno             (<code>int | None</code>)         \u2013          <p>The object ending line (inclusive), or None for modules.</p> </li> <li> docstring             (<code>Docstring | None</code>)         \u2013          <p>The object docstring.</p> </li> <li> parent             (<code>Module | Class | None</code>)         \u2013          <p>The object parent, or None if it is the top module.</p> </li> <li> members             (<code>dict[str, Object | Alias]</code>)         \u2013          <p>The object members.</p> </li> <li> labels             (<code>set[str]</code>)         \u2013          <p>The object labels.</p> </li> </ul> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013          <p>The object name, as declared in the code.</p> </li> <li> lineno             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>The object starting line, or None for modules. Lines start at 1.</p> </li> <li> endlineno             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>The object ending line (inclusive), or None for modules.</p> </li> <li> runtime             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether this object is present at runtime or not.</p> </li> <li> docstring             (<code>Docstring | None</code>, default:                 <code>None</code> )         \u2013          <p>The object docstring.</p> </li> <li> parent             (<code>Module | Class | None</code>, default:                 <code>None</code> )         \u2013          <p>The object parent.</p> </li> <li> lines_collection             (<code>LinesCollection | None</code>, default:                 <code>None</code> )         \u2013          <p>A collection of source code lines.</p> </li> <li> modules_collection             (<code>ModulesCollection | None</code>, default:                 <code>None</code> )         \u2013          <p>A collection of modules.</p> </li> </ul> <p>Methods:</p> <ul> <li> __delitem__           \u2013            <p>Delete a member with its name or path.</p> </li> <li> __getitem__           \u2013            <p>Get a member with its name or path.</p> </li> <li> __setitem__           \u2013            <p>Set a member with its name or path.</p> </li> <li> as_dict           \u2013            <p>Return this object's data as a dictionary.</p> </li> <li> as_json           \u2013            <p>Return this object's data as a JSON string.</p> </li> <li> del_member           \u2013            <p>Delete a member with its name or path.</p> </li> <li> filter_members           \u2013            <p>Filter and return members based on predicates.</p> </li> <li> from_json           \u2013            <p>Create an instance of this class from a JSON string.</p> </li> <li> get_member           \u2013            <p>Get a member with its name or path.</p> </li> <li> has_labels           \u2013            <p>Tell if this object has all the given labels.</p> </li> <li> is_exported           \u2013            <p>Tell if this object/alias is implicitely exported by its parent.</p> </li> <li> is_kind           \u2013            <p>Tell if this object is of the given kind.</p> </li> <li> is_public           \u2013            <p>Whether this object is considered public.</p> </li> <li> member_is_exported           \u2013            <p>Tell if a member of this object is \"exported\".</p> </li> <li> resolve           \u2013            <p>Resolve a name within this object's and parents' scope.</p> </li> <li> set_member           \u2013            <p>Set a member with its name or path.</p> </li> </ul> <p>Attributes:</p> <ul> <li> all_members             (<code>dict[str, Object | Alias]</code>)         \u2013          <p>All members (declared and inherited).</p> </li> <li> attributes             (<code>dict[str, Attribute]</code>)         \u2013          <p>Return the attribute members.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Return the full dotted path of this object.</p> </li> <li> classes             (<code>dict[str, Class]</code>)         \u2013          <p>Return the class members.</p> </li> <li> filepath             (<code>Path | list[Path]</code>)         \u2013          <p>Return the file path where this object was defined.</p> </li> <li> functions             (<code>dict[str, Function]</code>)         \u2013          <p>Return the function members.</p> </li> <li> has_docstring             (<code>bool</code>)         \u2013          <p>Tell if this object has a non-empty docstring.</p> </li> <li> has_docstrings             (<code>bool</code>)         \u2013          <p>Tell if this object or any of its members has a non-empty docstring.</p> </li> <li> inherited_members             (<code>dict[str, Alias]</code>)         \u2013          <p>Members that are inherited from base classes.</p> </li> <li> is_attribute             (<code>bool</code>)         \u2013          <p>Tell if this object is an attribute.</p> </li> <li> is_class             (<code>bool</code>)         \u2013          <p>Tell if this object is a class.</p> </li> <li> is_explicitely_exported             (<code>bool</code>)         \u2013          <p>Tell if this object/alias is explicitely exported by its parent.</p> </li> <li> is_function             (<code>bool</code>)         \u2013          <p>Tell if this object is a function.</p> </li> <li> is_implicitely_exported             (<code>bool</code>)         \u2013          <p>Tell if this object/alias is implicitely exported by its parent.</p> </li> <li> is_module             (<code>bool</code>)         \u2013          <p>Tell if this object is a module.</p> </li> <li> lines             (<code>list[str]</code>)         \u2013          <p>Return the lines containing the source of this object.</p> </li> <li> lines_collection             (<code>LinesCollection</code>)         \u2013          <p>Return the lines collection attached to this object or its parents.</p> </li> <li> module             (<code>Module</code>)         \u2013          <p>Return the parent module of this object.</p> </li> <li> modules             (<code>dict[str, Module]</code>)         \u2013          <p>Return the module members.</p> </li> <li> modules_collection             (<code>ModulesCollection</code>)         \u2013          <p>Return the modules collection attached to this object or its parents.</p> </li> <li> package             (<code>Module</code>)         \u2013          <p>Return the absolute top module (the package) of this object.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Return the dotted path of this object.</p> </li> <li> relative_filepath             (<code>Path</code>)         \u2013          <p>Return the file path where this object was defined, relative to the current working directory.</p> </li> <li> relative_package_filepath             (<code>Path</code>)         \u2013          <p>Return the file path where this object was defined, relative to the top module path.</p> </li> <li> source             (<code>str</code>)         \u2013          <p>Return the source code of this object.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    *,\n    lineno: int | None = None,\n    endlineno: int | None = None,\n    runtime: bool = True,\n    docstring: Docstring | None = None,\n    parent: Module | Class | None = None,\n    lines_collection: LinesCollection | None = None,\n    modules_collection: ModulesCollection | None = None,\n) -&gt; None:\n\"\"\"Initialize the object.\n\n    Parameters:\n        name: The object name, as declared in the code.\n        lineno: The object starting line, or None for modules. Lines start at 1.\n        endlineno: The object ending line (inclusive), or None for modules.\n        runtime: Whether this object is present at runtime or not.\n        docstring: The object docstring.\n        parent: The object parent.\n        lines_collection: A collection of source code lines.\n        modules_collection: A collection of modules.\n    \"\"\"\n    self.name: str = name\n    self.lineno: int | None = lineno\n    self.endlineno: int | None = endlineno\n    self.docstring: Docstring | None = docstring\n    self.parent: Module | Class | None = parent\n    self.members: dict[str, Object | Alias] = {}\n    self.labels: set[str] = set()\n    self.imports: dict[str, str] = {}\n    self.exports: set[str] | list[str | ExprName] | None = None\n    self.aliases: dict[str, Alias] = {}\n    self.runtime: bool = runtime\n    self.extra: dict[str, dict[str, Any]] = defaultdict(dict)\n    self.public: bool | None = None\n    self._lines_collection: LinesCollection | None = lines_collection\n    self._modules_collection: ModulesCollection | None = modules_collection\n\n    # attach the docstring to this object\n    if docstring:\n        docstring.parent = self\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.all_members","title":"all_members  <code>property</code>","text":"<pre><code>all_members: dict[str, Object | Alias]\n</code></pre> <p>All members (declared and inherited).</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.attributes","title":"attributes  <code>property</code>","text":"<pre><code>attributes: dict[str, Attribute]\n</code></pre> <p>Return the attribute members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Attribute]</code>         \u2013          <p>A dictionary of attributes.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Return the full dotted path of this object.</p> <p>The canonical path is the path where the object was defined (not imported).</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>A dotted path.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.classes","title":"classes  <code>property</code>","text":"<pre><code>classes: dict[str, Class]\n</code></pre> <p>Return the class members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Class]</code>         \u2013          <p>A dictionary of classes.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.filepath","title":"filepath  <code>property</code>","text":"<pre><code>filepath: Path | list[Path]\n</code></pre> <p>Return the file path where this object was defined.</p> <p>Returns:</p> <ul> <li> <code>Path | list[Path]</code>         \u2013          <p>A file path or a list of directories.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.functions","title":"functions  <code>property</code>","text":"<pre><code>functions: dict[str, Function]\n</code></pre> <p>Return the function members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Function]</code>         \u2013          <p>A dictionary of functions.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.has_docstring","title":"has_docstring  <code>property</code>","text":"<pre><code>has_docstring: bool\n</code></pre> <p>Tell if this object has a non-empty docstring.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.has_docstrings","title":"has_docstrings  <code>property</code>","text":"<pre><code>has_docstrings: bool\n</code></pre> <p>Tell if this object or any of its members has a non-empty docstring.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.inherited_members","title":"inherited_members  <code>cached</code> <code>property</code>","text":"<pre><code>inherited_members: dict[str, Alias]\n</code></pre> <p>Members that are inherited from base classes.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.is_attribute","title":"is_attribute  <code>property</code>","text":"<pre><code>is_attribute: bool\n</code></pre> <p>Tell if this object is an attribute.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.is_class","title":"is_class  <code>property</code>","text":"<pre><code>is_class: bool\n</code></pre> <p>Tell if this object is a class.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.is_explicitely_exported","title":"is_explicitely_exported  <code>property</code>","text":"<pre><code>is_explicitely_exported: bool\n</code></pre> <p>Tell if this object/alias is explicitely exported by its parent.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.is_function","title":"is_function  <code>property</code>","text":"<pre><code>is_function: bool\n</code></pre> <p>Tell if this object is a function.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.is_implicitely_exported","title":"is_implicitely_exported  <code>property</code>","text":"<pre><code>is_implicitely_exported: bool\n</code></pre> <p>Tell if this object/alias is implicitely exported by its parent.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.is_module","title":"is_module  <code>property</code>","text":"<pre><code>is_module: bool\n</code></pre> <p>Tell if this object is a module.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.lines","title":"lines  <code>property</code>","text":"<pre><code>lines: list[str]\n</code></pre> <p>Return the lines containing the source of this object.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>         \u2013          <p>A list of lines.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.lines_collection","title":"lines_collection  <code>property</code>","text":"<pre><code>lines_collection: LinesCollection\n</code></pre> <p>Return the lines collection attached to this object or its parents.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When no modules collection can be found in the object or its parents.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>LinesCollection</code>         \u2013          <p>A lines collection.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.module","title":"module  <code>property</code>","text":"<pre><code>module: Module\n</code></pre> <p>Return the parent module of this object.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When the object is not a module and does not have a parent.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013          <p>The parent module.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.modules","title":"modules  <code>property</code>","text":"<pre><code>modules: dict[str, Module]\n</code></pre> <p>Return the module members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Module]</code>         \u2013          <p>A dictionary of modules.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.modules_collection","title":"modules_collection  <code>property</code>","text":"<pre><code>modules_collection: ModulesCollection\n</code></pre> <p>Return the modules collection attached to this object or its parents.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When no modules collection can be found in the object or its parents.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ModulesCollection</code>         \u2013          <p>A modules collection.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.package","title":"package  <code>property</code>","text":"<pre><code>package: Module\n</code></pre> <p>Return the absolute top module (the package) of this object.</p> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013          <p>The parent module.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Return the dotted path of this object.</p> <p>On regular objects (not aliases), the path is the canonical path.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>A dotted path.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.relative_filepath","title":"relative_filepath  <code>property</code>","text":"<pre><code>relative_filepath: Path\n</code></pre> <p>Return the file path where this object was defined, relative to the current working directory.</p> <p>If this object's file path is not relative to the current working directory, return its absolute path.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When the relative path could not be computed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code>         \u2013          <p>A file path.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.relative_package_filepath","title":"relative_package_filepath  <code>property</code>","text":"<pre><code>relative_package_filepath: Path\n</code></pre> <p>Return the file path where this object was defined, relative to the top module path.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When the relative path could not be computed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code>         \u2013          <p>A file path.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.source","title":"source  <code>property</code>","text":"<pre><code>source: str\n</code></pre> <p>Return the source code of this object.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The source code.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.__delitem__","title":"__delitem__","text":"<pre><code>__delitem__(key: str | Sequence[str]) -&gt; None\n</code></pre> <p>Delete a member with its name or path.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Members will be looked up in both declared members and inherited ones, triggering computation of the latter.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; del griffe_object[\"foo\"]\n&gt;&gt;&gt; del griffe_object[\"path.to.bar\"]\n&gt;&gt;&gt; del griffe_object[(\"path\", \"to\", \"qux\")]\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def __delitem__(self, key: str | Sequence[str]) -&gt; None:\n\"\"\"Delete a member with its name or path.\n\n    This method is part of the consumer API:\n    do not use when producing Griffe trees!\n\n    Members will be looked up in both declared members and inherited ones,\n    triggering computation of the latter.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; del griffe_object[\"foo\"]\n        &gt;&gt;&gt; del griffe_object[\"path.to.bar\"]\n        &gt;&gt;&gt; del griffe_object[(\"path\", \"to\", \"qux\")]\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        try:\n            del self.members[name]  # type: ignore[attr-defined]\n        except KeyError:\n            del self.inherited_members[name]  # type: ignore[attr-defined]\n    else:\n        del self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key: str | Sequence[str]) -&gt; Any\n</code></pre> <p>Get a member with its name or path.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Members will be looked up in both declared members and inherited ones, triggering computation of the latter.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; foo = griffe_object[\"foo\"]\n&gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n&gt;&gt;&gt; qux = griffe_object[(\"path\", \"to\", \"qux\")]\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def __getitem__(self, key: str | Sequence[str]) -&gt; Any:\n\"\"\"Get a member with its name or path.\n\n    This method is part of the consumer API:\n    do not use when producing Griffe trees!\n\n    Members will be looked up in both declared members and inherited ones,\n    triggering computation of the latter.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; foo = griffe_object[\"foo\"]\n        &gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n        &gt;&gt;&gt; qux = griffe_object[(\"path\", \"to\", \"qux\")]\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        return self.all_members[parts[0]]  # type: ignore[attr-defined]\n    return self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(\n    key: str | Sequence[str], value: Object | Alias\n) -&gt; None\n</code></pre> <p>Set a member with its name or path.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> <li> value             (<code>Object | Alias</code>)         \u2013          <p>The member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; griffe_object[\"foo\"] = foo\n&gt;&gt;&gt; griffe_object[\"path.to.bar\"] = bar\n&gt;&gt;&gt; griffe_object[(\"path\", \"to\", \"qux\")] = qux\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def __setitem__(self, key: str | Sequence[str], value: Object | Alias) -&gt; None:\n\"\"\"Set a member with its name or path.\n\n    This method is part of the consumer API:\n    do not use when producing Griffe trees!\n\n    Parameters:\n        key: The name or path of the member.\n        value: The member.\n\n    Examples:\n        &gt;&gt;&gt; griffe_object[\"foo\"] = foo\n        &gt;&gt;&gt; griffe_object[\"path.to.bar\"] = bar\n        &gt;&gt;&gt; griffe_object[(\"path\", \"to\", \"qux\")] = qux\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        self.members[name] = value  # type: ignore[attr-defined]\n        if self.is_collection:  # type: ignore[attr-defined]\n            value._modules_collection = self  # type: ignore[union-attr]\n        else:\n            value.parent = self  # type: ignore[assignment]\n    else:\n        self.members[parts[0]][parts[1:]] = value  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.as_dict","title":"as_dict","text":"<pre><code>as_dict(\n    *, full: bool = False, **kwargs: Any\n) -&gt; dict[str, Any]\n</code></pre> <p>Return this object's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> full             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to return full info, or just base info.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def as_dict(self, *, full: bool = False, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return this object's data as a dictionary.\n\n    Parameters:\n        full: Whether to return full info, or just base info.\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    base = {\n        \"kind\": self.kind,\n        \"name\": self.name,\n    }\n\n    if full:\n        base.update(\n            {\n                \"path\": self.path,\n                \"filepath\": self.filepath,\n                \"relative_filepath\": self.relative_filepath,\n                \"relative_package_filepath\": self.relative_package_filepath,\n            },\n        )\n\n    if self.lineno:\n        base[\"lineno\"] = self.lineno\n    if self.endlineno:\n        base[\"endlineno\"] = self.endlineno\n    if self.docstring:\n        base[\"docstring\"] = self.docstring\n\n    # doing this last for a prettier JSON dump\n    base[\"labels\"] = self.labels\n    base[\"members\"] = [member.as_dict(full=full, **kwargs) for member in self.members.values()]\n\n    return base\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.as_json","title":"as_json","text":"<pre><code>as_json(*, full: bool = False, **kwargs: Any) -&gt; str\n</code></pre> <p>Return this object's data as a JSON string.</p> <p>Parameters:</p> <ul> <li> full             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to return full info, or just base info.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options passed to encoder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>A JSON string.</p> </li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>def as_json(self, *, full: bool = False, **kwargs: Any) -&gt; str:\n\"\"\"Return this object's data as a JSON string.\n\n    Parameters:\n        full: Whether to return full info, or just base info.\n        **kwargs: Additional serialization options passed to encoder.\n\n    Returns:\n        A JSON string.\n    \"\"\"\n    from griffe.encoders import JSONEncoder  # avoid circular import\n\n    return json.dumps(self, cls=JSONEncoder, full=full, **kwargs)\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.del_member","title":"del_member","text":"<pre><code>del_member(key: str | Sequence[str]) -&gt; None\n</code></pre> <p>Delete a member with its name or path.</p> <p>This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).</p> <p>Members will be looked up in declared members only, not inherited ones.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; griffe_object.del_member(\"foo\")\n&gt;&gt;&gt; griffe_object.del_member(\"path.to.bar\")\n&gt;&gt;&gt; griffe_object.del_member((\"path\", \"to\", \"qux\"))\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def del_member(self, key: str | Sequence[str]) -&gt; None:\n\"\"\"Delete a member with its name or path.\n\n    This method is part of the producer API:\n    you can use it safely while building Griffe trees\n    (for example in Griffe extensions).\n\n    Members will be looked up in declared members only, not inherited ones.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; griffe_object.del_member(\"foo\")\n        &gt;&gt;&gt; griffe_object.del_member(\"path.to.bar\")\n        &gt;&gt;&gt; griffe_object.del_member((\"path\", \"to\", \"qux\"))\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        del self.members[name]  # type: ignore[attr-defined]\n    else:\n        self.members[parts[0]].del_member(parts[1:])  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.filter_members","title":"filter_members","text":"<pre><code>filter_members(\n    *predicates: Callable[[Object | Alias], bool]\n) -&gt; dict[str, Object | Alias]\n</code></pre> <p>Filter and return members based on predicates.</p> <p>Parameters:</p> <ul> <li> *predicates             (<code>Callable[[Object | Alias], bool]</code>, default:                 <code>()</code> )         \u2013          <p>A list of predicates, i.e. callables accepting a member as argument and returning a boolean.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Object | Alias]</code>         \u2013          <p>A dictionary of members.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def filter_members(self, *predicates: Callable[[Object | Alias], bool]) -&gt; dict[str, Object | Alias]:\n\"\"\"Filter and return members based on predicates.\n\n    Parameters:\n        *predicates: A list of predicates, i.e. callables accepting a member as argument and returning a boolean.\n\n    Returns:\n        A dictionary of members.\n    \"\"\"\n    if not predicates:\n        return self.members\n    members: dict[str, Object | Alias] = {}\n    for name, member in self.members.items():\n        if all(predicate(member) for predicate in predicates):\n            members[name] = member\n    return members\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_string: str, **kwargs: Any) -&gt; _ObjType\n</code></pre> <p>Create an instance of this class from a JSON string.</p> <p>Parameters:</p> <ul> <li> json_string             (<code>str</code>)         \u2013          <p>JSON to decode into Object.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional options passed to decoder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_ObjType</code>         \u2013          <p>An Object instance.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>           \u2013          <p>When the json_string does not represent and object of the class from which this classmethod has been called.</p> </li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>@classmethod\ndef from_json(cls: type[_ObjType], json_string: str, **kwargs: Any) -&gt; _ObjType:  # noqa: PYI019\n\"\"\"Create an instance of this class from a JSON string.\n\n    Parameters:\n        json_string: JSON to decode into Object.\n        **kwargs: Additional options passed to decoder.\n\n    Returns:\n        An Object instance.\n\n    Raises:\n        TypeError: When the json_string does not represent and object\n            of the class from which this classmethod has been called.\n    \"\"\"\n    from griffe.encoders import json_decoder  # avoid circular import\n\n    kwargs.setdefault(\"object_hook\", json_decoder)\n    obj = json.loads(json_string, **kwargs)\n    if not isinstance(obj, cls):\n        raise TypeError(f\"provided JSON object is not of type {cls}\")\n    return obj\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.get_member","title":"get_member","text":"<pre><code>get_member(key: str | Sequence[str]) -&gt; Any\n</code></pre> <p>Get a member with its name or path.</p> <p>This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).</p> <p>Members will be looked up in declared members only, not inherited ones.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; foo = griffe_object[\"foo\"]\n&gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n&gt;&gt;&gt; bar = griffe_object[(\"path\", \"to\", \"bar\")]\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def get_member(self, key: str | Sequence[str]) -&gt; Any:\n\"\"\"Get a member with its name or path.\n\n    This method is part of the producer API:\n    you can use it safely while building Griffe trees\n    (for example in Griffe extensions).\n\n    Members will be looked up in declared members only, not inherited ones.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; foo = griffe_object[\"foo\"]\n        &gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n        &gt;&gt;&gt; bar = griffe_object[(\"path\", \"to\", \"bar\")]\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        return self.members[parts[0]]  # type: ignore[attr-defined]\n    return self.members[parts[0]].get_member(parts[1:])  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.has_labels","title":"has_labels","text":"<pre><code>has_labels(labels: set[str]) -&gt; bool\n</code></pre> <p>Tell if this object has all the given labels.</p> <p>Parameters:</p> <ul> <li> labels             (<code>set[str]</code>)         \u2013          <p>A set of labels.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def has_labels(self, labels: set[str]) -&gt; bool:\n\"\"\"Tell if this object has all the given labels.\n\n    Parameters:\n        labels: A set of labels.\n\n    Returns:\n        True or False.\n    \"\"\"\n    return all(label in self.labels for label in labels)\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.is_exported","title":"is_exported","text":"<pre><code>is_exported(*, explicitely: bool = True) -&gt; bool\n</code></pre> <p>Tell if this object/alias is implicitely exported by its parent.</p> <p>Parameters:</p> <ul> <li> explicitely             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to only return True when <code>__all__</code> is defined.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>def is_exported(self, *, explicitely: bool = True) -&gt; bool:\n\"\"\"Tell if this object/alias is implicitely exported by its parent.\n\n    Parameters:\n        explicitely: Whether to only return True when `__all__` is defined.\n\n    Returns:\n        True or False.\n    \"\"\"\n    return self.parent.member_is_exported(self, explicitely=explicitely)  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.is_kind","title":"is_kind","text":"<pre><code>is_kind(kind: str | Kind | set[str | Kind]) -&gt; bool\n</code></pre> <p>Tell if this object is of the given kind.</p> <p>Parameters:</p> <ul> <li> kind             (<code>str | Kind | set[str | Kind]</code>)         \u2013          <p>An instance or set of kinds (strings or enumerations).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When an empty set is given as argument.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def is_kind(self, kind: str | Kind | set[str | Kind]) -&gt; bool:\n\"\"\"Tell if this object is of the given kind.\n\n    Parameters:\n        kind: An instance or set of kinds (strings or enumerations).\n\n    Raises:\n        ValueError: When an empty set is given as argument.\n\n    Returns:\n        True or False.\n    \"\"\"\n    if isinstance(kind, set):\n        if not kind:\n            raise ValueError(\"kind must not be an empty set\")\n        return self.kind in (knd if isinstance(knd, Kind) else Kind(knd) for knd in kind)\n    if isinstance(kind, str):\n        kind = Kind(kind)\n    return self.kind is kind\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.is_public","title":"is_public","text":"<pre><code>is_public(\n    *, strict: bool = False, check_name: bool = True\n) -&gt; bool\n</code></pre> <p>Whether this object is considered public.</p> <p>In modules, developers can mark objects as public thanks to the <code>__all__</code> variable. In classes however, there is no convention or standard to do so.</p> <p>Therefore, to decide whether an object is public, we follow this algorithm:</p> <ul> <li>If the object's <code>public</code> attribute is set (boolean), return its value.</li> <li>In strict mode, the object is public only if it is explicitely exported (listed in <code>__all__</code>).     Strict mode should only be used for module members.</li> <li>Otherwise, if name checks are enabled, the object is private if its name starts with an underscore.</li> <li>Otherwise, if the object is an alias, and is neither inherited from a base class,     nor a member of a parent alias, it is not public.</li> <li>Otherwise, the object is public.</li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>def is_public(\n    self,\n    *,\n    strict: bool = False,\n    check_name: bool = True,\n) -&gt; bool:\n\"\"\"Whether this object is considered public.\n\n    In modules, developers can mark objects as public thanks to the `__all__` variable.\n    In classes however, there is no convention or standard to do so.\n\n    Therefore, to decide whether an object is public, we follow this algorithm:\n\n    - If the object's `public` attribute is set (boolean), return its value.\n    - In strict mode, the object is public only if it is explicitely exported (listed in `__all__`).\n        Strict mode should only be used for module members.\n    - Otherwise, if name checks are enabled, the object is private if its name starts with an underscore.\n    - Otherwise, if the object is an alias, and is neither inherited from a base class,\n        nor a member of a parent alias, it is not public.\n    - Otherwise, the object is public.\n    \"\"\"\n    if self.public is not None:  # type: ignore[attr-defined]\n        return self.public  # type: ignore[attr-defined]\n    if self.is_explicitely_exported:\n        return True\n    if strict:\n        return False\n    if check_name and self.name.startswith(\"_\"):  # type: ignore[attr-defined]\n        return False\n    if self.is_alias and not (self.inherited or self.parent.is_alias):  # type: ignore[attr-defined]\n        return False\n    return True\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.member_is_exported","title":"member_is_exported","text":"<pre><code>member_is_exported(\n    member: Object | Alias, *, explicitely: bool = True\n) -&gt; bool\n</code></pre> <p>Tell if a member of this object is \"exported\".</p> <p>By exported, we mean that the object is included in the <code>__all__</code> attribute of its parent module or class. When <code>__all__</code> is not defined, we consider the member to be implicitely exported, unless it's a module and it was not imported, and unless it's not defined at runtime.</p> <p>Parameters:</p> <ul> <li> member             (<code>Object | Alias</code>)         \u2013          <p>The member to verify.</p> </li> <li> explicitely             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to only return True when <code>__all__</code> is defined.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def member_is_exported(self, member: Object | Alias, *, explicitely: bool = True) -&gt; bool:\n\"\"\"Tell if a member of this object is \"exported\".\n\n    By exported, we mean that the object is included in the `__all__` attribute\n    of its parent module or class. When `__all__` is not defined,\n    we consider the member to be *implicitely* exported,\n    unless it's a module and it was not imported,\n    and unless it's not defined at runtime.\n\n    Parameters:\n        member: The member to verify.\n        explicitely: Whether to only return True when `__all__` is defined.\n\n    Returns:\n        True or False.\n    \"\"\"\n    if not member.runtime:\n        return False\n    if self.exports is None:\n        return not explicitely and (member.is_alias or not member.is_module or member.name in self.imports)\n    return member.name in self.exports\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.resolve","title":"resolve","text":"<pre><code>resolve(name: str) -&gt; str\n</code></pre> <p>Resolve a name within this object's and parents' scope.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013          <p>The name to resolve.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NameResolutionError</code>           \u2013          <p>When the name could not be resolved.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The resolved name.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def resolve(self, name: str) -&gt; str:\n\"\"\"Resolve a name within this object's and parents' scope.\n\n    Parameters:\n        name: The name to resolve.\n\n    Raises:\n        NameResolutionError: When the name could not be resolved.\n\n    Returns:\n        The resolved name.\n    \"\"\"\n    if name in self.members:\n        if self.members[name].is_alias:\n            return self.members[name].target_path  # type: ignore[union-attr]\n        return self.members[name].path\n    if name in self.imports:\n        return self.imports[name]\n    if self.parent is None:\n        # could be a built-in\n        raise NameResolutionError(f\"{name} could not be resolved in the scope of {self.path}\")\n    if name == self.parent.name and not self.parent.is_module:\n        return self.parent.path\n    return self.parent.resolve(name)\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.set_member","title":"set_member","text":"<pre><code>set_member(\n    key: str | Sequence[str], value: Object | Alias\n) -&gt; None\n</code></pre> <p>Set a member with its name or path.</p> <p>This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> <li> value             (<code>Object | Alias</code>)         \u2013          <p>The member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; griffe_object.set_member(\"foo\", foo)\n&gt;&gt;&gt; griffe_object.set_member(\"path.to.bar\", bar)\n&gt;&gt;&gt; griffe_object.set_member((\"path\", \"to\", \"qux\", qux)\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def set_member(self, key: str | Sequence[str], value: Object | Alias) -&gt; None:\n\"\"\"Set a member with its name or path.\n\n    This method is part of the producer API:\n    you can use it safely while building Griffe trees\n    (for example in Griffe extensions).\n\n    Parameters:\n        key: The name or path of the member.\n        value: The member.\n\n    Examples:\n        &gt;&gt;&gt; griffe_object.set_member(\"foo\", foo)\n        &gt;&gt;&gt; griffe_object.set_member(\"path.to.bar\", bar)\n        &gt;&gt;&gt; griffe_object.set_member((\"path\", \"to\", \"qux\", qux)\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        if name in self.members:  # type: ignore[attr-defined]\n            member = self.members[name]  # type: ignore[attr-defined]\n            if not member.is_alias:\n                # when reassigning a module to an existing one,\n                # try to merge them as one regular and one stubs module\n                # (implicit support for .pyi modules)\n                if member.is_module and not (member.is_namespace_package or member.is_namespace_subpackage):\n                    with suppress(AliasResolutionError, CyclicAliasError):\n                        if value.is_module and value.filepath != member.filepath:\n                            with suppress(ValueError):\n                                value = merge_stubs(member, value)  # type: ignore[arg-type]\n                for alias in member.aliases.values():\n                    with suppress(CyclicAliasError):\n                        alias.target = value\n        self.members[name] = value  # type: ignore[attr-defined]\n        if self.is_collection:  # type: ignore[attr-defined]\n            value._modules_collection = self  # type: ignore[union-attr]\n        else:\n            value.parent = self  # type: ignore[assignment]\n    else:\n        self.members[parts[0]].set_member(parts[1:], value)  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameter","title":"Parameter","text":"<pre><code>Parameter(\n    name: str,\n    *,\n    annotation: str | Expr | None = None,\n    kind: ParameterKind | None = None,\n    default: str | Expr | None = None\n)\n</code></pre> <p>This class represent a function parameter.</p> <p>Attributes:</p> <ul> <li> name             (<code>str</code>)         \u2013          <p>The parameter name.</p> </li> <li> annotation             (<code>str | Expr | None</code>)         \u2013          <p>The parameter annotation, if any.</p> </li> <li> kind             (<code>ParameterKind | None</code>)         \u2013          <p>The parameter kind.</p> </li> <li> default             (<code>str | Expr | None</code>)         \u2013          <p>The parameter default, if any.</p> </li> </ul> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013          <p>The parameter name.</p> </li> <li> annotation             (<code>str | Expr | None</code>, default:                 <code>None</code> )         \u2013          <p>The parameter annotation, if any.</p> </li> <li> kind             (<code>ParameterKind | None</code>, default:                 <code>None</code> )         \u2013          <p>The parameter kind.</p> </li> <li> default             (<code>str | Expr | None</code>, default:                 <code>None</code> )         \u2013          <p>The parameter default, if any.</p> </li> </ul> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this parameter's data as a dictionary.</p> </li> </ul> <p>Attributes:</p> <ul> <li> required             (<code>bool</code>)         \u2013          <p>Tell if this parameter is required.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    *,\n    annotation: str | Expr | None = None,\n    kind: ParameterKind | None = None,\n    default: str | Expr | None = None,\n) -&gt; None:\n\"\"\"Initialize the parameter.\n\n    Parameters:\n        name: The parameter name.\n        annotation: The parameter annotation, if any.\n        kind: The parameter kind.\n        default: The parameter default, if any.\n    \"\"\"\n    self.name: str = name\n    self.annotation: str | Expr | None = annotation\n    self.kind: ParameterKind | None = kind\n    self.default: str | Expr | None = default\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameter.required","title":"required  <code>property</code>","text":"<pre><code>required: bool\n</code></pre> <p>Tell if this parameter is required.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameter.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return this parameter's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:  # noqa: ARG002\n\"\"\"Return this parameter's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return {\n        \"name\": self.name,\n        \"annotation\": self.annotation,\n        \"kind\": self.kind,\n        \"default\": self.default,\n    }\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.ParameterKind","title":"ParameterKind","text":"<p>             Bases: <code>Enum</code></p> <p>Enumeration of the different parameter kinds.</p> <p>Attributes:</p> <ul> <li> positional_only             (<code>str</code>)         \u2013          <p>Positional-only parameter.</p> </li> <li> positional_or_keyword             (<code>str</code>)         \u2013          <p>Positional or keyword parameter.</p> </li> <li> var_positional             (<code>str</code>)         \u2013          <p>Variadic positional parameter.</p> </li> <li> keyword_only             (<code>str</code>)         \u2013          <p>Keyword-only parameter.</p> </li> <li> var_keyword             (<code>str</code>)         \u2013          <p>Variadic keyword parameter.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameters","title":"Parameters","text":"<pre><code>Parameters(*parameters: Parameter)\n</code></pre> <p>This class is a container for parameters.</p> <p>It allows to get parameters using their position (index) or their name.</p> <p>Parameters:</p> <ul> <li> *parameters             (<code>Parameter</code>, default:                 <code>()</code> )         \u2013          <p>The initial parameters to add to the container.</p> </li> </ul> <p>Methods:</p> <ul> <li> add           \u2013            <p>Add a parameter to the container.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def __init__(self, *parameters: Parameter) -&gt; None:\n\"\"\"Initialize the parameters container.\n\n    Parameters:\n        *parameters: The initial parameters to add to the container.\n    \"\"\"\n    self._parameters_list: list[Parameter] = []\n    self._parameters_dict: dict[str, Parameter] = {}\n    for parameter in parameters:\n        self.add(parameter)\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameters.add","title":"add","text":"<pre><code>add(parameter: Parameter) -&gt; None\n</code></pre> <p>Add a parameter to the container.</p> <p>Parameters:</p> <ul> <li> parameter             (<code>Parameter</code>)         \u2013          <p>The function parameter to add.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When a parameter with the same name is already present.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def add(self, parameter: Parameter) -&gt; None:\n\"\"\"Add a parameter to the container.\n\n    Parameters:\n        parameter: The function parameter to add.\n\n    Raises:\n        ValueError: When a parameter with the same name is already present.\n    \"\"\"\n    if parameter.name not in self._parameters_dict:\n        self._parameters_dict[parameter.name] = parameter\n        self._parameters_list.append(parameter)\n    else:\n        raise ValueError(f\"parameter {parameter.name} already present\")\n</code></pre>"},{"location":"reference/griffe/diff/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> diff","text":""},{"location":"reference/griffe/diff/#griffe.diff","title":"diff","text":"<p>This module exports \"breaking changes\" related utilities.</p> <p>Classes:</p> <ul> <li> AttributeChangedTypeBreakage         \u2013          <p>Specific breakage class for attributes whose type changed.</p> </li> <li> AttributeChangedValueBreakage         \u2013          <p>Specific breakage class for attributes whose value changed.</p> </li> <li> Breakage         \u2013          <p>Breakages can explain what broke from a version to another.</p> </li> <li> BreakageKind         \u2013          <p>An enumeration of the possible breakages.</p> </li> <li> ClassRemovedBaseBreakage         \u2013          <p>Specific breakage class for removed base classes.</p> </li> <li> ExplanationStyle         \u2013          <p>An enumeration of the possible styles for explanations.</p> </li> <li> ObjectChangedKindBreakage         \u2013          <p>Specific breakage class for objects whose kind changed.</p> </li> <li> ObjectRemovedBreakage         \u2013          <p>Specific breakage class for removed objects.</p> </li> <li> ParameterAddedRequiredBreakage         \u2013          <p>Specific breakage class for new parameters added as required.</p> </li> <li> ParameterChangedDefaultBreakage         \u2013          <p>Specific breakage class for parameters whose default value changed.</p> </li> <li> ParameterChangedKindBreakage         \u2013          <p>Specific breakage class for parameters whose kind changed.</p> </li> <li> ParameterChangedRequiredBreakage         \u2013          <p>Specific breakage class for parameters which became required.</p> </li> <li> ParameterMovedBreakage         \u2013          <p>Specific breakage class for moved parameters.</p> </li> <li> ParameterRemovedBreakage         \u2013          <p>Specific breakage class for removed parameters.</p> </li> <li> ReturnChangedTypeBreakage         \u2013          <p>Specific breakage class for return values which changed type.</p> </li> </ul> <p>Functions:</p> <ul> <li> find_breaking_changes           \u2013            <p>Find breaking changes between two versions of the same API.</p> </li> </ul>"},{"location":"reference/griffe/diff/#griffe.diff.AttributeChangedTypeBreakage","title":"AttributeChangedTypeBreakage","text":"<p>             Bases: <code>Breakage</code></p> <p>Specific breakage class for attributes whose type changed.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this object's data as a dictionary.</p> </li> <li> explain           \u2013            <p>Explain the breakage by showing old and new value.</p> </li> </ul>"},{"location":"reference/griffe/diff/#griffe.diff.AttributeChangedTypeBreakage.as_dict","title":"as_dict","text":"<pre><code>as_dict(\n    *, full: bool = False, **kwargs: Any\n) -&gt; dict[str, Any]\n</code></pre> <p>Return this object's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> full             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to return full info, or just base info.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/diff.py</code> <pre><code>def as_dict(self, *, full: bool = False, **kwargs: Any) -&gt; dict[str, Any]:  # noqa: ARG002\n\"\"\"Return this object's data as a dictionary.\n\n    Parameters:\n        full: Whether to return full info, or just base info.\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return {\n        \"kind\": self.kind,\n        \"object_path\": self.obj.path,\n        \"old_value\": self.old_value,\n        \"new_value\": self.new_value,\n    }\n</code></pre>"},{"location":"reference/griffe/diff/#griffe.diff.AttributeChangedTypeBreakage.explain","title":"explain","text":"<pre><code>explain(\n    style: ExplanationStyle = ExplanationStyle.ONE_LINE,\n) -&gt; str\n</code></pre> <p>Explain the breakage by showing old and new value.</p> <p>Parameters:</p> <ul> <li> style             (<code>ExplanationStyle</code>, default:                 <code>ONE_LINE</code> )         \u2013          <p>The explanation style to use.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>An explanation.</p> </li> </ul> Source code in <code>src/griffe/diff.py</code> <pre><code>def explain(self, style: ExplanationStyle = ExplanationStyle.ONE_LINE) -&gt; str:\n\"\"\"Explain the breakage by showing old and new value.\n\n    Parameters:\n        style: The explanation style to use.\n\n    Returns:\n        An explanation.\n    \"\"\"\n    return getattr(self, f\"_explain_{style.value}\")()\n</code></pre>"},{"location":"reference/griffe/diff/#griffe.diff.AttributeChangedValueBreakage","title":"AttributeChangedValueBreakage","text":"<p>             Bases: <code>Breakage</code></p> <p>Specific breakage class for attributes whose value changed.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this object's data as a dictionary.</p> </li> <li> explain           \u2013            <p>Explain the breakage by showing old and new value.</p> </li> </ul>"},{"location":"reference/griffe/diff/#griffe.diff.AttributeChangedValueBreakage.as_dict","title":"as_dict","text":"<pre><code>as_dict(\n    *, full: bool = False, **kwargs: Any\n) -&gt; dict[str, Any]\n</code></pre> <p>Return this object's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> full             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to return full info, or just base info.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/diff.py</code> <pre><code>def as_dict(self, *, full: bool = False, **kwargs: Any) -&gt; dict[str, Any]:  # noqa: ARG002\n\"\"\"Return this object's data as a dictionary.\n\n    Parameters:\n        full: Whether to return full info, or just base info.\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return {\n        \"kind\": self.kind,\n        \"object_path\": self.obj.path,\n        \"old_value\": self.old_value,\n        \"new_value\": self.new_value,\n    }\n</code></pre>"},{"location":"reference/griffe/diff/#griffe.diff.AttributeChangedValueBreakage.explain","title":"explain","text":"<pre><code>explain(\n    style: ExplanationStyle = ExplanationStyle.ONE_LINE,\n) -&gt; str\n</code></pre> <p>Explain the breakage by showing old and new value.</p> <p>Parameters:</p> <ul> <li> style             (<code>ExplanationStyle</code>, default:                 <code>ONE_LINE</code> )         \u2013          <p>The explanation style to use.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>An explanation.</p> </li> </ul> Source code in <code>src/griffe/diff.py</code> <pre><code>def explain(self, style: ExplanationStyle = ExplanationStyle.ONE_LINE) -&gt; str:\n\"\"\"Explain the breakage by showing old and new value.\n\n    Parameters:\n        style: The explanation style to use.\n\n    Returns:\n        An explanation.\n    \"\"\"\n    return getattr(self, f\"_explain_{style.value}\")()\n</code></pre>"},{"location":"reference/griffe/diff/#griffe.diff.Breakage","title":"Breakage","text":"<pre><code>Breakage(\n    obj: Object,\n    old_value: Any,\n    new_value: Any,\n    details: str = \"\",\n)\n</code></pre> <p>Breakages can explain what broke from a version to another.</p> <p>Parameters:</p> <ul> <li> obj             (<code>Object</code>)         \u2013          <p>The object related to the breakage.</p> </li> <li> old_value             (<code>Any</code>)         \u2013          <p>The old value.</p> </li> <li> new_value             (<code>Any</code>)         \u2013          <p>The new, incompatible value.</p> </li> <li> details             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>Some details about the breakage.</p> </li> </ul> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this object's data as a dictionary.</p> </li> <li> explain           \u2013            <p>Explain the breakage by showing old and new value.</p> </li> </ul> Source code in <code>src/griffe/diff.py</code> <pre><code>def __init__(self, obj: Object, old_value: Any, new_value: Any, details: str = \"\") -&gt; None:\n\"\"\"Initialize the breakage.\n\n    Parameters:\n        obj: The object related to the breakage.\n        old_value: The old value.\n        new_value: The new, incompatible value.\n        details: Some details about the breakage.\n    \"\"\"\n    self.obj = obj\n    self.old_value = old_value\n    self.new_value = new_value\n    self.details = details\n</code></pre>"},{"location":"reference/griffe/diff/#griffe.diff.Breakage.as_dict","title":"as_dict","text":"<pre><code>as_dict(\n    *, full: bool = False, **kwargs: Any\n) -&gt; dict[str, Any]\n</code></pre> <p>Return this object's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> full             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to return full info, or just base info.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/diff.py</code> <pre><code>def as_dict(self, *, full: bool = False, **kwargs: Any) -&gt; dict[str, Any]:  # noqa: ARG002\n\"\"\"Return this object's data as a dictionary.\n\n    Parameters:\n        full: Whether to return full info, or just base info.\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return {\n        \"kind\": self.kind,\n        \"object_path\": self.obj.path,\n        \"old_value\": self.old_value,\n        \"new_value\": self.new_value,\n    }\n</code></pre>"},{"location":"reference/griffe/diff/#griffe.diff.Breakage.explain","title":"explain","text":"<pre><code>explain(\n    style: ExplanationStyle = ExplanationStyle.ONE_LINE,\n) -&gt; str\n</code></pre> <p>Explain the breakage by showing old and new value.</p> <p>Parameters:</p> <ul> <li> style             (<code>ExplanationStyle</code>, default:                 <code>ONE_LINE</code> )         \u2013          <p>The explanation style to use.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>An explanation.</p> </li> </ul> Source code in <code>src/griffe/diff.py</code> <pre><code>def explain(self, style: ExplanationStyle = ExplanationStyle.ONE_LINE) -&gt; str:\n\"\"\"Explain the breakage by showing old and new value.\n\n    Parameters:\n        style: The explanation style to use.\n\n    Returns:\n        An explanation.\n    \"\"\"\n    return getattr(self, f\"_explain_{style.value}\")()\n</code></pre>"},{"location":"reference/griffe/diff/#griffe.diff.BreakageKind","title":"BreakageKind","text":"<p>             Bases: <code>Enum</code></p> <p>An enumeration of the possible breakages.</p>"},{"location":"reference/griffe/diff/#griffe.diff.ClassRemovedBaseBreakage","title":"ClassRemovedBaseBreakage","text":"<p>             Bases: <code>Breakage</code></p> <p>Specific breakage class for removed base classes.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this object's data as a dictionary.</p> </li> <li> explain           \u2013            <p>Explain the breakage by showing old and new value.</p> </li> </ul>"},{"location":"reference/griffe/diff/#griffe.diff.ClassRemovedBaseBreakage.as_dict","title":"as_dict","text":"<pre><code>as_dict(\n    *, full: bool = False, **kwargs: Any\n) -&gt; dict[str, Any]\n</code></pre> <p>Return this object's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> full             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to return full info, or just base info.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/diff.py</code> <pre><code>def as_dict(self, *, full: bool = False, **kwargs: Any) -&gt; dict[str, Any]:  # noqa: ARG002\n\"\"\"Return this object's data as a dictionary.\n\n    Parameters:\n        full: Whether to return full info, or just base info.\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return {\n        \"kind\": self.kind,\n        \"object_path\": self.obj.path,\n        \"old_value\": self.old_value,\n        \"new_value\": self.new_value,\n    }\n</code></pre>"},{"location":"reference/griffe/diff/#griffe.diff.ClassRemovedBaseBreakage.explain","title":"explain","text":"<pre><code>explain(\n    style: ExplanationStyle = ExplanationStyle.ONE_LINE,\n) -&gt; str\n</code></pre> <p>Explain the breakage by showing old and new value.</p> <p>Parameters:</p> <ul> <li> style             (<code>ExplanationStyle</code>, default:                 <code>ONE_LINE</code> )         \u2013          <p>The explanation style to use.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>An explanation.</p> </li> </ul> Source code in <code>src/griffe/diff.py</code> <pre><code>def explain(self, style: ExplanationStyle = ExplanationStyle.ONE_LINE) -&gt; str:\n\"\"\"Explain the breakage by showing old and new value.\n\n    Parameters:\n        style: The explanation style to use.\n\n    Returns:\n        An explanation.\n    \"\"\"\n    return getattr(self, f\"_explain_{style.value}\")()\n</code></pre>"},{"location":"reference/griffe/diff/#griffe.diff.ExplanationStyle","title":"ExplanationStyle","text":"<p>             Bases: <code>Enum</code></p> <p>An enumeration of the possible styles for explanations.</p>"},{"location":"reference/griffe/diff/#griffe.diff.ObjectChangedKindBreakage","title":"ObjectChangedKindBreakage","text":"<p>             Bases: <code>Breakage</code></p> <p>Specific breakage class for objects whose kind changed.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this object's data as a dictionary.</p> </li> <li> explain           \u2013            <p>Explain the breakage by showing old and new value.</p> </li> </ul>"},{"location":"reference/griffe/diff/#griffe.diff.ObjectChangedKindBreakage.as_dict","title":"as_dict","text":"<pre><code>as_dict(\n    *, full: bool = False, **kwargs: Any\n) -&gt; dict[str, Any]\n</code></pre> <p>Return this object's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> full             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to return full info, or just base info.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/diff.py</code> <pre><code>def as_dict(self, *, full: bool = False, **kwargs: Any) -&gt; dict[str, Any]:  # noqa: ARG002\n\"\"\"Return this object's data as a dictionary.\n\n    Parameters:\n        full: Whether to return full info, or just base info.\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return {\n        \"kind\": self.kind,\n        \"object_path\": self.obj.path,\n        \"old_value\": self.old_value,\n        \"new_value\": self.new_value,\n    }\n</code></pre>"},{"location":"reference/griffe/diff/#griffe.diff.ObjectChangedKindBreakage.explain","title":"explain","text":"<pre><code>explain(\n    style: ExplanationStyle = ExplanationStyle.ONE_LINE,\n) -&gt; str\n</code></pre> <p>Explain the breakage by showing old and new value.</p> <p>Parameters:</p> <ul> <li> style             (<code>ExplanationStyle</code>, default:                 <code>ONE_LINE</code> )         \u2013          <p>The explanation style to use.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>An explanation.</p> </li> </ul> Source code in <code>src/griffe/diff.py</code> <pre><code>def explain(self, style: ExplanationStyle = ExplanationStyle.ONE_LINE) -&gt; str:\n\"\"\"Explain the breakage by showing old and new value.\n\n    Parameters:\n        style: The explanation style to use.\n\n    Returns:\n        An explanation.\n    \"\"\"\n    return getattr(self, f\"_explain_{style.value}\")()\n</code></pre>"},{"location":"reference/griffe/diff/#griffe.diff.ObjectRemovedBreakage","title":"ObjectRemovedBreakage","text":"<p>             Bases: <code>Breakage</code></p> <p>Specific breakage class for removed objects.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this object's data as a dictionary.</p> </li> <li> explain           \u2013            <p>Explain the breakage by showing old and new value.</p> </li> </ul>"},{"location":"reference/griffe/diff/#griffe.diff.ObjectRemovedBreakage.as_dict","title":"as_dict","text":"<pre><code>as_dict(\n    *, full: bool = False, **kwargs: Any\n) -&gt; dict[str, Any]\n</code></pre> <p>Return this object's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> full             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to return full info, or just base info.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/diff.py</code> <pre><code>def as_dict(self, *, full: bool = False, **kwargs: Any) -&gt; dict[str, Any]:  # noqa: ARG002\n\"\"\"Return this object's data as a dictionary.\n\n    Parameters:\n        full: Whether to return full info, or just base info.\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return {\n        \"kind\": self.kind,\n        \"object_path\": self.obj.path,\n        \"old_value\": self.old_value,\n        \"new_value\": self.new_value,\n    }\n</code></pre>"},{"location":"reference/griffe/diff/#griffe.diff.ObjectRemovedBreakage.explain","title":"explain","text":"<pre><code>explain(\n    style: ExplanationStyle = ExplanationStyle.ONE_LINE,\n) -&gt; str\n</code></pre> <p>Explain the breakage by showing old and new value.</p> <p>Parameters:</p> <ul> <li> style             (<code>ExplanationStyle</code>, default:                 <code>ONE_LINE</code> )         \u2013          <p>The explanation style to use.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>An explanation.</p> </li> </ul> Source code in <code>src/griffe/diff.py</code> <pre><code>def explain(self, style: ExplanationStyle = ExplanationStyle.ONE_LINE) -&gt; str:\n\"\"\"Explain the breakage by showing old and new value.\n\n    Parameters:\n        style: The explanation style to use.\n\n    Returns:\n        An explanation.\n    \"\"\"\n    return getattr(self, f\"_explain_{style.value}\")()\n</code></pre>"},{"location":"reference/griffe/diff/#griffe.diff.ParameterAddedRequiredBreakage","title":"ParameterAddedRequiredBreakage","text":"<p>             Bases: <code>Breakage</code></p> <p>Specific breakage class for new parameters added as required.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this object's data as a dictionary.</p> </li> <li> explain           \u2013            <p>Explain the breakage by showing old and new value.</p> </li> </ul>"},{"location":"reference/griffe/diff/#griffe.diff.ParameterAddedRequiredBreakage.as_dict","title":"as_dict","text":"<pre><code>as_dict(\n    *, full: bool = False, **kwargs: Any\n) -&gt; dict[str, Any]\n</code></pre> <p>Return this object's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> full             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to return full info, or just base info.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/diff.py</code> <pre><code>def as_dict(self, *, full: bool = False, **kwargs: Any) -&gt; dict[str, Any]:  # noqa: ARG002\n\"\"\"Return this object's data as a dictionary.\n\n    Parameters:\n        full: Whether to return full info, or just base info.\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return {\n        \"kind\": self.kind,\n        \"object_path\": self.obj.path,\n        \"old_value\": self.old_value,\n        \"new_value\": self.new_value,\n    }\n</code></pre>"},{"location":"reference/griffe/diff/#griffe.diff.ParameterAddedRequiredBreakage.explain","title":"explain","text":"<pre><code>explain(\n    style: ExplanationStyle = ExplanationStyle.ONE_LINE,\n) -&gt; str\n</code></pre> <p>Explain the breakage by showing old and new value.</p> <p>Parameters:</p> <ul> <li> style             (<code>ExplanationStyle</code>, default:                 <code>ONE_LINE</code> )         \u2013          <p>The explanation style to use.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>An explanation.</p> </li> </ul> Source code in <code>src/griffe/diff.py</code> <pre><code>def explain(self, style: ExplanationStyle = ExplanationStyle.ONE_LINE) -&gt; str:\n\"\"\"Explain the breakage by showing old and new value.\n\n    Parameters:\n        style: The explanation style to use.\n\n    Returns:\n        An explanation.\n    \"\"\"\n    return getattr(self, f\"_explain_{style.value}\")()\n</code></pre>"},{"location":"reference/griffe/diff/#griffe.diff.ParameterChangedDefaultBreakage","title":"ParameterChangedDefaultBreakage","text":"<p>             Bases: <code>Breakage</code></p> <p>Specific breakage class for parameters whose default value changed.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this object's data as a dictionary.</p> </li> <li> explain           \u2013            <p>Explain the breakage by showing old and new value.</p> </li> </ul>"},{"location":"reference/griffe/diff/#griffe.diff.ParameterChangedDefaultBreakage.as_dict","title":"as_dict","text":"<pre><code>as_dict(\n    *, full: bool = False, **kwargs: Any\n) -&gt; dict[str, Any]\n</code></pre> <p>Return this object's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> full             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to return full info, or just base info.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/diff.py</code> <pre><code>def as_dict(self, *, full: bool = False, **kwargs: Any) -&gt; dict[str, Any]:  # noqa: ARG002\n\"\"\"Return this object's data as a dictionary.\n\n    Parameters:\n        full: Whether to return full info, or just base info.\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return {\n        \"kind\": self.kind,\n        \"object_path\": self.obj.path,\n        \"old_value\": self.old_value,\n        \"new_value\": self.new_value,\n    }\n</code></pre>"},{"location":"reference/griffe/diff/#griffe.diff.ParameterChangedDefaultBreakage.explain","title":"explain","text":"<pre><code>explain(\n    style: ExplanationStyle = ExplanationStyle.ONE_LINE,\n) -&gt; str\n</code></pre> <p>Explain the breakage by showing old and new value.</p> <p>Parameters:</p> <ul> <li> style             (<code>ExplanationStyle</code>, default:                 <code>ONE_LINE</code> )         \u2013          <p>The explanation style to use.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>An explanation.</p> </li> </ul> Source code in <code>src/griffe/diff.py</code> <pre><code>def explain(self, style: ExplanationStyle = ExplanationStyle.ONE_LINE) -&gt; str:\n\"\"\"Explain the breakage by showing old and new value.\n\n    Parameters:\n        style: The explanation style to use.\n\n    Returns:\n        An explanation.\n    \"\"\"\n    return getattr(self, f\"_explain_{style.value}\")()\n</code></pre>"},{"location":"reference/griffe/diff/#griffe.diff.ParameterChangedKindBreakage","title":"ParameterChangedKindBreakage","text":"<p>             Bases: <code>Breakage</code></p> <p>Specific breakage class for parameters whose kind changed.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this object's data as a dictionary.</p> </li> <li> explain           \u2013            <p>Explain the breakage by showing old and new value.</p> </li> </ul>"},{"location":"reference/griffe/diff/#griffe.diff.ParameterChangedKindBreakage.as_dict","title":"as_dict","text":"<pre><code>as_dict(\n    *, full: bool = False, **kwargs: Any\n) -&gt; dict[str, Any]\n</code></pre> <p>Return this object's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> full             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to return full info, or just base info.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/diff.py</code> <pre><code>def as_dict(self, *, full: bool = False, **kwargs: Any) -&gt; dict[str, Any]:  # noqa: ARG002\n\"\"\"Return this object's data as a dictionary.\n\n    Parameters:\n        full: Whether to return full info, or just base info.\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return {\n        \"kind\": self.kind,\n        \"object_path\": self.obj.path,\n        \"old_value\": self.old_value,\n        \"new_value\": self.new_value,\n    }\n</code></pre>"},{"location":"reference/griffe/diff/#griffe.diff.ParameterChangedKindBreakage.explain","title":"explain","text":"<pre><code>explain(\n    style: ExplanationStyle = ExplanationStyle.ONE_LINE,\n) -&gt; str\n</code></pre> <p>Explain the breakage by showing old and new value.</p> <p>Parameters:</p> <ul> <li> style             (<code>ExplanationStyle</code>, default:                 <code>ONE_LINE</code> )         \u2013          <p>The explanation style to use.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>An explanation.</p> </li> </ul> Source code in <code>src/griffe/diff.py</code> <pre><code>def explain(self, style: ExplanationStyle = ExplanationStyle.ONE_LINE) -&gt; str:\n\"\"\"Explain the breakage by showing old and new value.\n\n    Parameters:\n        style: The explanation style to use.\n\n    Returns:\n        An explanation.\n    \"\"\"\n    return getattr(self, f\"_explain_{style.value}\")()\n</code></pre>"},{"location":"reference/griffe/diff/#griffe.diff.ParameterChangedRequiredBreakage","title":"ParameterChangedRequiredBreakage","text":"<p>             Bases: <code>Breakage</code></p> <p>Specific breakage class for parameters which became required.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this object's data as a dictionary.</p> </li> <li> explain           \u2013            <p>Explain the breakage by showing old and new value.</p> </li> </ul>"},{"location":"reference/griffe/diff/#griffe.diff.ParameterChangedRequiredBreakage.as_dict","title":"as_dict","text":"<pre><code>as_dict(\n    *, full: bool = False, **kwargs: Any\n) -&gt; dict[str, Any]\n</code></pre> <p>Return this object's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> full             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to return full info, or just base info.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/diff.py</code> <pre><code>def as_dict(self, *, full: bool = False, **kwargs: Any) -&gt; dict[str, Any]:  # noqa: ARG002\n\"\"\"Return this object's data as a dictionary.\n\n    Parameters:\n        full: Whether to return full info, or just base info.\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return {\n        \"kind\": self.kind,\n        \"object_path\": self.obj.path,\n        \"old_value\": self.old_value,\n        \"new_value\": self.new_value,\n    }\n</code></pre>"},{"location":"reference/griffe/diff/#griffe.diff.ParameterChangedRequiredBreakage.explain","title":"explain","text":"<pre><code>explain(\n    style: ExplanationStyle = ExplanationStyle.ONE_LINE,\n) -&gt; str\n</code></pre> <p>Explain the breakage by showing old and new value.</p> <p>Parameters:</p> <ul> <li> style             (<code>ExplanationStyle</code>, default:                 <code>ONE_LINE</code> )         \u2013          <p>The explanation style to use.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>An explanation.</p> </li> </ul> Source code in <code>src/griffe/diff.py</code> <pre><code>def explain(self, style: ExplanationStyle = ExplanationStyle.ONE_LINE) -&gt; str:\n\"\"\"Explain the breakage by showing old and new value.\n\n    Parameters:\n        style: The explanation style to use.\n\n    Returns:\n        An explanation.\n    \"\"\"\n    return getattr(self, f\"_explain_{style.value}\")()\n</code></pre>"},{"location":"reference/griffe/diff/#griffe.diff.ParameterMovedBreakage","title":"ParameterMovedBreakage","text":"<p>             Bases: <code>Breakage</code></p> <p>Specific breakage class for moved parameters.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this object's data as a dictionary.</p> </li> <li> explain           \u2013            <p>Explain the breakage by showing old and new value.</p> </li> </ul>"},{"location":"reference/griffe/diff/#griffe.diff.ParameterMovedBreakage.as_dict","title":"as_dict","text":"<pre><code>as_dict(\n    *, full: bool = False, **kwargs: Any\n) -&gt; dict[str, Any]\n</code></pre> <p>Return this object's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> full             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to return full info, or just base info.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/diff.py</code> <pre><code>def as_dict(self, *, full: bool = False, **kwargs: Any) -&gt; dict[str, Any]:  # noqa: ARG002\n\"\"\"Return this object's data as a dictionary.\n\n    Parameters:\n        full: Whether to return full info, or just base info.\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return {\n        \"kind\": self.kind,\n        \"object_path\": self.obj.path,\n        \"old_value\": self.old_value,\n        \"new_value\": self.new_value,\n    }\n</code></pre>"},{"location":"reference/griffe/diff/#griffe.diff.ParameterMovedBreakage.explain","title":"explain","text":"<pre><code>explain(\n    style: ExplanationStyle = ExplanationStyle.ONE_LINE,\n) -&gt; str\n</code></pre> <p>Explain the breakage by showing old and new value.</p> <p>Parameters:</p> <ul> <li> style             (<code>ExplanationStyle</code>, default:                 <code>ONE_LINE</code> )         \u2013          <p>The explanation style to use.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>An explanation.</p> </li> </ul> Source code in <code>src/griffe/diff.py</code> <pre><code>def explain(self, style: ExplanationStyle = ExplanationStyle.ONE_LINE) -&gt; str:\n\"\"\"Explain the breakage by showing old and new value.\n\n    Parameters:\n        style: The explanation style to use.\n\n    Returns:\n        An explanation.\n    \"\"\"\n    return getattr(self, f\"_explain_{style.value}\")()\n</code></pre>"},{"location":"reference/griffe/diff/#griffe.diff.ParameterRemovedBreakage","title":"ParameterRemovedBreakage","text":"<p>             Bases: <code>Breakage</code></p> <p>Specific breakage class for removed parameters.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this object's data as a dictionary.</p> </li> <li> explain           \u2013            <p>Explain the breakage by showing old and new value.</p> </li> </ul>"},{"location":"reference/griffe/diff/#griffe.diff.ParameterRemovedBreakage.as_dict","title":"as_dict","text":"<pre><code>as_dict(\n    *, full: bool = False, **kwargs: Any\n) -&gt; dict[str, Any]\n</code></pre> <p>Return this object's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> full             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to return full info, or just base info.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/diff.py</code> <pre><code>def as_dict(self, *, full: bool = False, **kwargs: Any) -&gt; dict[str, Any]:  # noqa: ARG002\n\"\"\"Return this object's data as a dictionary.\n\n    Parameters:\n        full: Whether to return full info, or just base info.\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return {\n        \"kind\": self.kind,\n        \"object_path\": self.obj.path,\n        \"old_value\": self.old_value,\n        \"new_value\": self.new_value,\n    }\n</code></pre>"},{"location":"reference/griffe/diff/#griffe.diff.ParameterRemovedBreakage.explain","title":"explain","text":"<pre><code>explain(\n    style: ExplanationStyle = ExplanationStyle.ONE_LINE,\n) -&gt; str\n</code></pre> <p>Explain the breakage by showing old and new value.</p> <p>Parameters:</p> <ul> <li> style             (<code>ExplanationStyle</code>, default:                 <code>ONE_LINE</code> )         \u2013          <p>The explanation style to use.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>An explanation.</p> </li> </ul> Source code in <code>src/griffe/diff.py</code> <pre><code>def explain(self, style: ExplanationStyle = ExplanationStyle.ONE_LINE) -&gt; str:\n\"\"\"Explain the breakage by showing old and new value.\n\n    Parameters:\n        style: The explanation style to use.\n\n    Returns:\n        An explanation.\n    \"\"\"\n    return getattr(self, f\"_explain_{style.value}\")()\n</code></pre>"},{"location":"reference/griffe/diff/#griffe.diff.ReturnChangedTypeBreakage","title":"ReturnChangedTypeBreakage","text":"<p>             Bases: <code>Breakage</code></p> <p>Specific breakage class for return values which changed type.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this object's data as a dictionary.</p> </li> <li> explain           \u2013            <p>Explain the breakage by showing old and new value.</p> </li> </ul>"},{"location":"reference/griffe/diff/#griffe.diff.ReturnChangedTypeBreakage.as_dict","title":"as_dict","text":"<pre><code>as_dict(\n    *, full: bool = False, **kwargs: Any\n) -&gt; dict[str, Any]\n</code></pre> <p>Return this object's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> full             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to return full info, or just base info.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/diff.py</code> <pre><code>def as_dict(self, *, full: bool = False, **kwargs: Any) -&gt; dict[str, Any]:  # noqa: ARG002\n\"\"\"Return this object's data as a dictionary.\n\n    Parameters:\n        full: Whether to return full info, or just base info.\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return {\n        \"kind\": self.kind,\n        \"object_path\": self.obj.path,\n        \"old_value\": self.old_value,\n        \"new_value\": self.new_value,\n    }\n</code></pre>"},{"location":"reference/griffe/diff/#griffe.diff.ReturnChangedTypeBreakage.explain","title":"explain","text":"<pre><code>explain(\n    style: ExplanationStyle = ExplanationStyle.ONE_LINE,\n) -&gt; str\n</code></pre> <p>Explain the breakage by showing old and new value.</p> <p>Parameters:</p> <ul> <li> style             (<code>ExplanationStyle</code>, default:                 <code>ONE_LINE</code> )         \u2013          <p>The explanation style to use.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>An explanation.</p> </li> </ul> Source code in <code>src/griffe/diff.py</code> <pre><code>def explain(self, style: ExplanationStyle = ExplanationStyle.ONE_LINE) -&gt; str:\n\"\"\"Explain the breakage by showing old and new value.\n\n    Parameters:\n        style: The explanation style to use.\n\n    Returns:\n        An explanation.\n    \"\"\"\n    return getattr(self, f\"_explain_{style.value}\")()\n</code></pre>"},{"location":"reference/griffe/diff/#griffe.diff.find_breaking_changes","title":"find_breaking_changes","text":"<pre><code>find_breaking_changes(\n    old_obj: Object | Alias,\n    new_obj: Object | Alias,\n    *,\n    ignore_private: bool = True\n) -&gt; Iterator[Breakage]\n</code></pre> <p>Find breaking changes between two versions of the same API.</p> <p>The function will iterate recursively on all objects and yield breaking changes with detailed information.</p> <p>Parameters:</p> <ul> <li> old_obj             (<code>Object | Alias</code>)         \u2013          <p>The old version of an object.</p> </li> <li> new_obj             (<code>Object | Alias</code>)         \u2013          <p>The new version of an object.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>Breakage</code>         \u2013          <p>Breaking changes.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import sys, griffe\n&gt;&gt;&gt; new = griffe.load(\"pkg\")\n&gt;&gt;&gt; old = griffe.load_git(\"pkg\", \"1.2.3\")\n&gt;&gt;&gt; for breakage in griffe.find_breaking_changes(old, new)\n...     print(breakage.explain(style=style), file=sys.stderr)\n</code></pre> Source code in <code>src/griffe/diff.py</code> <pre><code>def find_breaking_changes(\n    old_obj: Object | Alias,\n    new_obj: Object | Alias,\n    *,\n    ignore_private: bool = True,\n) -&gt; Iterator[Breakage]:\n\"\"\"Find breaking changes between two versions of the same API.\n\n    The function will iterate recursively on all objects\n    and yield breaking changes with detailed information.\n\n    Parameters:\n        old_obj: The old version of an object.\n        new_obj: The new version of an object.\n\n    Yields:\n        Breaking changes.\n\n    Examples:\n        &gt;&gt;&gt; import sys, griffe\n        &gt;&gt;&gt; new = griffe.load(\"pkg\")\n        &gt;&gt;&gt; old = griffe.load_git(\"pkg\", \"1.2.3\")\n        &gt;&gt;&gt; for breakage in griffe.find_breaking_changes(old, new)\n        ...     print(breakage.explain(style=style), file=sys.stderr)\n    \"\"\"\n    yield from _member_incompatibilities(old_obj, new_obj, ignore_private=ignore_private)\n</code></pre>"},{"location":"reference/griffe/encoders/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> encoders","text":""},{"location":"reference/griffe/encoders/#griffe.encoders","title":"encoders","text":"<p>This module contains data encoders/serializers and decoders/deserializers.</p> <p>The available formats are:</p> <ul> <li><code>JSON</code>: see the <code>JSONEncoder</code> and <code>json_decoder</code>.</li> </ul> <p>Classes:</p> <ul> <li> JSONEncoder         \u2013          <p>JSON encoder.</p> </li> </ul> <p>Functions:</p> <ul> <li> json_decoder           \u2013            <p>Decode dictionaries as data classes.</p> </li> </ul>"},{"location":"reference/griffe/encoders/#griffe.encoders.JSONEncoder","title":"JSONEncoder","text":"<pre><code>JSONEncoder(\n    *args: Any,\n    full: bool = False,\n    docstring_parser: Parser | None = None,\n    docstring_options: dict[str, Any] | None = None,\n    **kwargs: Any\n)\n</code></pre> <p>             Bases: <code>JSONEncoder</code></p> <p>JSON encoder.</p> <p>JSON encoders can be used directly, or through the <code>json.dump</code> or <code>json.dumps</code> methods.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from griffe.encoders import JSONEncoder\n&gt;&gt;&gt; JSONEncoder(full=True).encode(..., **kwargs)\n</code></pre> <pre><code>&gt;&gt;&gt; import json\n&gt;&gt;&gt; from griffe.encoders import JSONEncoder\n&gt;&gt;&gt; json.dumps(..., cls=JSONEncoder, full=True, **kwargs)\n</code></pre> <p>Parameters:</p> <ul> <li> *args             (<code>Any</code>, default:                 <code>()</code> )         \u2013          <p>See <code>json.JSONEncoder</code>.</p> </li> <li> full             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to dump full data or base data. If you plan to reload the data in Python memory using the <code>json_decoder</code>, you don't need the full data as it can be infered again using the base data. If you want to feed a non-Python tool instead, dump the full data.</p> </li> <li> docstring_parser             (<code>Parser | None</code>, default:                 <code>None</code> )         \u2013          <p>The docstring parser to use. By default, no parsing is done.</p> </li> <li> docstring_options             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional docstring parsing options.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>See <code>json.JSONEncoder</code>.</p> </li> </ul> <p>Methods:</p> <ul> <li> default           \u2013            <p>Return a serializable representation of the given object.</p> </li> </ul> Source code in <code>src/griffe/encoders.py</code> <pre><code>def __init__(\n    self,\n    *args: Any,\n    full: bool = False,\n    docstring_parser: Parser | None = None,\n    docstring_options: dict[str, Any] | None = None,\n    **kwargs: Any,\n) -&gt; None:\n\"\"\"Initialize the encoder.\n\n    Parameters:\n        *args: See [`json.JSONEncoder`][].\n        full: Whether to dump full data or base data.\n            If you plan to reload the data in Python memory\n            using the [`json_decoder`][griffe.encoders.json_decoder],\n            you don't need the full data as it can be infered again\n            using the base data. If you want to feed a non-Python\n            tool instead, dump the full data.\n        docstring_parser: The docstring parser to use. By default, no parsing is done.\n        docstring_options: Additional docstring parsing options.\n        **kwargs: See [`json.JSONEncoder`][].\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.full: bool = full\n    self.docstring_parser: Parser | None = docstring_parser\n    self.docstring_options: dict[str, Any] = docstring_options or {}\n</code></pre>"},{"location":"reference/griffe/encoders/#griffe.encoders.JSONEncoder.default","title":"default","text":"<pre><code>default(obj: Any) -&gt; Any\n</code></pre> <p>Return a serializable representation of the given object.</p> <p>Parameters:</p> <ul> <li> obj             (<code>Any</code>)         \u2013          <p>The object to serialize.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code>         \u2013          <p>A serializable representation.</p> </li> </ul> Source code in <code>src/griffe/encoders.py</code> <pre><code>def default(self, obj: Any) -&gt; Any:\n\"\"\"Return a serializable representation of the given object.\n\n    Parameters:\n        obj: The object to serialize.\n\n    Returns:\n        A serializable representation.\n    \"\"\"\n    try:\n        return obj.as_dict(full=self.full, docstring_parser=self.docstring_parser, **self.docstring_options)\n    except AttributeError:\n        return _json_encoder_map.get(type(obj), super().default)(obj)\n</code></pre>"},{"location":"reference/griffe/encoders/#griffe.encoders.json_decoder","title":"json_decoder","text":"<pre><code>json_decoder(\n    obj_dict: dict[str, Any]\n) -&gt; (\n    dict[str, Any] | Object | Alias | Parameter | str | Expr\n)\n</code></pre> <p>Decode dictionaries as data classes.</p> <p>The <code>json.loads</code> method walks the tree from bottom to top.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import json\n&gt;&gt;&gt; from griffe.encoders import json_decoder\n&gt;&gt;&gt; json.loads(..., object_hook=json_decoder)\n</code></pre> <p>Parameters:</p> <ul> <li> obj_dict             (<code>dict[str, Any]</code>)         \u2013          <p>The dictionary to decode.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any] | Object | Alias | Parameter | str | Expr</code>         \u2013          <p>An instance of a data class.</p> </li> </ul> Source code in <code>src/griffe/encoders.py</code> <pre><code>def json_decoder(obj_dict: dict[str, Any]) -&gt; dict[str, Any] | Object | Alias | Parameter | str | expressions.Expr:\n\"\"\"Decode dictionaries as data classes.\n\n    The [`json.loads`][] method walks the tree from bottom to top.\n\n    Examples:\n        &gt;&gt;&gt; import json\n        &gt;&gt;&gt; from griffe.encoders import json_decoder\n        &gt;&gt;&gt; json.loads(..., object_hook=json_decoder)\n\n    Parameters:\n        obj_dict: The dictionary to decode.\n\n    Returns:\n        An instance of a data class.\n    \"\"\"\n    if \"cls\" in obj_dict:\n        return _load_expression(obj_dict)\n    if \"kind\" in obj_dict:\n        try:\n            kind = Kind(obj_dict[\"kind\"])\n        except ValueError:\n            return _load_parameter(obj_dict)\n        return _loader_map[kind](obj_dict)\n    return obj_dict\n</code></pre>"},{"location":"reference/griffe/enumerations/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> enumerations","text":""},{"location":"reference/griffe/enumerations/#griffe.enumerations","title":"enumerations","text":"<p>This module contains all the enumerations of the package.</p> <p>Classes:</p> <ul> <li> BreakageKind         \u2013          <p>An enumeration of the possible breakages.</p> </li> <li> DocstringSectionKind         \u2013          <p>The possible section kinds.</p> </li> <li> ExplanationStyle         \u2013          <p>An enumeration of the possible styles for explanations.</p> </li> <li> Kind         \u2013          <p>Enumeration of the different objects kinds.</p> </li> <li> ObjectKind         \u2013          <p>Enumeration for the different kinds of objects.</p> </li> <li> ParameterKind         \u2013          <p>Enumeration of the different parameter kinds.</p> </li> <li> Parser         \u2013          <p>Enumeration for the different docstring parsers.</p> </li> <li> When         \u2013          <p>This enumeration contains the different times at which an extension is used.</p> </li> </ul>"},{"location":"reference/griffe/enumerations/#griffe.enumerations.BreakageKind","title":"BreakageKind","text":"<p>             Bases: <code>Enum</code></p> <p>An enumeration of the possible breakages.</p>"},{"location":"reference/griffe/enumerations/#griffe.enumerations.DocstringSectionKind","title":"DocstringSectionKind","text":"<p>             Bases: <code>Enum</code></p> <p>The possible section kinds.</p>"},{"location":"reference/griffe/enumerations/#griffe.enumerations.ExplanationStyle","title":"ExplanationStyle","text":"<p>             Bases: <code>Enum</code></p> <p>An enumeration of the possible styles for explanations.</p>"},{"location":"reference/griffe/enumerations/#griffe.enumerations.Kind","title":"Kind","text":"<p>             Bases: <code>Enum</code></p> <p>Enumeration of the different objects kinds.</p> <p>Attributes:</p> <ul> <li> MODULE             (<code>str</code>)         \u2013          <p>The module kind.</p> </li> <li> CLASS             (<code>str</code>)         \u2013          <p>The class kind.</p> </li> <li> FUNCTION             (<code>str</code>)         \u2013          <p>The function kind.</p> </li> <li> ATTRIBUTE             (<code>str</code>)         \u2013          <p>The attribute kind.</p> </li> </ul>"},{"location":"reference/griffe/enumerations/#griffe.enumerations.ObjectKind","title":"ObjectKind","text":"<p>             Bases: <code>Enum</code></p> <p>Enumeration for the different kinds of objects.</p> <p>Attributes:</p> <ul> <li> ATTRIBUTE             (<code>str</code>)         \u2013          <p>Attributes.</p> </li> <li> BUILTIN_FUNCTION             (<code>str</code>)         \u2013          <p>Built-in functions.</p> </li> <li> BUILTIN_METHOD             (<code>str</code>)         \u2013          <p>Built-in ethods.</p> </li> <li> CACHED_PROPERTY             (<code>str</code>)         \u2013          <p>Cached properties.</p> </li> <li> CLASS             (<code>str</code>)         \u2013          <p>Classes.</p> </li> <li> CLASSMETHOD             (<code>str</code>)         \u2013          <p>Class methods.</p> </li> <li> COROUTINE             (<code>str</code>)         \u2013          <p>Coroutines</p> </li> <li> FUNCTION             (<code>str</code>)         \u2013          <p>Functions.</p> </li> <li> METHOD             (<code>str</code>)         \u2013          <p>Methods.</p> </li> <li> METHOD_DESCRIPTOR             (<code>str</code>)         \u2013          <p>Method descriptors.</p> </li> <li> MODULE             (<code>str</code>)         \u2013          <p>Modules.</p> </li> <li> PROPERTY             (<code>str</code>)         \u2013          <p>Properties.</p> </li> <li> STATICMETHOD             (<code>str</code>)         \u2013          <p>Static methods.</p> </li> </ul>"},{"location":"reference/griffe/enumerations/#griffe.enumerations.ObjectKind.ATTRIBUTE","title":"ATTRIBUTE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ATTRIBUTE: str = 'attribute'\n</code></pre> <p>Attributes.</p>"},{"location":"reference/griffe/enumerations/#griffe.enumerations.ObjectKind.BUILTIN_FUNCTION","title":"BUILTIN_FUNCTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BUILTIN_FUNCTION: str = 'builtin_function'\n</code></pre> <p>Built-in functions.</p>"},{"location":"reference/griffe/enumerations/#griffe.enumerations.ObjectKind.BUILTIN_METHOD","title":"BUILTIN_METHOD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BUILTIN_METHOD: str = 'builtin_method'\n</code></pre> <p>Built-in ethods.</p>"},{"location":"reference/griffe/enumerations/#griffe.enumerations.ObjectKind.CACHED_PROPERTY","title":"CACHED_PROPERTY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CACHED_PROPERTY: str = 'cached_property'\n</code></pre> <p>Cached properties.</p>"},{"location":"reference/griffe/enumerations/#griffe.enumerations.ObjectKind.CLASS","title":"CLASS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CLASS: str = 'class'\n</code></pre> <p>Classes.</p>"},{"location":"reference/griffe/enumerations/#griffe.enumerations.ObjectKind.CLASSMETHOD","title":"CLASSMETHOD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CLASSMETHOD: str = 'classmethod'\n</code></pre> <p>Class methods.</p>"},{"location":"reference/griffe/enumerations/#griffe.enumerations.ObjectKind.COROUTINE","title":"COROUTINE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>COROUTINE: str = 'coroutine'\n</code></pre> <p>Coroutines</p>"},{"location":"reference/griffe/enumerations/#griffe.enumerations.ObjectKind.FUNCTION","title":"FUNCTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FUNCTION: str = 'function'\n</code></pre> <p>Functions.</p>"},{"location":"reference/griffe/enumerations/#griffe.enumerations.ObjectKind.METHOD","title":"METHOD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>METHOD: str = 'method'\n</code></pre> <p>Methods.</p>"},{"location":"reference/griffe/enumerations/#griffe.enumerations.ObjectKind.METHOD_DESCRIPTOR","title":"METHOD_DESCRIPTOR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>METHOD_DESCRIPTOR: str = 'method_descriptor'\n</code></pre> <p>Method descriptors.</p>"},{"location":"reference/griffe/enumerations/#griffe.enumerations.ObjectKind.MODULE","title":"MODULE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MODULE: str = 'module'\n</code></pre> <p>Modules.</p>"},{"location":"reference/griffe/enumerations/#griffe.enumerations.ObjectKind.PROPERTY","title":"PROPERTY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PROPERTY: str = 'property'\n</code></pre> <p>Properties.</p>"},{"location":"reference/griffe/enumerations/#griffe.enumerations.ObjectKind.STATICMETHOD","title":"STATICMETHOD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STATICMETHOD: str = 'staticmethod'\n</code></pre> <p>Static methods.</p>"},{"location":"reference/griffe/enumerations/#griffe.enumerations.ParameterKind","title":"ParameterKind","text":"<p>             Bases: <code>Enum</code></p> <p>Enumeration of the different parameter kinds.</p> <p>Attributes:</p> <ul> <li> positional_only             (<code>str</code>)         \u2013          <p>Positional-only parameter.</p> </li> <li> positional_or_keyword             (<code>str</code>)         \u2013          <p>Positional or keyword parameter.</p> </li> <li> var_positional             (<code>str</code>)         \u2013          <p>Variadic positional parameter.</p> </li> <li> keyword_only             (<code>str</code>)         \u2013          <p>Keyword-only parameter.</p> </li> <li> var_keyword             (<code>str</code>)         \u2013          <p>Variadic keyword parameter.</p> </li> </ul>"},{"location":"reference/griffe/enumerations/#griffe.enumerations.Parser","title":"Parser","text":"<p>             Bases: <code>Enum</code></p> <p>Enumeration for the different docstring parsers.</p>"},{"location":"reference/griffe/enumerations/#griffe.enumerations.When","title":"When","text":"<p>             Bases: <code>Enum</code></p> <p>This enumeration contains the different times at which an extension is used.</p> <p>Attributes:</p> <ul> <li> before_all             (<code>int</code>)         \u2013          <p>For each node, before the visit/inspection.</p> </li> <li> before_children             (<code>int</code>)         \u2013          <p>For each node, after the visit has started, and before the children visit/inspection.</p> </li> <li> after_children             (<code>int</code>)         \u2013          <p>For each node, after the children have been visited/inspected, and before finishing the visit/inspection.</p> </li> <li> after_all             (<code>int</code>)         \u2013          <p>For each node, after the visit/inspection.</p> </li> </ul>"},{"location":"reference/griffe/exceptions/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> exceptions","text":""},{"location":"reference/griffe/exceptions/#griffe.exceptions","title":"exceptions","text":"<p>This module contains all the exceptions specific to Griffe.</p> <p>Classes:</p> <ul> <li> AliasResolutionError         \u2013          <p>Exception for alias that cannot be resolved.</p> </li> <li> BuiltinModuleError         \u2013          <p>Exception raised when trying to access the filepath of a builtin module.</p> </li> <li> CyclicAliasError         \u2013          <p>Exception raised when a cycle is detected in aliases.</p> </li> <li> ExtensionError         \u2013          <p>Base class for errors raised by extensions.</p> </li> <li> ExtensionNotLoadedError         \u2013          <p>Exception raised when an extension could not be loaded.</p> </li> <li> GitError         \u2013          <p>Exception raised for errors related to Git.</p> </li> <li> GriffeError         \u2013          <p>The base exception for all Griffe errors.</p> </li> <li> LastNodeError         \u2013          <p>Exception raised when trying to access a next or previous node.</p> </li> <li> LoadingError         \u2013          <p>The base exception for all Griffe errors.</p> </li> <li> NameResolutionError         \u2013          <p>Exception for names that cannot be resolved in a object scope.</p> </li> <li> RootNodeError         \u2013          <p>Exception raised when trying to use siblings properties on a root node.</p> </li> <li> UnhandledEditableModuleError         \u2013          <p>Exception for unhandled editables modules, when searching modules.</p> </li> <li> UnimportableModuleError         \u2013          <p>Exception for modules that cannot be imported.</p> </li> </ul>"},{"location":"reference/griffe/exceptions/#griffe.exceptions.AliasResolutionError","title":"AliasResolutionError","text":"<pre><code>AliasResolutionError(alias: Alias)\n</code></pre> <p>             Bases: <code>GriffeError</code></p> <p>Exception for alias that cannot be resolved.</p> <p>Parameters:</p> <ul> <li> alias             (<code>Alias</code>)         \u2013          <p>The alias that could not be resolved.</p> </li> </ul> <p>Methods:</p> <ul> </ul> Source code in <code>src/griffe/exceptions.py</code> <pre><code>def __init__(self, alias: Alias) -&gt; None:\n\"\"\"Initialize the exception.\n\n    Parameters:\n        alias: The alias that could not be resolved.\n    \"\"\"\n    self.alias: Alias = alias\n    message = f\"Could not resolve alias {alias.path} pointing at {alias.target_path}\"\n    try:\n        filepath = alias.parent.relative_filepath  # type: ignore[union-attr]\n    except BuiltinModuleError:\n        pass\n    else:\n        message += f\" (in {filepath}:{alias.alias_lineno})\"\n    super().__init__(message)\n</code></pre>"},{"location":"reference/griffe/exceptions/#griffe.exceptions.BuiltinModuleError","title":"BuiltinModuleError","text":"<p>             Bases: <code>GriffeError</code></p> <p>Exception raised when trying to access the filepath of a builtin module.</p>"},{"location":"reference/griffe/exceptions/#griffe.exceptions.CyclicAliasError","title":"CyclicAliasError","text":"<pre><code>CyclicAliasError(chain: list[str])\n</code></pre> <p>             Bases: <code>GriffeError</code></p> <p>Exception raised when a cycle is detected in aliases.</p> <p>Parameters:</p> <ul> <li> chain             (<code>list[str]</code>)         \u2013          <p>The cyclic chain of items (such as target path).</p> </li> </ul> <p>Methods:</p> <ul> </ul> Source code in <code>src/griffe/exceptions.py</code> <pre><code>def __init__(self, chain: list[str]) -&gt; None:\n\"\"\"Initialize the exception.\n\n    Parameters:\n        chain: The cyclic chain of items (such as target path).\n    \"\"\"\n    self.chain: list[str] = chain\n    super().__init__(\"Cyclic aliases detected:\\n  \" + \"\\n  \".join(self.chain))\n</code></pre>"},{"location":"reference/griffe/exceptions/#griffe.exceptions.ExtensionError","title":"ExtensionError","text":"<p>             Bases: <code>GriffeError</code></p> <p>Base class for errors raised by extensions.</p>"},{"location":"reference/griffe/exceptions/#griffe.exceptions.ExtensionNotLoadedError","title":"ExtensionNotLoadedError","text":"<p>             Bases: <code>ExtensionError</code></p> <p>Exception raised when an extension could not be loaded.</p>"},{"location":"reference/griffe/exceptions/#griffe.exceptions.GitError","title":"GitError","text":"<p>             Bases: <code>GriffeError</code></p> <p>Exception raised for errors related to Git.</p>"},{"location":"reference/griffe/exceptions/#griffe.exceptions.GriffeError","title":"GriffeError","text":"<p>             Bases: <code>Exception</code></p> <p>The base exception for all Griffe errors.</p>"},{"location":"reference/griffe/exceptions/#griffe.exceptions.LastNodeError","title":"LastNodeError","text":"<p>             Bases: <code>GriffeError</code></p> <p>Exception raised when trying to access a next or previous node.</p>"},{"location":"reference/griffe/exceptions/#griffe.exceptions.LoadingError","title":"LoadingError","text":"<p>             Bases: <code>GriffeError</code></p> <p>The base exception for all Griffe errors.</p>"},{"location":"reference/griffe/exceptions/#griffe.exceptions.NameResolutionError","title":"NameResolutionError","text":"<p>             Bases: <code>GriffeError</code></p> <p>Exception for names that cannot be resolved in a object scope.</p>"},{"location":"reference/griffe/exceptions/#griffe.exceptions.RootNodeError","title":"RootNodeError","text":"<p>             Bases: <code>GriffeError</code></p> <p>Exception raised when trying to use siblings properties on a root node.</p>"},{"location":"reference/griffe/exceptions/#griffe.exceptions.UnhandledEditableModuleError","title":"UnhandledEditableModuleError","text":"<p>             Bases: <code>GriffeError</code></p> <p>Exception for unhandled editables modules, when searching modules.</p>"},{"location":"reference/griffe/exceptions/#griffe.exceptions.UnimportableModuleError","title":"UnimportableModuleError","text":"<p>             Bases: <code>GriffeError</code></p> <p>Exception for modules that cannot be imported.</p>"},{"location":"reference/griffe/expressions/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> expressions","text":""},{"location":"reference/griffe/expressions/#griffe.expressions","title":"expressions","text":"<p>This module contains the data classes that represent resolvable names and expressions.</p> <p>Classes:</p> <ul> <li> Expr         \u2013          <p>Base class for expressions.</p> </li> <li> ExprAttribute         \u2013          <p>Attributes like <code>a.b</code>.</p> </li> <li> ExprBinOp         \u2013          <p>Binary operations like <code>a + b</code>.</p> </li> <li> ExprBoolOp         \u2013          <p>Boolean operations like <code>a or b</code>.</p> </li> <li> ExprCall         \u2013          <p>Calls like <code>f()</code>.</p> </li> <li> ExprCompare         \u2013          <p>Comparisons like <code>a &gt; b</code>.</p> </li> <li> ExprComprehension         \u2013          <p>Comprehensions like <code>a for b in c if d</code>.</p> </li> <li> ExprConstant         \u2013          <p>Constants like <code>\"a\"</code> or <code>1</code>.</p> </li> <li> ExprDict         \u2013          <p>Dictionaries like <code>{\"a\": 0}</code>.</p> </li> <li> ExprDictComp         \u2013          <p>Dict comprehensions like <code>{k: v for k, v in a}</code>.</p> </li> <li> ExprExtSlice         \u2013          <p>Extended slice like <code>a[x:y, z]</code>.</p> </li> <li> ExprFormatted         \u2013          <p>Formatted string like <code>{1 + 1}</code>.</p> </li> <li> ExprGeneratorExp         \u2013          <p>Generator expressions like <code>a for b in c for d in e</code>.</p> </li> <li> ExprIfExp         \u2013          <p>Conditions like <code>a if b else c</code>.</p> </li> <li> ExprJoinedStr         \u2013          <p>Joined strings like <code>f\"a {b} c\"</code>.</p> </li> <li> ExprKeyword         \u2013          <p>Keyword arguments like <code>a=b</code>.</p> </li> <li> ExprLambda         \u2013          <p>Lambda expressions like <code>lambda a: a.b</code>.</p> </li> <li> ExprList         \u2013          <p>Lists like <code>[0, 1, 2]</code>.</p> </li> <li> ExprListComp         \u2013          <p>List comprehensions like <code>[a for b in c]</code>.</p> </li> <li> ExprName         \u2013          <p>This class represents a Python object identified by a name in a given scope.</p> </li> <li> ExprNamedExpr         \u2013          <p>Named/assignment expressions like <code>a := b</code>.</p> </li> <li> ExprParameter         \u2013          <p>Parameters in function signatures like <code>a: int = 0</code>.</p> </li> <li> ExprSet         \u2013          <p>Sets like <code>{0, 1, 2}</code>.</p> </li> <li> ExprSetComp         \u2013          <p>Set comprehensions like <code>{a for b in c}</code>.</p> </li> <li> ExprSlice         \u2013          <p>Slices like <code>[a:b:c]</code>.</p> </li> <li> ExprSubscript         \u2013          <p>Subscripts like <code>a[b]</code>.</p> </li> <li> ExprTuple         \u2013          <p>Tuples like <code>(0, 1, 2)</code>.</p> </li> <li> ExprUnaryOp         \u2013          <p>Unary operations like <code>-1</code>.</p> </li> <li> ExprVarKeyword         \u2013          <p>Variadic keyword parameters like <code>**kwargs</code>.</p> </li> <li> ExprVarPositional         \u2013          <p>Variadic positional parameters like <code>*args</code>.</p> </li> <li> ExprYield         \u2013          <p>Yield statements like <code>yield a</code>.</p> </li> </ul> <p>Functions:</p> <ul> <li> get_expression           \u2013            <p>Build an expression from an AST.</p> </li> <li> safe_get_expression           \u2013            <p>Safely (no exception) build a resolvable annotation.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.Expr","title":"Expr  <code>dataclass</code>","text":"<p>Base class for expressions.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return the expression as a dictionary.</p> </li> <li> iterate           \u2013            <p>Iterate on the expression elements.</p> </li> </ul> <p>Attributes:</p> <ul> <li> canonical_name             (<code>str</code>)         \u2013          <p>Name of the expressed name/attribute.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> <li> classname             (<code>str</code>)         \u2013          <p>The expression class name.</p> </li> <li> is_classvar             (<code>bool</code>)         \u2013          <p>Whether this attribute is annotated with <code>ClassVar</code>.</p> </li> <li> is_generator             (<code>bool</code>)         \u2013          <p>Whether this expression is a generator.</p> </li> <li> is_iterator             (<code>bool</code>)         \u2013          <p>Whether this expression is an iterator.</p> </li> <li> is_tuple             (<code>bool</code>)         \u2013          <p>Whether this expression is a tuple.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.Expr.canonical_name","title":"canonical_name  <code>property</code>","text":"<pre><code>canonical_name: str\n</code></pre> <p>Name of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.Expr.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.Expr.classname","title":"classname  <code>property</code>","text":"<pre><code>classname: str\n</code></pre> <p>The expression class name.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.Expr.is_classvar","title":"is_classvar  <code>property</code>","text":"<pre><code>is_classvar: bool\n</code></pre> <p>Whether this attribute is annotated with <code>ClassVar</code>.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.Expr.is_generator","title":"is_generator  <code>property</code>","text":"<pre><code>is_generator: bool\n</code></pre> <p>Whether this expression is a generator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.Expr.is_iterator","title":"is_iterator  <code>property</code>","text":"<pre><code>is_iterator: bool\n</code></pre> <p>Whether this expression is an iterator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.Expr.is_tuple","title":"is_tuple  <code>property</code>","text":"<pre><code>is_tuple: bool\n</code></pre> <p>Whether this expression is a tuple.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.Expr.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.Expr.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return the expression as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Configuration options (none available yet).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return the expression as a dictionary.\n\n    Parameters:\n        **kwargs: Configuration options (none available yet).\n\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return _expr_as_dict(self, **kwargs)\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.Expr.iterate","title":"iterate","text":"<pre><code>iterate(*, flat: bool = True) -&gt; Iterator[str | Expr]\n</code></pre> <p>Iterate on the expression elements.</p> <p>Parameters:</p> <ul> <li> flat             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Expressions are trees.</p> <p>When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings.</p> <p>On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>str | Expr</code>         \u2013          <p>Strings and names when flat, strings and expressions otherwise.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def iterate(self, *, flat: bool = True) -&gt; Iterator[str | Expr]:  # noqa: ARG002\n\"\"\"Iterate on the expression elements.\n\n    Parameters:\n        flat: Expressions are trees.\n\n            When flat is false, this method iterates only on the first layer of the tree.\n            To iterate on all the subparts of the expression, you have to do so recursively.\n            It allows to handle each subpart specifically (for example subscripts, attribute, etc.),\n            without them getting rendered as strings.\n\n            On the contrary, when flat is true, the whole tree is flattened as a sequence\n            of strings and instances of [Names][griffe.expressions.ExprName].\n\n    Yields:\n        Strings and names when flat, strings and expressions otherwise.\n    \"\"\"\n    yield from ()\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprAttribute","title":"ExprAttribute  <code>dataclass</code>","text":"<p>             Bases: <code>Expr</code></p> <p>Attributes like <code>a.b</code>.</p> <p>Methods:</p> <ul> <li> append           \u2013            <p>Append a name to this attribute.</p> </li> <li> as_dict           \u2013            <p>Return the expression as a dictionary.</p> </li> </ul> <p>Attributes:</p> <ul> <li> canonical_name             (<code>str</code>)         \u2013          <p>Name of the expressed name/attribute.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>The canonical path of this attribute.</p> </li> <li> classname             (<code>str</code>)         \u2013          <p>The expression class name.</p> </li> <li> first             (<code>str | Expr</code>)         \u2013          <p>The first part of this attribute (on the left).</p> </li> <li> is_classvar             (<code>bool</code>)         \u2013          <p>Whether this attribute is annotated with <code>ClassVar</code>.</p> </li> <li> is_generator             (<code>bool</code>)         \u2013          <p>Whether this expression is a generator.</p> </li> <li> is_iterator             (<code>bool</code>)         \u2013          <p>Whether this expression is an iterator.</p> </li> <li> is_tuple             (<code>bool</code>)         \u2013          <p>Whether this expression is a tuple.</p> </li> <li> last             (<code>ExprName</code>)         \u2013          <p>The last part of this attribute (on the right).</p> </li> <li> path             (<code>str</code>)         \u2013          <p>The path of this attribute.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprAttribute.canonical_name","title":"canonical_name  <code>property</code>","text":"<pre><code>canonical_name: str\n</code></pre> <p>Name of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprAttribute.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>The canonical path of this attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprAttribute.classname","title":"classname  <code>property</code>","text":"<pre><code>classname: str\n</code></pre> <p>The expression class name.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprAttribute.first","title":"first  <code>property</code>","text":"<pre><code>first: str | Expr\n</code></pre> <p>The first part of this attribute (on the left).</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprAttribute.is_classvar","title":"is_classvar  <code>property</code>","text":"<pre><code>is_classvar: bool\n</code></pre> <p>Whether this attribute is annotated with <code>ClassVar</code>.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprAttribute.is_generator","title":"is_generator  <code>property</code>","text":"<pre><code>is_generator: bool\n</code></pre> <p>Whether this expression is a generator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprAttribute.is_iterator","title":"is_iterator  <code>property</code>","text":"<pre><code>is_iterator: bool\n</code></pre> <p>Whether this expression is an iterator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprAttribute.is_tuple","title":"is_tuple  <code>property</code>","text":"<pre><code>is_tuple: bool\n</code></pre> <p>Whether this expression is a tuple.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprAttribute.last","title":"last  <code>property</code>","text":"<pre><code>last: ExprName\n</code></pre> <p>The last part of this attribute (on the right).</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprAttribute.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>The path of this attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprAttribute.append","title":"append","text":"<pre><code>append(value: ExprName) -&gt; None\n</code></pre> <p>Append a name to this attribute.</p> <p>Parameters:</p> <ul> <li> value             (<code>ExprName</code>)         \u2013          <p>The expression name to append.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def append(self, value: ExprName) -&gt; None:\n\"\"\"Append a name to this attribute.\n\n    Parameters:\n        value: The expression name to append.\n    \"\"\"\n    if value.parent is None:\n        value.parent = self.last\n    self.values.append(value)\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprAttribute.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return the expression as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Configuration options (none available yet).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return the expression as a dictionary.\n\n    Parameters:\n        **kwargs: Configuration options (none available yet).\n\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return _expr_as_dict(self, **kwargs)\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprBinOp","title":"ExprBinOp  <code>dataclass</code>","text":"<p>             Bases: <code>Expr</code></p> <p>Binary operations like <code>a + b</code>.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return the expression as a dictionary.</p> </li> </ul> <p>Attributes:</p> <ul> <li> canonical_name             (<code>str</code>)         \u2013          <p>Name of the expressed name/attribute.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> <li> classname             (<code>str</code>)         \u2013          <p>The expression class name.</p> </li> <li> is_classvar             (<code>bool</code>)         \u2013          <p>Whether this attribute is annotated with <code>ClassVar</code>.</p> </li> <li> is_generator             (<code>bool</code>)         \u2013          <p>Whether this expression is a generator.</p> </li> <li> is_iterator             (<code>bool</code>)         \u2013          <p>Whether this expression is an iterator.</p> </li> <li> is_tuple             (<code>bool</code>)         \u2013          <p>Whether this expression is a tuple.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprBinOp.canonical_name","title":"canonical_name  <code>property</code>","text":"<pre><code>canonical_name: str\n</code></pre> <p>Name of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprBinOp.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprBinOp.classname","title":"classname  <code>property</code>","text":"<pre><code>classname: str\n</code></pre> <p>The expression class name.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprBinOp.is_classvar","title":"is_classvar  <code>property</code>","text":"<pre><code>is_classvar: bool\n</code></pre> <p>Whether this attribute is annotated with <code>ClassVar</code>.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprBinOp.is_generator","title":"is_generator  <code>property</code>","text":"<pre><code>is_generator: bool\n</code></pre> <p>Whether this expression is a generator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprBinOp.is_iterator","title":"is_iterator  <code>property</code>","text":"<pre><code>is_iterator: bool\n</code></pre> <p>Whether this expression is an iterator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprBinOp.is_tuple","title":"is_tuple  <code>property</code>","text":"<pre><code>is_tuple: bool\n</code></pre> <p>Whether this expression is a tuple.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprBinOp.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprBinOp.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return the expression as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Configuration options (none available yet).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return the expression as a dictionary.\n\n    Parameters:\n        **kwargs: Configuration options (none available yet).\n\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return _expr_as_dict(self, **kwargs)\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprBoolOp","title":"ExprBoolOp  <code>dataclass</code>","text":"<p>             Bases: <code>Expr</code></p> <p>Boolean operations like <code>a or b</code>.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return the expression as a dictionary.</p> </li> </ul> <p>Attributes:</p> <ul> <li> canonical_name             (<code>str</code>)         \u2013          <p>Name of the expressed name/attribute.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> <li> classname             (<code>str</code>)         \u2013          <p>The expression class name.</p> </li> <li> is_classvar             (<code>bool</code>)         \u2013          <p>Whether this attribute is annotated with <code>ClassVar</code>.</p> </li> <li> is_generator             (<code>bool</code>)         \u2013          <p>Whether this expression is a generator.</p> </li> <li> is_iterator             (<code>bool</code>)         \u2013          <p>Whether this expression is an iterator.</p> </li> <li> is_tuple             (<code>bool</code>)         \u2013          <p>Whether this expression is a tuple.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprBoolOp.canonical_name","title":"canonical_name  <code>property</code>","text":"<pre><code>canonical_name: str\n</code></pre> <p>Name of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprBoolOp.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprBoolOp.classname","title":"classname  <code>property</code>","text":"<pre><code>classname: str\n</code></pre> <p>The expression class name.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprBoolOp.is_classvar","title":"is_classvar  <code>property</code>","text":"<pre><code>is_classvar: bool\n</code></pre> <p>Whether this attribute is annotated with <code>ClassVar</code>.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprBoolOp.is_generator","title":"is_generator  <code>property</code>","text":"<pre><code>is_generator: bool\n</code></pre> <p>Whether this expression is a generator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprBoolOp.is_iterator","title":"is_iterator  <code>property</code>","text":"<pre><code>is_iterator: bool\n</code></pre> <p>Whether this expression is an iterator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprBoolOp.is_tuple","title":"is_tuple  <code>property</code>","text":"<pre><code>is_tuple: bool\n</code></pre> <p>Whether this expression is a tuple.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprBoolOp.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprBoolOp.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return the expression as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Configuration options (none available yet).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return the expression as a dictionary.\n\n    Parameters:\n        **kwargs: Configuration options (none available yet).\n\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return _expr_as_dict(self, **kwargs)\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprCall","title":"ExprCall  <code>dataclass</code>","text":"<p>             Bases: <code>Expr</code></p> <p>Calls like <code>f()</code>.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return the expression as a dictionary.</p> </li> </ul> <p>Attributes:</p> <ul> <li> canonical_name             (<code>str</code>)         \u2013          <p>Name of the expressed name/attribute.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> <li> classname             (<code>str</code>)         \u2013          <p>The expression class name.</p> </li> <li> is_classvar             (<code>bool</code>)         \u2013          <p>Whether this attribute is annotated with <code>ClassVar</code>.</p> </li> <li> is_generator             (<code>bool</code>)         \u2013          <p>Whether this expression is a generator.</p> </li> <li> is_iterator             (<code>bool</code>)         \u2013          <p>Whether this expression is an iterator.</p> </li> <li> is_tuple             (<code>bool</code>)         \u2013          <p>Whether this expression is a tuple.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprCall.canonical_name","title":"canonical_name  <code>property</code>","text":"<pre><code>canonical_name: str\n</code></pre> <p>Name of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprCall.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprCall.classname","title":"classname  <code>property</code>","text":"<pre><code>classname: str\n</code></pre> <p>The expression class name.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprCall.is_classvar","title":"is_classvar  <code>property</code>","text":"<pre><code>is_classvar: bool\n</code></pre> <p>Whether this attribute is annotated with <code>ClassVar</code>.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprCall.is_generator","title":"is_generator  <code>property</code>","text":"<pre><code>is_generator: bool\n</code></pre> <p>Whether this expression is a generator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprCall.is_iterator","title":"is_iterator  <code>property</code>","text":"<pre><code>is_iterator: bool\n</code></pre> <p>Whether this expression is an iterator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprCall.is_tuple","title":"is_tuple  <code>property</code>","text":"<pre><code>is_tuple: bool\n</code></pre> <p>Whether this expression is a tuple.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprCall.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprCall.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return the expression as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Configuration options (none available yet).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return the expression as a dictionary.\n\n    Parameters:\n        **kwargs: Configuration options (none available yet).\n\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return _expr_as_dict(self, **kwargs)\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprCompare","title":"ExprCompare  <code>dataclass</code>","text":"<p>             Bases: <code>Expr</code></p> <p>Comparisons like <code>a &gt; b</code>.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return the expression as a dictionary.</p> </li> </ul> <p>Attributes:</p> <ul> <li> canonical_name             (<code>str</code>)         \u2013          <p>Name of the expressed name/attribute.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> <li> classname             (<code>str</code>)         \u2013          <p>The expression class name.</p> </li> <li> is_classvar             (<code>bool</code>)         \u2013          <p>Whether this attribute is annotated with <code>ClassVar</code>.</p> </li> <li> is_generator             (<code>bool</code>)         \u2013          <p>Whether this expression is a generator.</p> </li> <li> is_iterator             (<code>bool</code>)         \u2013          <p>Whether this expression is an iterator.</p> </li> <li> is_tuple             (<code>bool</code>)         \u2013          <p>Whether this expression is a tuple.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprCompare.canonical_name","title":"canonical_name  <code>property</code>","text":"<pre><code>canonical_name: str\n</code></pre> <p>Name of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprCompare.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprCompare.classname","title":"classname  <code>property</code>","text":"<pre><code>classname: str\n</code></pre> <p>The expression class name.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprCompare.is_classvar","title":"is_classvar  <code>property</code>","text":"<pre><code>is_classvar: bool\n</code></pre> <p>Whether this attribute is annotated with <code>ClassVar</code>.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprCompare.is_generator","title":"is_generator  <code>property</code>","text":"<pre><code>is_generator: bool\n</code></pre> <p>Whether this expression is a generator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprCompare.is_iterator","title":"is_iterator  <code>property</code>","text":"<pre><code>is_iterator: bool\n</code></pre> <p>Whether this expression is an iterator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprCompare.is_tuple","title":"is_tuple  <code>property</code>","text":"<pre><code>is_tuple: bool\n</code></pre> <p>Whether this expression is a tuple.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprCompare.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprCompare.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return the expression as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Configuration options (none available yet).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return the expression as a dictionary.\n\n    Parameters:\n        **kwargs: Configuration options (none available yet).\n\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return _expr_as_dict(self, **kwargs)\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprComprehension","title":"ExprComprehension  <code>dataclass</code>","text":"<p>             Bases: <code>Expr</code></p> <p>Comprehensions like <code>a for b in c if d</code>.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return the expression as a dictionary.</p> </li> </ul> <p>Attributes:</p> <ul> <li> canonical_name             (<code>str</code>)         \u2013          <p>Name of the expressed name/attribute.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> <li> classname             (<code>str</code>)         \u2013          <p>The expression class name.</p> </li> <li> is_classvar             (<code>bool</code>)         \u2013          <p>Whether this attribute is annotated with <code>ClassVar</code>.</p> </li> <li> is_generator             (<code>bool</code>)         \u2013          <p>Whether this expression is a generator.</p> </li> <li> is_iterator             (<code>bool</code>)         \u2013          <p>Whether this expression is an iterator.</p> </li> <li> is_tuple             (<code>bool</code>)         \u2013          <p>Whether this expression is a tuple.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprComprehension.canonical_name","title":"canonical_name  <code>property</code>","text":"<pre><code>canonical_name: str\n</code></pre> <p>Name of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprComprehension.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprComprehension.classname","title":"classname  <code>property</code>","text":"<pre><code>classname: str\n</code></pre> <p>The expression class name.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprComprehension.is_classvar","title":"is_classvar  <code>property</code>","text":"<pre><code>is_classvar: bool\n</code></pre> <p>Whether this attribute is annotated with <code>ClassVar</code>.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprComprehension.is_generator","title":"is_generator  <code>property</code>","text":"<pre><code>is_generator: bool\n</code></pre> <p>Whether this expression is a generator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprComprehension.is_iterator","title":"is_iterator  <code>property</code>","text":"<pre><code>is_iterator: bool\n</code></pre> <p>Whether this expression is an iterator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprComprehension.is_tuple","title":"is_tuple  <code>property</code>","text":"<pre><code>is_tuple: bool\n</code></pre> <p>Whether this expression is a tuple.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprComprehension.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprComprehension.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return the expression as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Configuration options (none available yet).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return the expression as a dictionary.\n\n    Parameters:\n        **kwargs: Configuration options (none available yet).\n\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return _expr_as_dict(self, **kwargs)\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprConstant","title":"ExprConstant  <code>dataclass</code>","text":"<p>             Bases: <code>Expr</code></p> <p>Constants like <code>\"a\"</code> or <code>1</code>.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return the expression as a dictionary.</p> </li> </ul> <p>Attributes:</p> <ul> <li> canonical_name             (<code>str</code>)         \u2013          <p>Name of the expressed name/attribute.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> <li> classname             (<code>str</code>)         \u2013          <p>The expression class name.</p> </li> <li> is_classvar             (<code>bool</code>)         \u2013          <p>Whether this attribute is annotated with <code>ClassVar</code>.</p> </li> <li> is_generator             (<code>bool</code>)         \u2013          <p>Whether this expression is a generator.</p> </li> <li> is_iterator             (<code>bool</code>)         \u2013          <p>Whether this expression is an iterator.</p> </li> <li> is_tuple             (<code>bool</code>)         \u2013          <p>Whether this expression is a tuple.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprConstant.canonical_name","title":"canonical_name  <code>property</code>","text":"<pre><code>canonical_name: str\n</code></pre> <p>Name of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprConstant.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprConstant.classname","title":"classname  <code>property</code>","text":"<pre><code>classname: str\n</code></pre> <p>The expression class name.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprConstant.is_classvar","title":"is_classvar  <code>property</code>","text":"<pre><code>is_classvar: bool\n</code></pre> <p>Whether this attribute is annotated with <code>ClassVar</code>.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprConstant.is_generator","title":"is_generator  <code>property</code>","text":"<pre><code>is_generator: bool\n</code></pre> <p>Whether this expression is a generator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprConstant.is_iterator","title":"is_iterator  <code>property</code>","text":"<pre><code>is_iterator: bool\n</code></pre> <p>Whether this expression is an iterator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprConstant.is_tuple","title":"is_tuple  <code>property</code>","text":"<pre><code>is_tuple: bool\n</code></pre> <p>Whether this expression is a tuple.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprConstant.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprConstant.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return the expression as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Configuration options (none available yet).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return the expression as a dictionary.\n\n    Parameters:\n        **kwargs: Configuration options (none available yet).\n\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return _expr_as_dict(self, **kwargs)\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprDict","title":"ExprDict  <code>dataclass</code>","text":"<p>             Bases: <code>Expr</code></p> <p>Dictionaries like <code>{\"a\": 0}</code>.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return the expression as a dictionary.</p> </li> </ul> <p>Attributes:</p> <ul> <li> canonical_name             (<code>str</code>)         \u2013          <p>Name of the expressed name/attribute.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> <li> classname             (<code>str</code>)         \u2013          <p>The expression class name.</p> </li> <li> is_classvar             (<code>bool</code>)         \u2013          <p>Whether this attribute is annotated with <code>ClassVar</code>.</p> </li> <li> is_generator             (<code>bool</code>)         \u2013          <p>Whether this expression is a generator.</p> </li> <li> is_iterator             (<code>bool</code>)         \u2013          <p>Whether this expression is an iterator.</p> </li> <li> is_tuple             (<code>bool</code>)         \u2013          <p>Whether this expression is a tuple.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprDict.canonical_name","title":"canonical_name  <code>property</code>","text":"<pre><code>canonical_name: str\n</code></pre> <p>Name of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprDict.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprDict.classname","title":"classname  <code>property</code>","text":"<pre><code>classname: str\n</code></pre> <p>The expression class name.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprDict.is_classvar","title":"is_classvar  <code>property</code>","text":"<pre><code>is_classvar: bool\n</code></pre> <p>Whether this attribute is annotated with <code>ClassVar</code>.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprDict.is_generator","title":"is_generator  <code>property</code>","text":"<pre><code>is_generator: bool\n</code></pre> <p>Whether this expression is a generator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprDict.is_iterator","title":"is_iterator  <code>property</code>","text":"<pre><code>is_iterator: bool\n</code></pre> <p>Whether this expression is an iterator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprDict.is_tuple","title":"is_tuple  <code>property</code>","text":"<pre><code>is_tuple: bool\n</code></pre> <p>Whether this expression is a tuple.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprDict.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprDict.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return the expression as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Configuration options (none available yet).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return the expression as a dictionary.\n\n    Parameters:\n        **kwargs: Configuration options (none available yet).\n\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return _expr_as_dict(self, **kwargs)\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprDictComp","title":"ExprDictComp  <code>dataclass</code>","text":"<p>             Bases: <code>Expr</code></p> <p>Dict comprehensions like <code>{k: v for k, v in a}</code>.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return the expression as a dictionary.</p> </li> </ul> <p>Attributes:</p> <ul> <li> canonical_name             (<code>str</code>)         \u2013          <p>Name of the expressed name/attribute.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> <li> classname             (<code>str</code>)         \u2013          <p>The expression class name.</p> </li> <li> is_classvar             (<code>bool</code>)         \u2013          <p>Whether this attribute is annotated with <code>ClassVar</code>.</p> </li> <li> is_generator             (<code>bool</code>)         \u2013          <p>Whether this expression is a generator.</p> </li> <li> is_iterator             (<code>bool</code>)         \u2013          <p>Whether this expression is an iterator.</p> </li> <li> is_tuple             (<code>bool</code>)         \u2013          <p>Whether this expression is a tuple.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprDictComp.canonical_name","title":"canonical_name  <code>property</code>","text":"<pre><code>canonical_name: str\n</code></pre> <p>Name of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprDictComp.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprDictComp.classname","title":"classname  <code>property</code>","text":"<pre><code>classname: str\n</code></pre> <p>The expression class name.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprDictComp.is_classvar","title":"is_classvar  <code>property</code>","text":"<pre><code>is_classvar: bool\n</code></pre> <p>Whether this attribute is annotated with <code>ClassVar</code>.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprDictComp.is_generator","title":"is_generator  <code>property</code>","text":"<pre><code>is_generator: bool\n</code></pre> <p>Whether this expression is a generator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprDictComp.is_iterator","title":"is_iterator  <code>property</code>","text":"<pre><code>is_iterator: bool\n</code></pre> <p>Whether this expression is an iterator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprDictComp.is_tuple","title":"is_tuple  <code>property</code>","text":"<pre><code>is_tuple: bool\n</code></pre> <p>Whether this expression is a tuple.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprDictComp.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprDictComp.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return the expression as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Configuration options (none available yet).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return the expression as a dictionary.\n\n    Parameters:\n        **kwargs: Configuration options (none available yet).\n\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return _expr_as_dict(self, **kwargs)\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprExtSlice","title":"ExprExtSlice  <code>dataclass</code>","text":"<p>             Bases: <code>Expr</code></p> <p>Extended slice like <code>a[x:y, z]</code>.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return the expression as a dictionary.</p> </li> </ul> <p>Attributes:</p> <ul> <li> canonical_name             (<code>str</code>)         \u2013          <p>Name of the expressed name/attribute.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> <li> classname             (<code>str</code>)         \u2013          <p>The expression class name.</p> </li> <li> is_classvar             (<code>bool</code>)         \u2013          <p>Whether this attribute is annotated with <code>ClassVar</code>.</p> </li> <li> is_generator             (<code>bool</code>)         \u2013          <p>Whether this expression is a generator.</p> </li> <li> is_iterator             (<code>bool</code>)         \u2013          <p>Whether this expression is an iterator.</p> </li> <li> is_tuple             (<code>bool</code>)         \u2013          <p>Whether this expression is a tuple.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprExtSlice.canonical_name","title":"canonical_name  <code>property</code>","text":"<pre><code>canonical_name: str\n</code></pre> <p>Name of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprExtSlice.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprExtSlice.classname","title":"classname  <code>property</code>","text":"<pre><code>classname: str\n</code></pre> <p>The expression class name.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprExtSlice.is_classvar","title":"is_classvar  <code>property</code>","text":"<pre><code>is_classvar: bool\n</code></pre> <p>Whether this attribute is annotated with <code>ClassVar</code>.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprExtSlice.is_generator","title":"is_generator  <code>property</code>","text":"<pre><code>is_generator: bool\n</code></pre> <p>Whether this expression is a generator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprExtSlice.is_iterator","title":"is_iterator  <code>property</code>","text":"<pre><code>is_iterator: bool\n</code></pre> <p>Whether this expression is an iterator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprExtSlice.is_tuple","title":"is_tuple  <code>property</code>","text":"<pre><code>is_tuple: bool\n</code></pre> <p>Whether this expression is a tuple.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprExtSlice.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprExtSlice.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return the expression as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Configuration options (none available yet).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return the expression as a dictionary.\n\n    Parameters:\n        **kwargs: Configuration options (none available yet).\n\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return _expr_as_dict(self, **kwargs)\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprFormatted","title":"ExprFormatted  <code>dataclass</code>","text":"<p>             Bases: <code>Expr</code></p> <p>Formatted string like <code>{1 + 1}</code>.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return the expression as a dictionary.</p> </li> </ul> <p>Attributes:</p> <ul> <li> canonical_name             (<code>str</code>)         \u2013          <p>Name of the expressed name/attribute.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> <li> classname             (<code>str</code>)         \u2013          <p>The expression class name.</p> </li> <li> is_classvar             (<code>bool</code>)         \u2013          <p>Whether this attribute is annotated with <code>ClassVar</code>.</p> </li> <li> is_generator             (<code>bool</code>)         \u2013          <p>Whether this expression is a generator.</p> </li> <li> is_iterator             (<code>bool</code>)         \u2013          <p>Whether this expression is an iterator.</p> </li> <li> is_tuple             (<code>bool</code>)         \u2013          <p>Whether this expression is a tuple.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprFormatted.canonical_name","title":"canonical_name  <code>property</code>","text":"<pre><code>canonical_name: str\n</code></pre> <p>Name of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprFormatted.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprFormatted.classname","title":"classname  <code>property</code>","text":"<pre><code>classname: str\n</code></pre> <p>The expression class name.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprFormatted.is_classvar","title":"is_classvar  <code>property</code>","text":"<pre><code>is_classvar: bool\n</code></pre> <p>Whether this attribute is annotated with <code>ClassVar</code>.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprFormatted.is_generator","title":"is_generator  <code>property</code>","text":"<pre><code>is_generator: bool\n</code></pre> <p>Whether this expression is a generator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprFormatted.is_iterator","title":"is_iterator  <code>property</code>","text":"<pre><code>is_iterator: bool\n</code></pre> <p>Whether this expression is an iterator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprFormatted.is_tuple","title":"is_tuple  <code>property</code>","text":"<pre><code>is_tuple: bool\n</code></pre> <p>Whether this expression is a tuple.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprFormatted.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprFormatted.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return the expression as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Configuration options (none available yet).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return the expression as a dictionary.\n\n    Parameters:\n        **kwargs: Configuration options (none available yet).\n\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return _expr_as_dict(self, **kwargs)\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprGeneratorExp","title":"ExprGeneratorExp  <code>dataclass</code>","text":"<p>             Bases: <code>Expr</code></p> <p>Generator expressions like <code>a for b in c for d in e</code>.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return the expression as a dictionary.</p> </li> </ul> <p>Attributes:</p> <ul> <li> canonical_name             (<code>str</code>)         \u2013          <p>Name of the expressed name/attribute.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> <li> classname             (<code>str</code>)         \u2013          <p>The expression class name.</p> </li> <li> is_classvar             (<code>bool</code>)         \u2013          <p>Whether this attribute is annotated with <code>ClassVar</code>.</p> </li> <li> is_generator             (<code>bool</code>)         \u2013          <p>Whether this expression is a generator.</p> </li> <li> is_iterator             (<code>bool</code>)         \u2013          <p>Whether this expression is an iterator.</p> </li> <li> is_tuple             (<code>bool</code>)         \u2013          <p>Whether this expression is a tuple.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprGeneratorExp.canonical_name","title":"canonical_name  <code>property</code>","text":"<pre><code>canonical_name: str\n</code></pre> <p>Name of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprGeneratorExp.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprGeneratorExp.classname","title":"classname  <code>property</code>","text":"<pre><code>classname: str\n</code></pre> <p>The expression class name.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprGeneratorExp.is_classvar","title":"is_classvar  <code>property</code>","text":"<pre><code>is_classvar: bool\n</code></pre> <p>Whether this attribute is annotated with <code>ClassVar</code>.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprGeneratorExp.is_generator","title":"is_generator  <code>property</code>","text":"<pre><code>is_generator: bool\n</code></pre> <p>Whether this expression is a generator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprGeneratorExp.is_iterator","title":"is_iterator  <code>property</code>","text":"<pre><code>is_iterator: bool\n</code></pre> <p>Whether this expression is an iterator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprGeneratorExp.is_tuple","title":"is_tuple  <code>property</code>","text":"<pre><code>is_tuple: bool\n</code></pre> <p>Whether this expression is a tuple.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprGeneratorExp.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprGeneratorExp.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return the expression as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Configuration options (none available yet).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return the expression as a dictionary.\n\n    Parameters:\n        **kwargs: Configuration options (none available yet).\n\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return _expr_as_dict(self, **kwargs)\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprIfExp","title":"ExprIfExp  <code>dataclass</code>","text":"<p>             Bases: <code>Expr</code></p> <p>Conditions like <code>a if b else c</code>.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return the expression as a dictionary.</p> </li> </ul> <p>Attributes:</p> <ul> <li> canonical_name             (<code>str</code>)         \u2013          <p>Name of the expressed name/attribute.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> <li> classname             (<code>str</code>)         \u2013          <p>The expression class name.</p> </li> <li> is_classvar             (<code>bool</code>)         \u2013          <p>Whether this attribute is annotated with <code>ClassVar</code>.</p> </li> <li> is_generator             (<code>bool</code>)         \u2013          <p>Whether this expression is a generator.</p> </li> <li> is_iterator             (<code>bool</code>)         \u2013          <p>Whether this expression is an iterator.</p> </li> <li> is_tuple             (<code>bool</code>)         \u2013          <p>Whether this expression is a tuple.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprIfExp.canonical_name","title":"canonical_name  <code>property</code>","text":"<pre><code>canonical_name: str\n</code></pre> <p>Name of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprIfExp.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprIfExp.classname","title":"classname  <code>property</code>","text":"<pre><code>classname: str\n</code></pre> <p>The expression class name.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprIfExp.is_classvar","title":"is_classvar  <code>property</code>","text":"<pre><code>is_classvar: bool\n</code></pre> <p>Whether this attribute is annotated with <code>ClassVar</code>.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprIfExp.is_generator","title":"is_generator  <code>property</code>","text":"<pre><code>is_generator: bool\n</code></pre> <p>Whether this expression is a generator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprIfExp.is_iterator","title":"is_iterator  <code>property</code>","text":"<pre><code>is_iterator: bool\n</code></pre> <p>Whether this expression is an iterator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprIfExp.is_tuple","title":"is_tuple  <code>property</code>","text":"<pre><code>is_tuple: bool\n</code></pre> <p>Whether this expression is a tuple.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprIfExp.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprIfExp.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return the expression as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Configuration options (none available yet).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return the expression as a dictionary.\n\n    Parameters:\n        **kwargs: Configuration options (none available yet).\n\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return _expr_as_dict(self, **kwargs)\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprJoinedStr","title":"ExprJoinedStr  <code>dataclass</code>","text":"<p>             Bases: <code>Expr</code></p> <p>Joined strings like <code>f\"a {b} c\"</code>.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return the expression as a dictionary.</p> </li> </ul> <p>Attributes:</p> <ul> <li> canonical_name             (<code>str</code>)         \u2013          <p>Name of the expressed name/attribute.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> <li> classname             (<code>str</code>)         \u2013          <p>The expression class name.</p> </li> <li> is_classvar             (<code>bool</code>)         \u2013          <p>Whether this attribute is annotated with <code>ClassVar</code>.</p> </li> <li> is_generator             (<code>bool</code>)         \u2013          <p>Whether this expression is a generator.</p> </li> <li> is_iterator             (<code>bool</code>)         \u2013          <p>Whether this expression is an iterator.</p> </li> <li> is_tuple             (<code>bool</code>)         \u2013          <p>Whether this expression is a tuple.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprJoinedStr.canonical_name","title":"canonical_name  <code>property</code>","text":"<pre><code>canonical_name: str\n</code></pre> <p>Name of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprJoinedStr.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprJoinedStr.classname","title":"classname  <code>property</code>","text":"<pre><code>classname: str\n</code></pre> <p>The expression class name.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprJoinedStr.is_classvar","title":"is_classvar  <code>property</code>","text":"<pre><code>is_classvar: bool\n</code></pre> <p>Whether this attribute is annotated with <code>ClassVar</code>.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprJoinedStr.is_generator","title":"is_generator  <code>property</code>","text":"<pre><code>is_generator: bool\n</code></pre> <p>Whether this expression is a generator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprJoinedStr.is_iterator","title":"is_iterator  <code>property</code>","text":"<pre><code>is_iterator: bool\n</code></pre> <p>Whether this expression is an iterator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprJoinedStr.is_tuple","title":"is_tuple  <code>property</code>","text":"<pre><code>is_tuple: bool\n</code></pre> <p>Whether this expression is a tuple.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprJoinedStr.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprJoinedStr.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return the expression as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Configuration options (none available yet).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return the expression as a dictionary.\n\n    Parameters:\n        **kwargs: Configuration options (none available yet).\n\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return _expr_as_dict(self, **kwargs)\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprKeyword","title":"ExprKeyword  <code>dataclass</code>","text":"<p>             Bases: <code>Expr</code></p> <p>Keyword arguments like <code>a=b</code>.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return the expression as a dictionary.</p> </li> </ul> <p>Attributes:</p> <ul> <li> canonical_name             (<code>str</code>)         \u2013          <p>Name of the expressed name/attribute.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> <li> classname             (<code>str</code>)         \u2013          <p>The expression class name.</p> </li> <li> is_classvar             (<code>bool</code>)         \u2013          <p>Whether this attribute is annotated with <code>ClassVar</code>.</p> </li> <li> is_generator             (<code>bool</code>)         \u2013          <p>Whether this expression is a generator.</p> </li> <li> is_iterator             (<code>bool</code>)         \u2013          <p>Whether this expression is an iterator.</p> </li> <li> is_tuple             (<code>bool</code>)         \u2013          <p>Whether this expression is a tuple.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprKeyword.canonical_name","title":"canonical_name  <code>property</code>","text":"<pre><code>canonical_name: str\n</code></pre> <p>Name of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprKeyword.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprKeyword.classname","title":"classname  <code>property</code>","text":"<pre><code>classname: str\n</code></pre> <p>The expression class name.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprKeyword.is_classvar","title":"is_classvar  <code>property</code>","text":"<pre><code>is_classvar: bool\n</code></pre> <p>Whether this attribute is annotated with <code>ClassVar</code>.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprKeyword.is_generator","title":"is_generator  <code>property</code>","text":"<pre><code>is_generator: bool\n</code></pre> <p>Whether this expression is a generator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprKeyword.is_iterator","title":"is_iterator  <code>property</code>","text":"<pre><code>is_iterator: bool\n</code></pre> <p>Whether this expression is an iterator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprKeyword.is_tuple","title":"is_tuple  <code>property</code>","text":"<pre><code>is_tuple: bool\n</code></pre> <p>Whether this expression is a tuple.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprKeyword.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprKeyword.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return the expression as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Configuration options (none available yet).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return the expression as a dictionary.\n\n    Parameters:\n        **kwargs: Configuration options (none available yet).\n\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return _expr_as_dict(self, **kwargs)\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprLambda","title":"ExprLambda  <code>dataclass</code>","text":"<p>             Bases: <code>Expr</code></p> <p>Lambda expressions like <code>lambda a: a.b</code>.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return the expression as a dictionary.</p> </li> </ul> <p>Attributes:</p> <ul> <li> canonical_name             (<code>str</code>)         \u2013          <p>Name of the expressed name/attribute.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> <li> classname             (<code>str</code>)         \u2013          <p>The expression class name.</p> </li> <li> is_classvar             (<code>bool</code>)         \u2013          <p>Whether this attribute is annotated with <code>ClassVar</code>.</p> </li> <li> is_generator             (<code>bool</code>)         \u2013          <p>Whether this expression is a generator.</p> </li> <li> is_iterator             (<code>bool</code>)         \u2013          <p>Whether this expression is an iterator.</p> </li> <li> is_tuple             (<code>bool</code>)         \u2013          <p>Whether this expression is a tuple.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprLambda.canonical_name","title":"canonical_name  <code>property</code>","text":"<pre><code>canonical_name: str\n</code></pre> <p>Name of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprLambda.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprLambda.classname","title":"classname  <code>property</code>","text":"<pre><code>classname: str\n</code></pre> <p>The expression class name.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprLambda.is_classvar","title":"is_classvar  <code>property</code>","text":"<pre><code>is_classvar: bool\n</code></pre> <p>Whether this attribute is annotated with <code>ClassVar</code>.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprLambda.is_generator","title":"is_generator  <code>property</code>","text":"<pre><code>is_generator: bool\n</code></pre> <p>Whether this expression is a generator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprLambda.is_iterator","title":"is_iterator  <code>property</code>","text":"<pre><code>is_iterator: bool\n</code></pre> <p>Whether this expression is an iterator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprLambda.is_tuple","title":"is_tuple  <code>property</code>","text":"<pre><code>is_tuple: bool\n</code></pre> <p>Whether this expression is a tuple.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprLambda.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprLambda.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return the expression as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Configuration options (none available yet).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return the expression as a dictionary.\n\n    Parameters:\n        **kwargs: Configuration options (none available yet).\n\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return _expr_as_dict(self, **kwargs)\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprList","title":"ExprList  <code>dataclass</code>","text":"<p>             Bases: <code>Expr</code></p> <p>Lists like <code>[0, 1, 2]</code>.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return the expression as a dictionary.</p> </li> </ul> <p>Attributes:</p> <ul> <li> canonical_name             (<code>str</code>)         \u2013          <p>Name of the expressed name/attribute.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> <li> classname             (<code>str</code>)         \u2013          <p>The expression class name.</p> </li> <li> is_classvar             (<code>bool</code>)         \u2013          <p>Whether this attribute is annotated with <code>ClassVar</code>.</p> </li> <li> is_generator             (<code>bool</code>)         \u2013          <p>Whether this expression is a generator.</p> </li> <li> is_iterator             (<code>bool</code>)         \u2013          <p>Whether this expression is an iterator.</p> </li> <li> is_tuple             (<code>bool</code>)         \u2013          <p>Whether this expression is a tuple.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprList.canonical_name","title":"canonical_name  <code>property</code>","text":"<pre><code>canonical_name: str\n</code></pre> <p>Name of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprList.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprList.classname","title":"classname  <code>property</code>","text":"<pre><code>classname: str\n</code></pre> <p>The expression class name.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprList.is_classvar","title":"is_classvar  <code>property</code>","text":"<pre><code>is_classvar: bool\n</code></pre> <p>Whether this attribute is annotated with <code>ClassVar</code>.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprList.is_generator","title":"is_generator  <code>property</code>","text":"<pre><code>is_generator: bool\n</code></pre> <p>Whether this expression is a generator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprList.is_iterator","title":"is_iterator  <code>property</code>","text":"<pre><code>is_iterator: bool\n</code></pre> <p>Whether this expression is an iterator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprList.is_tuple","title":"is_tuple  <code>property</code>","text":"<pre><code>is_tuple: bool\n</code></pre> <p>Whether this expression is a tuple.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprList.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprList.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return the expression as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Configuration options (none available yet).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return the expression as a dictionary.\n\n    Parameters:\n        **kwargs: Configuration options (none available yet).\n\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return _expr_as_dict(self, **kwargs)\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprListComp","title":"ExprListComp  <code>dataclass</code>","text":"<p>             Bases: <code>Expr</code></p> <p>List comprehensions like <code>[a for b in c]</code>.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return the expression as a dictionary.</p> </li> </ul> <p>Attributes:</p> <ul> <li> canonical_name             (<code>str</code>)         \u2013          <p>Name of the expressed name/attribute.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> <li> classname             (<code>str</code>)         \u2013          <p>The expression class name.</p> </li> <li> is_classvar             (<code>bool</code>)         \u2013          <p>Whether this attribute is annotated with <code>ClassVar</code>.</p> </li> <li> is_generator             (<code>bool</code>)         \u2013          <p>Whether this expression is a generator.</p> </li> <li> is_iterator             (<code>bool</code>)         \u2013          <p>Whether this expression is an iterator.</p> </li> <li> is_tuple             (<code>bool</code>)         \u2013          <p>Whether this expression is a tuple.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprListComp.canonical_name","title":"canonical_name  <code>property</code>","text":"<pre><code>canonical_name: str\n</code></pre> <p>Name of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprListComp.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprListComp.classname","title":"classname  <code>property</code>","text":"<pre><code>classname: str\n</code></pre> <p>The expression class name.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprListComp.is_classvar","title":"is_classvar  <code>property</code>","text":"<pre><code>is_classvar: bool\n</code></pre> <p>Whether this attribute is annotated with <code>ClassVar</code>.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprListComp.is_generator","title":"is_generator  <code>property</code>","text":"<pre><code>is_generator: bool\n</code></pre> <p>Whether this expression is a generator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprListComp.is_iterator","title":"is_iterator  <code>property</code>","text":"<pre><code>is_iterator: bool\n</code></pre> <p>Whether this expression is an iterator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprListComp.is_tuple","title":"is_tuple  <code>property</code>","text":"<pre><code>is_tuple: bool\n</code></pre> <p>Whether this expression is a tuple.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprListComp.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprListComp.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return the expression as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Configuration options (none available yet).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return the expression as a dictionary.\n\n    Parameters:\n        **kwargs: Configuration options (none available yet).\n\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return _expr_as_dict(self, **kwargs)\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprName","title":"ExprName  <code>dataclass</code>","text":"<p>             Bases: <code>Expr</code></p> <p>This class represents a Python object identified by a name in a given scope.</p> <p>Attributes:</p> <ul> <li> source         \u2013          <p>The name as written in the source code.</p> </li> </ul> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return the expression as a dictionary.</p> </li> </ul> <p>Attributes:</p> <ul> <li> canonical_name             (<code>str</code>)         \u2013          <p>Name of the expressed name/attribute.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Return the canonical name (resolved one, not alias name).</p> </li> <li> classname             (<code>str</code>)         \u2013          <p>The expression class name.</p> </li> <li> is_classvar             (<code>bool</code>)         \u2013          <p>Whether this attribute is annotated with <code>ClassVar</code>.</p> </li> <li> is_generator             (<code>bool</code>)         \u2013          <p>Whether this expression is a generator.</p> </li> <li> is_iterator             (<code>bool</code>)         \u2013          <p>Whether this expression is an iterator.</p> </li> <li> is_tuple             (<code>bool</code>)         \u2013          <p>Whether this expression is a tuple.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Return the full, resolved name.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprName.canonical_name","title":"canonical_name  <code>property</code>","text":"<pre><code>canonical_name: str\n</code></pre> <p>Name of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprName.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Return the canonical name (resolved one, not alias name).</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The canonical name.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprName.classname","title":"classname  <code>property</code>","text":"<pre><code>classname: str\n</code></pre> <p>The expression class name.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprName.is_classvar","title":"is_classvar  <code>property</code>","text":"<pre><code>is_classvar: bool\n</code></pre> <p>Whether this attribute is annotated with <code>ClassVar</code>.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprName.is_generator","title":"is_generator  <code>property</code>","text":"<pre><code>is_generator: bool\n</code></pre> <p>Whether this expression is a generator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprName.is_iterator","title":"is_iterator  <code>property</code>","text":"<pre><code>is_iterator: bool\n</code></pre> <p>Whether this expression is an iterator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprName.is_tuple","title":"is_tuple  <code>property</code>","text":"<pre><code>is_tuple: bool\n</code></pre> <p>Whether this expression is a tuple.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprName.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Return the full, resolved name.</p> <p>If it was given when creating the name, return that. If a callable was given, call it and return its result. It the name cannot be resolved, return the source.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The resolved name or the source.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprName.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return the expression as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Configuration options (none available yet).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return the expression as a dictionary.\n\n    Parameters:\n        **kwargs: Configuration options (none available yet).\n\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return _expr_as_dict(self, **kwargs)\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprNamedExpr","title":"ExprNamedExpr  <code>dataclass</code>","text":"<p>             Bases: <code>Expr</code></p> <p>Named/assignment expressions like <code>a := b</code>.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return the expression as a dictionary.</p> </li> </ul> <p>Attributes:</p> <ul> <li> canonical_name             (<code>str</code>)         \u2013          <p>Name of the expressed name/attribute.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> <li> classname             (<code>str</code>)         \u2013          <p>The expression class name.</p> </li> <li> is_classvar             (<code>bool</code>)         \u2013          <p>Whether this attribute is annotated with <code>ClassVar</code>.</p> </li> <li> is_generator             (<code>bool</code>)         \u2013          <p>Whether this expression is a generator.</p> </li> <li> is_iterator             (<code>bool</code>)         \u2013          <p>Whether this expression is an iterator.</p> </li> <li> is_tuple             (<code>bool</code>)         \u2013          <p>Whether this expression is a tuple.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprNamedExpr.canonical_name","title":"canonical_name  <code>property</code>","text":"<pre><code>canonical_name: str\n</code></pre> <p>Name of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprNamedExpr.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprNamedExpr.classname","title":"classname  <code>property</code>","text":"<pre><code>classname: str\n</code></pre> <p>The expression class name.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprNamedExpr.is_classvar","title":"is_classvar  <code>property</code>","text":"<pre><code>is_classvar: bool\n</code></pre> <p>Whether this attribute is annotated with <code>ClassVar</code>.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprNamedExpr.is_generator","title":"is_generator  <code>property</code>","text":"<pre><code>is_generator: bool\n</code></pre> <p>Whether this expression is a generator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprNamedExpr.is_iterator","title":"is_iterator  <code>property</code>","text":"<pre><code>is_iterator: bool\n</code></pre> <p>Whether this expression is an iterator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprNamedExpr.is_tuple","title":"is_tuple  <code>property</code>","text":"<pre><code>is_tuple: bool\n</code></pre> <p>Whether this expression is a tuple.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprNamedExpr.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprNamedExpr.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return the expression as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Configuration options (none available yet).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return the expression as a dictionary.\n\n    Parameters:\n        **kwargs: Configuration options (none available yet).\n\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return _expr_as_dict(self, **kwargs)\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprParameter","title":"ExprParameter  <code>dataclass</code>","text":"<p>             Bases: <code>Expr</code></p> <p>Parameters in function signatures like <code>a: int = 0</code>.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return the expression as a dictionary.</p> </li> <li> iterate           \u2013            <p>Iterate on the expression elements.</p> </li> </ul> <p>Attributes:</p> <ul> <li> canonical_name             (<code>str</code>)         \u2013          <p>Name of the expressed name/attribute.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> <li> classname             (<code>str</code>)         \u2013          <p>The expression class name.</p> </li> <li> is_classvar             (<code>bool</code>)         \u2013          <p>Whether this attribute is annotated with <code>ClassVar</code>.</p> </li> <li> is_generator             (<code>bool</code>)         \u2013          <p>Whether this expression is a generator.</p> </li> <li> is_iterator             (<code>bool</code>)         \u2013          <p>Whether this expression is an iterator.</p> </li> <li> is_tuple             (<code>bool</code>)         \u2013          <p>Whether this expression is a tuple.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprParameter.canonical_name","title":"canonical_name  <code>property</code>","text":"<pre><code>canonical_name: str\n</code></pre> <p>Name of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprParameter.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprParameter.classname","title":"classname  <code>property</code>","text":"<pre><code>classname: str\n</code></pre> <p>The expression class name.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprParameter.is_classvar","title":"is_classvar  <code>property</code>","text":"<pre><code>is_classvar: bool\n</code></pre> <p>Whether this attribute is annotated with <code>ClassVar</code>.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprParameter.is_generator","title":"is_generator  <code>property</code>","text":"<pre><code>is_generator: bool\n</code></pre> <p>Whether this expression is a generator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprParameter.is_iterator","title":"is_iterator  <code>property</code>","text":"<pre><code>is_iterator: bool\n</code></pre> <p>Whether this expression is an iterator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprParameter.is_tuple","title":"is_tuple  <code>property</code>","text":"<pre><code>is_tuple: bool\n</code></pre> <p>Whether this expression is a tuple.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprParameter.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprParameter.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return the expression as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Configuration options (none available yet).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return the expression as a dictionary.\n\n    Parameters:\n        **kwargs: Configuration options (none available yet).\n\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return _expr_as_dict(self, **kwargs)\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprParameter.iterate","title":"iterate","text":"<pre><code>iterate(*, flat: bool = True) -&gt; Iterator[str | Expr]\n</code></pre> <p>Iterate on the expression elements.</p> <p>Parameters:</p> <ul> <li> flat             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Expressions are trees.</p> <p>When flat is false, this method iterates only on the first layer of the tree. To iterate on all the subparts of the expression, you have to do so recursively. It allows to handle each subpart specifically (for example subscripts, attribute, etc.), without them getting rendered as strings.</p> <p>On the contrary, when flat is true, the whole tree is flattened as a sequence of strings and instances of Names.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>str | Expr</code>         \u2013          <p>Strings and names when flat, strings and expressions otherwise.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def iterate(self, *, flat: bool = True) -&gt; Iterator[str | Expr]:  # noqa: ARG002\n\"\"\"Iterate on the expression elements.\n\n    Parameters:\n        flat: Expressions are trees.\n\n            When flat is false, this method iterates only on the first layer of the tree.\n            To iterate on all the subparts of the expression, you have to do so recursively.\n            It allows to handle each subpart specifically (for example subscripts, attribute, etc.),\n            without them getting rendered as strings.\n\n            On the contrary, when flat is true, the whole tree is flattened as a sequence\n            of strings and instances of [Names][griffe.expressions.ExprName].\n\n    Yields:\n        Strings and names when flat, strings and expressions otherwise.\n    \"\"\"\n    yield from ()\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSet","title":"ExprSet  <code>dataclass</code>","text":"<p>             Bases: <code>Expr</code></p> <p>Sets like <code>{0, 1, 2}</code>.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return the expression as a dictionary.</p> </li> </ul> <p>Attributes:</p> <ul> <li> canonical_name             (<code>str</code>)         \u2013          <p>Name of the expressed name/attribute.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> <li> classname             (<code>str</code>)         \u2013          <p>The expression class name.</p> </li> <li> is_classvar             (<code>bool</code>)         \u2013          <p>Whether this attribute is annotated with <code>ClassVar</code>.</p> </li> <li> is_generator             (<code>bool</code>)         \u2013          <p>Whether this expression is a generator.</p> </li> <li> is_iterator             (<code>bool</code>)         \u2013          <p>Whether this expression is an iterator.</p> </li> <li> is_tuple             (<code>bool</code>)         \u2013          <p>Whether this expression is a tuple.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSet.canonical_name","title":"canonical_name  <code>property</code>","text":"<pre><code>canonical_name: str\n</code></pre> <p>Name of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSet.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSet.classname","title":"classname  <code>property</code>","text":"<pre><code>classname: str\n</code></pre> <p>The expression class name.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSet.is_classvar","title":"is_classvar  <code>property</code>","text":"<pre><code>is_classvar: bool\n</code></pre> <p>Whether this attribute is annotated with <code>ClassVar</code>.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSet.is_generator","title":"is_generator  <code>property</code>","text":"<pre><code>is_generator: bool\n</code></pre> <p>Whether this expression is a generator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSet.is_iterator","title":"is_iterator  <code>property</code>","text":"<pre><code>is_iterator: bool\n</code></pre> <p>Whether this expression is an iterator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSet.is_tuple","title":"is_tuple  <code>property</code>","text":"<pre><code>is_tuple: bool\n</code></pre> <p>Whether this expression is a tuple.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSet.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSet.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return the expression as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Configuration options (none available yet).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return the expression as a dictionary.\n\n    Parameters:\n        **kwargs: Configuration options (none available yet).\n\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return _expr_as_dict(self, **kwargs)\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSetComp","title":"ExprSetComp  <code>dataclass</code>","text":"<p>             Bases: <code>Expr</code></p> <p>Set comprehensions like <code>{a for b in c}</code>.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return the expression as a dictionary.</p> </li> </ul> <p>Attributes:</p> <ul> <li> canonical_name             (<code>str</code>)         \u2013          <p>Name of the expressed name/attribute.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> <li> classname             (<code>str</code>)         \u2013          <p>The expression class name.</p> </li> <li> is_classvar             (<code>bool</code>)         \u2013          <p>Whether this attribute is annotated with <code>ClassVar</code>.</p> </li> <li> is_generator             (<code>bool</code>)         \u2013          <p>Whether this expression is a generator.</p> </li> <li> is_iterator             (<code>bool</code>)         \u2013          <p>Whether this expression is an iterator.</p> </li> <li> is_tuple             (<code>bool</code>)         \u2013          <p>Whether this expression is a tuple.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSetComp.canonical_name","title":"canonical_name  <code>property</code>","text":"<pre><code>canonical_name: str\n</code></pre> <p>Name of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSetComp.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSetComp.classname","title":"classname  <code>property</code>","text":"<pre><code>classname: str\n</code></pre> <p>The expression class name.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSetComp.is_classvar","title":"is_classvar  <code>property</code>","text":"<pre><code>is_classvar: bool\n</code></pre> <p>Whether this attribute is annotated with <code>ClassVar</code>.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSetComp.is_generator","title":"is_generator  <code>property</code>","text":"<pre><code>is_generator: bool\n</code></pre> <p>Whether this expression is a generator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSetComp.is_iterator","title":"is_iterator  <code>property</code>","text":"<pre><code>is_iterator: bool\n</code></pre> <p>Whether this expression is an iterator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSetComp.is_tuple","title":"is_tuple  <code>property</code>","text":"<pre><code>is_tuple: bool\n</code></pre> <p>Whether this expression is a tuple.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSetComp.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSetComp.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return the expression as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Configuration options (none available yet).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return the expression as a dictionary.\n\n    Parameters:\n        **kwargs: Configuration options (none available yet).\n\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return _expr_as_dict(self, **kwargs)\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSlice","title":"ExprSlice  <code>dataclass</code>","text":"<p>             Bases: <code>Expr</code></p> <p>Slices like <code>[a:b:c]</code>.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return the expression as a dictionary.</p> </li> </ul> <p>Attributes:</p> <ul> <li> canonical_name             (<code>str</code>)         \u2013          <p>Name of the expressed name/attribute.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> <li> classname             (<code>str</code>)         \u2013          <p>The expression class name.</p> </li> <li> is_classvar             (<code>bool</code>)         \u2013          <p>Whether this attribute is annotated with <code>ClassVar</code>.</p> </li> <li> is_generator             (<code>bool</code>)         \u2013          <p>Whether this expression is a generator.</p> </li> <li> is_iterator             (<code>bool</code>)         \u2013          <p>Whether this expression is an iterator.</p> </li> <li> is_tuple             (<code>bool</code>)         \u2013          <p>Whether this expression is a tuple.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSlice.canonical_name","title":"canonical_name  <code>property</code>","text":"<pre><code>canonical_name: str\n</code></pre> <p>Name of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSlice.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSlice.classname","title":"classname  <code>property</code>","text":"<pre><code>classname: str\n</code></pre> <p>The expression class name.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSlice.is_classvar","title":"is_classvar  <code>property</code>","text":"<pre><code>is_classvar: bool\n</code></pre> <p>Whether this attribute is annotated with <code>ClassVar</code>.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSlice.is_generator","title":"is_generator  <code>property</code>","text":"<pre><code>is_generator: bool\n</code></pre> <p>Whether this expression is a generator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSlice.is_iterator","title":"is_iterator  <code>property</code>","text":"<pre><code>is_iterator: bool\n</code></pre> <p>Whether this expression is an iterator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSlice.is_tuple","title":"is_tuple  <code>property</code>","text":"<pre><code>is_tuple: bool\n</code></pre> <p>Whether this expression is a tuple.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSlice.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSlice.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return the expression as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Configuration options (none available yet).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return the expression as a dictionary.\n\n    Parameters:\n        **kwargs: Configuration options (none available yet).\n\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return _expr_as_dict(self, **kwargs)\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSubscript","title":"ExprSubscript  <code>dataclass</code>","text":"<p>             Bases: <code>Expr</code></p> <p>Subscripts like <code>a[b]</code>.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return the expression as a dictionary.</p> </li> </ul> <p>Attributes:</p> <ul> <li> canonical_name             (<code>str</code>)         \u2013          <p>Name of the expressed name/attribute.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>The canonical path of this subscript's left part.</p> </li> <li> classname             (<code>str</code>)         \u2013          <p>The expression class name.</p> </li> <li> is_classvar             (<code>bool</code>)         \u2013          <p>Whether this attribute is annotated with <code>ClassVar</code>.</p> </li> <li> is_generator             (<code>bool</code>)         \u2013          <p>Whether this expression is a generator.</p> </li> <li> is_iterator             (<code>bool</code>)         \u2013          <p>Whether this expression is an iterator.</p> </li> <li> is_tuple             (<code>bool</code>)         \u2013          <p>Whether this expression is a tuple.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>The path of this subscript's left part.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSubscript.canonical_name","title":"canonical_name  <code>property</code>","text":"<pre><code>canonical_name: str\n</code></pre> <p>Name of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSubscript.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>The canonical path of this subscript's left part.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSubscript.classname","title":"classname  <code>property</code>","text":"<pre><code>classname: str\n</code></pre> <p>The expression class name.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSubscript.is_classvar","title":"is_classvar  <code>property</code>","text":"<pre><code>is_classvar: bool\n</code></pre> <p>Whether this attribute is annotated with <code>ClassVar</code>.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSubscript.is_generator","title":"is_generator  <code>property</code>","text":"<pre><code>is_generator: bool\n</code></pre> <p>Whether this expression is a generator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSubscript.is_iterator","title":"is_iterator  <code>property</code>","text":"<pre><code>is_iterator: bool\n</code></pre> <p>Whether this expression is an iterator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSubscript.is_tuple","title":"is_tuple  <code>property</code>","text":"<pre><code>is_tuple: bool\n</code></pre> <p>Whether this expression is a tuple.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSubscript.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>The path of this subscript's left part.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprSubscript.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return the expression as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Configuration options (none available yet).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return the expression as a dictionary.\n\n    Parameters:\n        **kwargs: Configuration options (none available yet).\n\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return _expr_as_dict(self, **kwargs)\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprTuple","title":"ExprTuple  <code>dataclass</code>","text":"<p>             Bases: <code>Expr</code></p> <p>Tuples like <code>(0, 1, 2)</code>.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return the expression as a dictionary.</p> </li> </ul> <p>Attributes:</p> <ul> <li> canonical_name             (<code>str</code>)         \u2013          <p>Name of the expressed name/attribute.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> <li> classname             (<code>str</code>)         \u2013          <p>The expression class name.</p> </li> <li> is_classvar             (<code>bool</code>)         \u2013          <p>Whether this attribute is annotated with <code>ClassVar</code>.</p> </li> <li> is_generator             (<code>bool</code>)         \u2013          <p>Whether this expression is a generator.</p> </li> <li> is_iterator             (<code>bool</code>)         \u2013          <p>Whether this expression is an iterator.</p> </li> <li> is_tuple             (<code>bool</code>)         \u2013          <p>Whether this expression is a tuple.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprTuple.canonical_name","title":"canonical_name  <code>property</code>","text":"<pre><code>canonical_name: str\n</code></pre> <p>Name of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprTuple.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprTuple.classname","title":"classname  <code>property</code>","text":"<pre><code>classname: str\n</code></pre> <p>The expression class name.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprTuple.is_classvar","title":"is_classvar  <code>property</code>","text":"<pre><code>is_classvar: bool\n</code></pre> <p>Whether this attribute is annotated with <code>ClassVar</code>.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprTuple.is_generator","title":"is_generator  <code>property</code>","text":"<pre><code>is_generator: bool\n</code></pre> <p>Whether this expression is a generator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprTuple.is_iterator","title":"is_iterator  <code>property</code>","text":"<pre><code>is_iterator: bool\n</code></pre> <p>Whether this expression is an iterator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprTuple.is_tuple","title":"is_tuple  <code>property</code>","text":"<pre><code>is_tuple: bool\n</code></pre> <p>Whether this expression is a tuple.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprTuple.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprTuple.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return the expression as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Configuration options (none available yet).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return the expression as a dictionary.\n\n    Parameters:\n        **kwargs: Configuration options (none available yet).\n\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return _expr_as_dict(self, **kwargs)\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprUnaryOp","title":"ExprUnaryOp  <code>dataclass</code>","text":"<p>             Bases: <code>Expr</code></p> <p>Unary operations like <code>-1</code>.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return the expression as a dictionary.</p> </li> </ul> <p>Attributes:</p> <ul> <li> canonical_name             (<code>str</code>)         \u2013          <p>Name of the expressed name/attribute.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> <li> classname             (<code>str</code>)         \u2013          <p>The expression class name.</p> </li> <li> is_classvar             (<code>bool</code>)         \u2013          <p>Whether this attribute is annotated with <code>ClassVar</code>.</p> </li> <li> is_generator             (<code>bool</code>)         \u2013          <p>Whether this expression is a generator.</p> </li> <li> is_iterator             (<code>bool</code>)         \u2013          <p>Whether this expression is an iterator.</p> </li> <li> is_tuple             (<code>bool</code>)         \u2013          <p>Whether this expression is a tuple.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprUnaryOp.canonical_name","title":"canonical_name  <code>property</code>","text":"<pre><code>canonical_name: str\n</code></pre> <p>Name of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprUnaryOp.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprUnaryOp.classname","title":"classname  <code>property</code>","text":"<pre><code>classname: str\n</code></pre> <p>The expression class name.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprUnaryOp.is_classvar","title":"is_classvar  <code>property</code>","text":"<pre><code>is_classvar: bool\n</code></pre> <p>Whether this attribute is annotated with <code>ClassVar</code>.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprUnaryOp.is_generator","title":"is_generator  <code>property</code>","text":"<pre><code>is_generator: bool\n</code></pre> <p>Whether this expression is a generator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprUnaryOp.is_iterator","title":"is_iterator  <code>property</code>","text":"<pre><code>is_iterator: bool\n</code></pre> <p>Whether this expression is an iterator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprUnaryOp.is_tuple","title":"is_tuple  <code>property</code>","text":"<pre><code>is_tuple: bool\n</code></pre> <p>Whether this expression is a tuple.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprUnaryOp.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprUnaryOp.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return the expression as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Configuration options (none available yet).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return the expression as a dictionary.\n\n    Parameters:\n        **kwargs: Configuration options (none available yet).\n\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return _expr_as_dict(self, **kwargs)\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprVarKeyword","title":"ExprVarKeyword  <code>dataclass</code>","text":"<p>             Bases: <code>Expr</code></p> <p>Variadic keyword parameters like <code>**kwargs</code>.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return the expression as a dictionary.</p> </li> </ul> <p>Attributes:</p> <ul> <li> canonical_name             (<code>str</code>)         \u2013          <p>Name of the expressed name/attribute.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> <li> classname             (<code>str</code>)         \u2013          <p>The expression class name.</p> </li> <li> is_classvar             (<code>bool</code>)         \u2013          <p>Whether this attribute is annotated with <code>ClassVar</code>.</p> </li> <li> is_generator             (<code>bool</code>)         \u2013          <p>Whether this expression is a generator.</p> </li> <li> is_iterator             (<code>bool</code>)         \u2013          <p>Whether this expression is an iterator.</p> </li> <li> is_tuple             (<code>bool</code>)         \u2013          <p>Whether this expression is a tuple.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprVarKeyword.canonical_name","title":"canonical_name  <code>property</code>","text":"<pre><code>canonical_name: str\n</code></pre> <p>Name of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprVarKeyword.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprVarKeyword.classname","title":"classname  <code>property</code>","text":"<pre><code>classname: str\n</code></pre> <p>The expression class name.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprVarKeyword.is_classvar","title":"is_classvar  <code>property</code>","text":"<pre><code>is_classvar: bool\n</code></pre> <p>Whether this attribute is annotated with <code>ClassVar</code>.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprVarKeyword.is_generator","title":"is_generator  <code>property</code>","text":"<pre><code>is_generator: bool\n</code></pre> <p>Whether this expression is a generator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprVarKeyword.is_iterator","title":"is_iterator  <code>property</code>","text":"<pre><code>is_iterator: bool\n</code></pre> <p>Whether this expression is an iterator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprVarKeyword.is_tuple","title":"is_tuple  <code>property</code>","text":"<pre><code>is_tuple: bool\n</code></pre> <p>Whether this expression is a tuple.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprVarKeyword.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprVarKeyword.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return the expression as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Configuration options (none available yet).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return the expression as a dictionary.\n\n    Parameters:\n        **kwargs: Configuration options (none available yet).\n\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return _expr_as_dict(self, **kwargs)\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprVarPositional","title":"ExprVarPositional  <code>dataclass</code>","text":"<p>             Bases: <code>Expr</code></p> <p>Variadic positional parameters like <code>*args</code>.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return the expression as a dictionary.</p> </li> </ul> <p>Attributes:</p> <ul> <li> canonical_name             (<code>str</code>)         \u2013          <p>Name of the expressed name/attribute.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> <li> classname             (<code>str</code>)         \u2013          <p>The expression class name.</p> </li> <li> is_classvar             (<code>bool</code>)         \u2013          <p>Whether this attribute is annotated with <code>ClassVar</code>.</p> </li> <li> is_generator             (<code>bool</code>)         \u2013          <p>Whether this expression is a generator.</p> </li> <li> is_iterator             (<code>bool</code>)         \u2013          <p>Whether this expression is an iterator.</p> </li> <li> is_tuple             (<code>bool</code>)         \u2013          <p>Whether this expression is a tuple.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprVarPositional.canonical_name","title":"canonical_name  <code>property</code>","text":"<pre><code>canonical_name: str\n</code></pre> <p>Name of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprVarPositional.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprVarPositional.classname","title":"classname  <code>property</code>","text":"<pre><code>classname: str\n</code></pre> <p>The expression class name.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprVarPositional.is_classvar","title":"is_classvar  <code>property</code>","text":"<pre><code>is_classvar: bool\n</code></pre> <p>Whether this attribute is annotated with <code>ClassVar</code>.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprVarPositional.is_generator","title":"is_generator  <code>property</code>","text":"<pre><code>is_generator: bool\n</code></pre> <p>Whether this expression is a generator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprVarPositional.is_iterator","title":"is_iterator  <code>property</code>","text":"<pre><code>is_iterator: bool\n</code></pre> <p>Whether this expression is an iterator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprVarPositional.is_tuple","title":"is_tuple  <code>property</code>","text":"<pre><code>is_tuple: bool\n</code></pre> <p>Whether this expression is a tuple.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprVarPositional.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprVarPositional.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return the expression as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Configuration options (none available yet).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return the expression as a dictionary.\n\n    Parameters:\n        **kwargs: Configuration options (none available yet).\n\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return _expr_as_dict(self, **kwargs)\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprYield","title":"ExprYield  <code>dataclass</code>","text":"<p>             Bases: <code>Expr</code></p> <p>Yield statements like <code>yield a</code>.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return the expression as a dictionary.</p> </li> </ul> <p>Attributes:</p> <ul> <li> canonical_name             (<code>str</code>)         \u2013          <p>Name of the expressed name/attribute.</p> </li> <li> canonical_path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> <li> classname             (<code>str</code>)         \u2013          <p>The expression class name.</p> </li> <li> is_classvar             (<code>bool</code>)         \u2013          <p>Whether this attribute is annotated with <code>ClassVar</code>.</p> </li> <li> is_generator             (<code>bool</code>)         \u2013          <p>Whether this expression is a generator.</p> </li> <li> is_iterator             (<code>bool</code>)         \u2013          <p>Whether this expression is an iterator.</p> </li> <li> is_tuple             (<code>bool</code>)         \u2013          <p>Whether this expression is a tuple.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>Path of the expressed name/attribute.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprYield.canonical_name","title":"canonical_name  <code>property</code>","text":"<pre><code>canonical_name: str\n</code></pre> <p>Name of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprYield.canonical_path","title":"canonical_path  <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprYield.classname","title":"classname  <code>property</code>","text":"<pre><code>classname: str\n</code></pre> <p>The expression class name.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprYield.is_classvar","title":"is_classvar  <code>property</code>","text":"<pre><code>is_classvar: bool\n</code></pre> <p>Whether this attribute is annotated with <code>ClassVar</code>.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprYield.is_generator","title":"is_generator  <code>property</code>","text":"<pre><code>is_generator: bool\n</code></pre> <p>Whether this expression is a generator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprYield.is_iterator","title":"is_iterator  <code>property</code>","text":"<pre><code>is_iterator: bool\n</code></pre> <p>Whether this expression is an iterator.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprYield.is_tuple","title":"is_tuple  <code>property</code>","text":"<pre><code>is_tuple: bool\n</code></pre> <p>Whether this expression is a tuple.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprYield.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Path of the expressed name/attribute.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.ExprYield.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return the expression as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Configuration options (none available yet).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return the expression as a dictionary.\n\n    Parameters:\n        **kwargs: Configuration options (none available yet).\n\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return _expr_as_dict(self, **kwargs)\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.get_expression","title":"get_expression","text":"<pre><code>get_expression(\n    node: AST | None,\n    parent: Module | Class,\n    *,\n    parse_strings: bool | None = None\n) -&gt; Expr | None\n</code></pre> <p>Build an expression from an AST.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | None</code>)         \u2013          <p>The annotation node.</p> </li> <li> parent             (<code>Module | Class</code>)         \u2013          <p>The parent used to resolve the name.</p> </li> <li> parse_strings             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether to try and parse strings as type annotations.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Expr | None</code>         \u2013          <p>A string or resovable name or expression.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def get_expression(\n    node: ast.AST | None,\n    parent: Module | Class,\n    *,\n    parse_strings: bool | None = None,\n) -&gt; Expr | None:\n\"\"\"Build an expression from an AST.\n\n    Parameters:\n        node: The annotation node.\n        parent: The parent used to resolve the name.\n        parse_strings: Whether to try and parse strings as type annotations.\n\n    Returns:\n        A string or resovable name or expression.\n    \"\"\"\n    if node is None:\n        return None\n    if parse_strings is None:\n        try:\n            module = parent.module\n        except ValueError:\n            parse_strings = False\n        else:\n            parse_strings = not module.imports_future_annotations\n    return _build(node, parent, parse_strings=parse_strings)\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.safe_get_expression","title":"safe_get_expression","text":"<pre><code>safe_get_expression(\n    node: AST | None,\n    parent: Module | Class,\n    *,\n    parse_strings: bool | None = None,\n    log_level: LogLevel | None = LogLevel.error,\n    msg_format: str = \"{path}:{lineno}: Failed to get expression from {node_class}: {error}\"\n) -&gt; Expr | None\n</code></pre> <p>Safely (no exception) build a resolvable annotation.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | None</code>)         \u2013          <p>The annotation node.</p> </li> <li> parent             (<code>Module | Class</code>)         \u2013          <p>The parent used to resolve the name.</p> </li> <li> parse_strings             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether to try and parse strings as type annotations.</p> </li> <li> log_level             (<code>LogLevel | None</code>, default:                 <code>error</code> )         \u2013          <p>Log level to use to log a message. None to disable logging.</p> </li> <li> msg_format             (<code>str</code>, default:                 <code>'{path}:{lineno}: Failed to get expression from {node_class}: {error}'</code> )         \u2013          <p>A format string for the log message. Available placeholders: path, lineno, node, error.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Expr | None</code>         \u2013          <p>A string or resovable name or expression.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def safe_get_expression(\n    node: ast.AST | None,\n    parent: Module | Class,\n    *,\n    parse_strings: bool | None = None,\n    log_level: LogLevel | None = LogLevel.error,\n    msg_format: str = \"{path}:{lineno}: Failed to get expression from {node_class}: {error}\",\n) -&gt; Expr | None:\n\"\"\"Safely (no exception) build a resolvable annotation.\n\n    Parameters:\n        node: The annotation node.\n        parent: The parent used to resolve the name.\n        parse_strings: Whether to try and parse strings as type annotations.\n        log_level: Log level to use to log a message. None to disable logging.\n        msg_format: A format string for the log message. Available placeholders:\n            path, lineno, node, error.\n\n    Returns:\n        A string or resovable name or expression.\n    \"\"\"\n    try:\n        return get_expression(node, parent, parse_strings=parse_strings)\n    except Exception as error:  # noqa: BLE001\n        if log_level is None:\n            return None\n        node_class = node.__class__.__name__\n        try:\n            path: Path | str = parent.relative_filepath\n        except ValueError:\n            path = \"&lt;in-memory&gt;\"\n        lineno = node.lineno  # type: ignore[union-attr]\n        error_str = f\"{error.__class__.__name__}: {error}\"\n        message = msg_format.format(path=path, lineno=lineno, node_class=node_class, error=error_str)\n        getattr(logger, log_level.value)(message)\n    return None\n</code></pre>"},{"location":"reference/griffe/finder/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> finder","text":""},{"location":"reference/griffe/finder/#griffe.finder","title":"finder","text":"<p>This module contains the code allowing to find modules.</p> <p>Classes:</p> <ul> <li> ModuleFinder         \u2013          <p>The Griffe finder, allowing to find modules on the file system.</p> </li> <li> NamespacePackage         \u2013          <p>This class is a simple placeholder used during the process of finding packages.</p> </li> <li> Package         \u2013          <p>This class is a simple placeholder used during the process of finding packages.</p> </li> </ul>"},{"location":"reference/griffe/finder/#griffe.finder.ModuleFinder","title":"ModuleFinder","text":"<pre><code>ModuleFinder(\n    search_paths: Sequence[str | Path] | None = None,\n)\n</code></pre> <p>The Griffe finder, allowing to find modules on the file system.</p> <p>Parameters:</p> <ul> <li> search_paths             (<code>Sequence[str | Path] | None</code>, default:                 <code>None</code> )         \u2013          <p>Optional paths to search into.</p> </li> </ul> <p>Methods:</p> <ul> <li> find_package           \u2013            <p>Find a package or namespace package.</p> </li> <li> find_spec           \u2013            <p>Find the top module of a module.</p> </li> <li> iter_submodules           \u2013            <p>Iterate on a module's submodules, if any.</p> </li> <li> submodules           \u2013            <p>Return the list of a module's submodules.</p> </li> </ul> Source code in <code>src/griffe/finder.py</code> <pre><code>def __init__(self, search_paths: Sequence[str | Path] | None = None) -&gt; None:\n\"\"\"Initialize the finder.\n\n    Parameters:\n        search_paths: Optional paths to search into.\n    \"\"\"\n    self._paths_contents: dict[Path, list[Path]] = {}\n    # optimization: pre-compute Paths to relieve CPU when joining paths\n    self.search_paths = [path if isinstance(path, Path) else Path(path) for path in search_paths or sys.path]\n    self._extend_from_pth_files()\n</code></pre>"},{"location":"reference/griffe/finder/#griffe.finder.ModuleFinder.find_package","title":"find_package","text":"<pre><code>find_package(\n    module_name: str,\n) -&gt; Package | NamespacePackage\n</code></pre> <p>Find a package or namespace package.</p> <p>Parameters:</p> <ul> <li> module_name             (<code>str</code>)         \u2013          <p>The module name.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ModuleNotFoundError</code>           \u2013          <p>When the module cannot be found.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Package | NamespacePackage</code>         \u2013          <p>A package or namespace package wrapper.</p> </li> </ul> Source code in <code>src/griffe/finder.py</code> <pre><code>def find_package(self, module_name: str) -&gt; Package | NamespacePackage:\n\"\"\"Find a package or namespace package.\n\n    Parameters:\n        module_name: The module name.\n\n    Raises:\n        ModuleNotFoundError: When the module cannot be found.\n\n    Returns:\n        A package or namespace package wrapper.\n    \"\"\"\n    filepaths = [\n        Path(module_name),\n        # TODO: handle .py[cod] and .so files?\n        Path(f\"{module_name}.py\"),\n    ]\n\n    namespace_dirs = []\n    for path in self.search_paths:\n        path_contents = self._contents(path)\n        if path_contents:\n            for choice in filepaths:\n                abs_path = path / choice\n                if abs_path in path_contents:\n                    if abs_path.suffix:\n                        stubs = abs_path.with_suffix(\".pyi\")\n                        return Package(module_name, abs_path, stubs if stubs.exists() else None)\n                    init_module = abs_path / \"__init__.py\"\n                    if init_module.exists() and not _is_pkg_style_namespace(init_module):\n                        stubs = init_module.with_suffix(\".pyi\")\n                        return Package(module_name, init_module, stubs if stubs.exists() else None)\n                    namespace_dirs.append(abs_path)\n\n    if namespace_dirs:\n        return NamespacePackage(module_name, namespace_dirs)\n\n    raise ModuleNotFoundError(module_name)\n</code></pre>"},{"location":"reference/griffe/finder/#griffe.finder.ModuleFinder.find_spec","title":"find_spec","text":"<pre><code>find_spec(\n    module: str | Path, *, try_relative_path: bool = True\n) -&gt; tuple[str, Package | NamespacePackage]\n</code></pre> <p>Find the top module of a module.</p> <p>If a Path is passed, only try to find the module as a file path. If a string is passed, first try to find the module as a file path, then look into the search paths.</p> <p>Parameters:</p> <ul> <li> module             (<code>str | Path</code>)         \u2013          <p>The module name or path.</p> </li> <li> try_relative_path             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to try finding the module as a relative path, when the given module is not already a path.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FileNotFoundError</code>           \u2013          <p>When a Path was passed and the module could not be found:</p> <ul> <li>the directory has no <code>__init__.py</code> file in it</li> <li>the path does not exist</li> </ul> </li> <li> <code>ModuleNotFoundError</code>           \u2013          <p>When a string was passed and the module could not be found:</p> <ul> <li>no <code>module/__init__.py</code></li> <li>no <code>module.py</code></li> <li>no <code>module.pth</code></li> <li>no <code>module</code> directory (namespace packages)</li> <li>or unsupported .pth file</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[str, Package | NamespacePackage]</code>         \u2013          <p>The name of the module, and an instance representing its (namespace) package.</p> </li> </ul> Source code in <code>src/griffe/finder.py</code> <pre><code>def find_spec(\n    self,\n    module: str | Path,\n    *,\n    try_relative_path: bool = True,\n) -&gt; tuple[str, Package | NamespacePackage]:\n\"\"\"Find the top module of a module.\n\n    If a Path is passed, only try to find the module as a file path.\n    If a string is passed, first try to find the module as a file path,\n    then look into the search paths.\n\n    Parameters:\n        module: The module name or path.\n        try_relative_path: Whether to try finding the module as a relative path,\n            when the given module is not already a path.\n\n    Raises:\n        FileNotFoundError: When a Path was passed and the module could not be found:\n\n            - the directory has no `__init__.py` file in it\n            - the path does not exist\n\n        ModuleNotFoundError: When a string was passed and the module could not be found:\n\n            - no `module/__init__.py`\n            - no `module.py`\n            - no `module.pth`\n            - no `module` directory (namespace packages)\n            - or unsupported .pth file\n\n    Returns:\n        The name of the module, and an instance representing its (namespace) package.\n    \"\"\"\n    module_path: Path | list[Path]\n    if isinstance(module, Path):\n        module_name, module_path = self._module_name_path(module)\n        top_module_name = self._top_module_name(module_path)\n    elif try_relative_path:\n        try:\n            module_name, module_path = self._module_name_path(Path(module))\n        except FileNotFoundError:\n            module_name = module\n            top_module_name = module.split(\".\", 1)[0]\n        else:\n            top_module_name = self._top_module_name(module_path)\n    else:\n        module_name = module\n        top_module_name = module.split(\".\", 1)[0]\n    return module_name, self.find_package(top_module_name)\n</code></pre>"},{"location":"reference/griffe/finder/#griffe.finder.ModuleFinder.iter_submodules","title":"iter_submodules","text":"<pre><code>iter_submodules(\n    path: Path | list[Path], seen: set | None = None\n) -&gt; Iterator[NamePartsAndPathType]\n</code></pre> <p>Iterate on a module's submodules, if any.</p> <p>Parameters:</p> <ul> <li> path             (<code>Path | list[Path]</code>)         \u2013          <p>The module path.</p> </li> <li> seen             (<code>set | None</code>, default:                 <code>None</code> )         \u2013          <p>If not none, this set is used to skip some files. The goal is to replicate the behavior of Python by only using the first packages (with <code>__init__</code> modules) of the same name found in different namespace packages. As soon as we find an <code>__init__</code> module, we add its parent path to the <code>seen</code> set, which will be reused when scanning the next namespace packages.</p> </li> </ul> <p>Yields:</p> <ul> <li> name_parts (            <code>tuple[str, ...]</code> )        \u2013          <p>The parts of a submodule name.</p> </li> <li> filepath (            <code>Path</code> )        \u2013          <p>A submodule filepath.</p> </li> </ul> Source code in <code>src/griffe/finder.py</code> <pre><code>def iter_submodules(\n    self,\n    path: Path | list[Path],\n    seen: set | None = None,\n) -&gt; Iterator[NamePartsAndPathType]:\n\"\"\"Iterate on a module's submodules, if any.\n\n    Parameters:\n        path: The module path.\n        seen: If not none, this set is used to skip some files.\n            The goal is to replicate the behavior of Python by\n            only using the first packages (with `__init__` modules)\n            of the same name found in different namespace packages.\n            As soon as we find an `__init__` module, we add its parent\n            path to the `seen` set, which will be reused when scanning\n            the next namespace packages.\n\n    Yields:\n        name_parts (tuple[str, ...]): The parts of a submodule name.\n        filepath (Path): A submodule filepath.\n    \"\"\"\n    if isinstance(path, list):\n        seen = set()\n        for path_elem in path:\n            yield from self.iter_submodules(path_elem, seen)\n        return\n\n    if path.stem == \"__init__\":\n        path = path.parent\n    # optimization: just check if the file name ends with .py[icod]/.so\n    # (to distinguish it from a directory),\n    # not if it's an actual file\n    elif path.suffix in self.extensions_set:\n        return\n\n    skip = set(seen) if seen else set()\n    for subpath in self._filter_py_modules(path):\n        rel_subpath = subpath.relative_to(path)\n        if rel_subpath.parent in skip:\n            logger.debug(f\"Skip {subpath}, another module took precedence\")\n            continue\n        py_file = rel_subpath.suffix == \".py\"\n        stem = rel_subpath.stem\n        if not py_file:\n            # .py[cod] and .so files look like `name.cpython-38-x86_64-linux-gnu.ext`\n            stem = stem.split(\".\", 1)[0]\n        if stem == \"__init__\":\n            # optimization: since it's a relative path,\n            # if it has only one part and is named __init__,\n            # it means it's the starting path\n            # (no need to compare it against starting path)\n            if len(rel_subpath.parts) == 1:\n                continue\n            yield rel_subpath.parts[:-1], subpath\n            if seen is not None:\n                seen.add(rel_subpath.parent)\n        elif py_file:\n            yield rel_subpath.with_suffix(\"\").parts, subpath\n        else:\n            yield rel_subpath.with_name(stem).parts, subpath\n</code></pre>"},{"location":"reference/griffe/finder/#griffe.finder.ModuleFinder.submodules","title":"submodules","text":"<pre><code>submodules(module: Module) -&gt; list[NamePartsAndPathType]\n</code></pre> <p>Return the list of a module's submodules.</p> <p>Parameters:</p> <ul> <li> module             (<code>Module</code>)         \u2013          <p>The parent module.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[NamePartsAndPathType]</code>         \u2013          <p>A list of tuples containing the parts of the submodule name and its path.</p> </li> </ul> Source code in <code>src/griffe/finder.py</code> <pre><code>def submodules(self, module: Module) -&gt; list[NamePartsAndPathType]:\n\"\"\"Return the list of a module's submodules.\n\n    Parameters:\n        module: The parent module.\n\n    Returns:\n        A list of tuples containing the parts of the submodule name and its path.\n    \"\"\"\n    return sorted(self.iter_submodules(module.filepath), key=_module_depth)\n</code></pre>"},{"location":"reference/griffe/finder/#griffe.finder.NamespacePackage","title":"NamespacePackage","text":"<pre><code>NamespacePackage(name: str, path: list[Path])\n</code></pre> <p>This class is a simple placeholder used during the process of finding packages.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013          <p>The package name.</p> </li> <li> path             (<code>list[Path]</code>)         \u2013          <p>The package paths.</p> </li> </ul> <p>Methods:</p> <ul> </ul> Source code in <code>src/griffe/finder.py</code> <pre><code>def __init__(self, name: str, path: list[Path]) -&gt; None:\n\"\"\"Initialize the namespace package.\n\n    Parameters:\n        name: The package name.\n        path: The package paths.\n    \"\"\"\n    self.name: str = name\n    self.path: list[Path] = path\n</code></pre>"},{"location":"reference/griffe/finder/#griffe.finder.Package","title":"Package","text":"<pre><code>Package(name: str, path: Path, stubs: Path | None = None)\n</code></pre> <p>This class is a simple placeholder used during the process of finding packages.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013          <p>The package name.</p> </li> <li> path             (<code>Path</code>)         \u2013          <p>The package path(s).</p> </li> <li> stubs             (<code>Path | None</code>, default:                 <code>None</code> )         \u2013          <p>An optional path to the related stubs file (.pyi).</p> </li> </ul> <p>Methods:</p> <ul> </ul> Source code in <code>src/griffe/finder.py</code> <pre><code>def __init__(self, name: str, path: Path, stubs: Path | None = None) -&gt; None:\n\"\"\"Initialize the package.\n\n    Parameters:\n        name: The package name.\n        path: The package path(s).\n        stubs: An optional path to the related stubs file (.pyi).\n    \"\"\"\n    self.name: str = name\n    self.path: Path = path\n    self.stubs: Path | None = stubs\n</code></pre>"},{"location":"reference/griffe/git/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> git","text":""},{"location":"reference/griffe/git/#griffe.git","title":"git","text":"<p>This module contains the code allowing to load modules from specific git commits.</p> <pre><code>from griffe.git import load_git\n\n# where `repo` is the folder *containing* `.git`\nold_api = load_git(\"my_module\", commit=\"v0.1.0\", repo=\"path/to/repo\")\n</code></pre> <p>Functions:</p> <ul> <li> load_git           \u2013            <p>Load and return a module from a specific Git reference.</p> </li> </ul>"},{"location":"reference/griffe/git/#griffe.git.load_git","title":"load_git","text":"<pre><code>load_git(\n    module: str | Path,\n    *,\n    ref: str = \"HEAD\",\n    repo: str | Path = \".\",\n    submodules: bool = True,\n    extensions: Extensions | None = None,\n    search_paths: Sequence[str | Path] | None = None,\n    docstring_parser: Parser | None = None,\n    docstring_options: dict[str, Any] | None = None,\n    lines_collection: LinesCollection | None = None,\n    modules_collection: ModulesCollection | None = None,\n    allow_inspection: bool = True\n) -&gt; Module\n</code></pre> <p>Load and return a module from a specific Git reference.</p> <p>This function will create a temporary git worktree at the requested reference before loading <code>module</code> with <code>griffe.load</code>.</p> <p>This function requires that the <code>git</code> executable is installed.</p> <p>Parameters:</p> <ul> <li> module             (<code>str | Path</code>)         \u2013          <p>The module path, relative to the repository root.</p> </li> <li> ref             (<code>str</code>, default:                 <code>'HEAD'</code> )         \u2013          <p>A Git reference such as a commit, tag or branch.</p> </li> <li> repo             (<code>str | Path</code>, default:                 <code>'.'</code> )         \u2013          <p>Path to the repository (i.e. the directory containing the <code>.git</code> directory)</p> </li> <li> submodules             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to recurse on the submodules.</p> </li> <li> extensions             (<code>Extensions | None</code>, default:                 <code>None</code> )         \u2013          <p>The extensions to use.</p> </li> <li> search_paths             (<code>Sequence[str | Path] | None</code>, default:                 <code>None</code> )         \u2013          <p>The paths to search into (relative to the repository root).</p> </li> <li> docstring_parser             (<code>Parser | None</code>, default:                 <code>None</code> )         \u2013          <p>The docstring parser to use. By default, no parsing is done.</p> </li> <li> docstring_options             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional docstring parsing options.</p> </li> <li> lines_collection             (<code>LinesCollection | None</code>, default:                 <code>None</code> )         \u2013          <p>A collection of source code lines.</p> </li> <li> modules_collection             (<code>ModulesCollection | None</code>, default:                 <code>None</code> )         \u2013          <p>A collection of modules.</p> </li> <li> allow_inspection             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to allow inspecting modules when visiting them is not possible.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013          <p>A loaded module.</p> </li> </ul> Source code in <code>src/griffe/git.py</code> <pre><code>def load_git(\n    module: str | Path,\n    *,\n    ref: str = \"HEAD\",\n    repo: str | Path = \".\",\n    submodules: bool = True,\n    extensions: Extensions | None = None,\n    search_paths: Sequence[str | Path] | None = None,\n    docstring_parser: Parser | None = None,\n    docstring_options: dict[str, Any] | None = None,\n    lines_collection: LinesCollection | None = None,\n    modules_collection: ModulesCollection | None = None,\n    allow_inspection: bool = True,\n) -&gt; Module:\n\"\"\"Load and return a module from a specific Git reference.\n\n    This function will create a temporary\n    [git worktree](https://git-scm.com/docs/git-worktree) at the requested reference\n    before loading `module` with [`griffe.load`][griffe.loader.load].\n\n    This function requires that the `git` executable is installed.\n\n    Parameters:\n        module: The module path, relative to the repository root.\n        ref: A Git reference such as a commit, tag or branch.\n        repo: Path to the repository (i.e. the directory *containing* the `.git` directory)\n        submodules: Whether to recurse on the submodules.\n        extensions: The extensions to use.\n        search_paths: The paths to search into (relative to the repository root).\n        docstring_parser: The docstring parser to use. By default, no parsing is done.\n        docstring_options: Additional docstring parsing options.\n        lines_collection: A collection of source code lines.\n        modules_collection: A collection of modules.\n        allow_inspection: Whether to allow inspecting modules when visiting them is not possible.\n\n    Returns:\n        A loaded module.\n    \"\"\"\n    with _tmp_worktree(repo, ref) as worktree:\n        search_paths = [worktree / path for path in search_paths or [\".\"]]\n        if isinstance(module, Path):\n            module = worktree / module\n        return loader.load(\n            module=module,\n            submodules=submodules,\n            try_relative_path=False,\n            extensions=extensions,\n            search_paths=search_paths,\n            docstring_parser=docstring_parser,\n            docstring_options=docstring_options,\n            lines_collection=lines_collection,\n            modules_collection=modules_collection,\n            allow_inspection=allow_inspection,\n        )\n</code></pre>"},{"location":"reference/griffe/importer/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> importer","text":""},{"location":"reference/griffe/importer/#griffe.importer","title":"importer","text":"<p>This module contains utilities to dynamically import objects.</p> <p>Functions:</p> <ul> <li> dynamic_import           \u2013            <p>Dynamically import the specified object.</p> </li> <li> sys_path           \u2013            <p>Redefine <code>sys.path</code> temporarily.</p> </li> </ul>"},{"location":"reference/griffe/importer/#griffe.importer.dynamic_import","title":"dynamic_import","text":"<pre><code>dynamic_import(\n    import_path: str,\n    import_paths: Sequence[str | Path] | None = None,\n) -&gt; Any\n</code></pre> <p>Dynamically import the specified object.</p> <p>It can be a module, class, method, function, attribute, nested arbitrarily.</p> <p>Parameters:</p> <ul> <li> import_path             (<code>str</code>)         \u2013          <p>The path of the object to import.</p> </li> <li> import_paths             (<code>Sequence[str | Path] | None</code>, default:                 <code>None</code> )         \u2013          <p>The paths to import the object from.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ModuleNotFoundError</code>           \u2013          <p>When the object's module could not be found.</p> </li> <li> <code>ImportError</code>           \u2013          <p>When there was an import error or when couldn't get the attribute.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code>         \u2013          <p>The imported object.</p> </li> </ul> Source code in <code>src/griffe/importer.py</code> <pre><code>def dynamic_import(import_path: str, import_paths: Sequence[str | Path] | None = None) -&gt; Any:\n\"\"\"Dynamically import the specified object.\n\n    It can be a module, class, method, function, attribute,\n    nested arbitrarily.\n\n    Parameters:\n        import_path: The path of the object to import.\n        import_paths: The paths to import the object from.\n\n    Raises:\n        ModuleNotFoundError: When the object's module could not be found.\n        ImportError: When there was an import error or when couldn't get the attribute.\n\n    Returns:\n        The imported object.\n    \"\"\"\n    module_parts: list[str] = import_path.split(\".\")\n    object_parts: list[str] = []\n    errors = []\n\n    with sys_path(*(import_paths or ())):\n        while True:\n            module_path = \".\".join(module_parts)\n            try:\n                module = import_module(module_path)\n            except ModuleNotFoundError as error:\n                if len(module_parts) == 1:\n                    raise\n                errors.append(f\"{error.__class__.__name__}: {error}\")\n                object_parts.insert(0, module_parts.pop(-1))\n            except (Exception, BaseException) as error:\n                # pyo3's PanicException can only be caught with BaseException.\n                # We do want to catch base exceptions anyway (exit, interrupt, etc.),\n                errors.append(f\"{error.__class__.__name__}: {error}\")\n                raise ImportError(\"\\n\".join(errors)) from error\n            else:\n                break\n\n    # Sometimes extra dependencies are not installed,\n    # and therefore we aren't able to import the leaf module,\n    # so we end up with its parent instead, on which we can't\n    # get the attribute either. In that case we re-raise an\n    # ImportError for consistency.\n    # See https://github.com/mkdocstrings/mkdocstrings/issues/380\n\n    value = module\n    for part in object_parts:\n        try:\n            value = getattr(value, part)\n        except AttributeError as error:\n            raise ImportError(\"\\n\".join(errors)) from error\n    return value\n</code></pre>"},{"location":"reference/griffe/importer/#griffe.importer.sys_path","title":"sys_path","text":"<pre><code>sys_path(*paths: str | Path) -&gt; Iterator[None]\n</code></pre> <p>Redefine <code>sys.path</code> temporarily.</p> <p>Parameters:</p> <ul> <li> *paths             (<code>str | Path</code>, default:                 <code>()</code> )         \u2013          <p>The paths to use when importing modules. If no paths are given, keep <code>sys.path</code> untouched.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>Iterator[None]</code>         \u2013          <p>Nothing.</p> </li> </ul> Source code in <code>src/griffe/importer.py</code> <pre><code>@contextmanager\ndef sys_path(*paths: str | Path) -&gt; Iterator[None]:\n\"\"\"Redefine `sys.path` temporarily.\n\n    Parameters:\n        *paths: The paths to use when importing modules.\n            If no paths are given, keep `sys.path` untouched.\n\n    Yields:\n        Nothing.\n    \"\"\"\n    if not paths:\n        yield\n        return\n    old_path = sys.path\n    sys.path = [str(path) for path in paths]\n    try:\n        yield\n    finally:\n        sys.path = old_path\n</code></pre>"},{"location":"reference/griffe/loader/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> loader","text":""},{"location":"reference/griffe/loader/#griffe.loader","title":"loader","text":"<p>This module contains the code allowing to load modules data.</p> <p>This is the entrypoint to use griffe programatically:</p> <pre><code>from griffe.loader import GriffeLoader\n\ngriffe = GriffeLoader()\nfastapi = griffe.load_module(\"fastapi\")\n</code></pre> <p>Classes:</p> <ul> <li> GriffeLoader         \u2013          <p>The Griffe loader, allowing to load data from modules.</p> </li> </ul> <p>Functions:</p> <ul> <li> load           \u2013            <p>Load and return a module.</p> </li> </ul>"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader","title":"GriffeLoader","text":"<pre><code>GriffeLoader(\n    *,\n    extensions: Extensions | None = None,\n    search_paths: Sequence[str | Path] | None = None,\n    docstring_parser: Parser | None = None,\n    docstring_options: dict[str, Any] | None = None,\n    lines_collection: LinesCollection | None = None,\n    modules_collection: ModulesCollection | None = None,\n    allow_inspection: bool = True,\n    store_source: bool = True\n)\n</code></pre> <p>The Griffe loader, allowing to load data from modules.</p> <p>Parameters:</p> <ul> <li> extensions             (<code>Extensions | None</code>, default:                 <code>None</code> )         \u2013          <p>The extensions to use.</p> </li> <li> search_paths             (<code>Sequence[str | Path] | None</code>, default:                 <code>None</code> )         \u2013          <p>The paths to search into.</p> </li> <li> docstring_parser             (<code>Parser | None</code>, default:                 <code>None</code> )         \u2013          <p>The docstring parser to use. By default, no parsing is done.</p> </li> <li> docstring_options             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional docstring parsing options.</p> </li> <li> lines_collection             (<code>LinesCollection | None</code>, default:                 <code>None</code> )         \u2013          <p>A collection of source code lines.</p> </li> <li> modules_collection             (<code>ModulesCollection | None</code>, default:                 <code>None</code> )         \u2013          <p>A collection of modules.</p> </li> <li> allow_inspection             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to allow inspecting modules when visiting them is not possible.</p> </li> </ul> <p>Methods:</p> <ul> <li> expand_exports           \u2013            <p>Expand exports: try to recursively expand all module exports.</p> </li> <li> expand_wildcards           \u2013            <p>Expand wildcards: try to recursively expand all found wildcards.</p> </li> <li> load_module           \u2013            <p>Load a module.</p> </li> <li> resolve_aliases           \u2013            <p>Resolve aliases.</p> </li> <li> resolve_module_aliases           \u2013            <p>Follow aliases: try to recursively resolve all found aliases.</p> </li> <li> stats           \u2013            <p>Compute some statistics.</p> </li> </ul> Source code in <code>src/griffe/loader.py</code> <pre><code>def __init__(\n    self,\n    *,\n    extensions: Extensions | None = None,\n    search_paths: Sequence[str | Path] | None = None,\n    docstring_parser: Parser | None = None,\n    docstring_options: dict[str, Any] | None = None,\n    lines_collection: LinesCollection | None = None,\n    modules_collection: ModulesCollection | None = None,\n    allow_inspection: bool = True,\n    store_source: bool = True,\n) -&gt; None:\n\"\"\"Initialize the loader.\n\n    Parameters:\n        extensions: The extensions to use.\n        search_paths: The paths to search into.\n        docstring_parser: The docstring parser to use. By default, no parsing is done.\n        docstring_options: Additional docstring parsing options.\n        lines_collection: A collection of source code lines.\n        modules_collection: A collection of modules.\n        allow_inspection: Whether to allow inspecting modules when visiting them is not possible.\n    \"\"\"\n    self.extensions: Extensions = extensions or Extensions()\n    self.docstring_parser: Parser | None = docstring_parser\n    self.docstring_options: dict[str, Any] = docstring_options or {}\n    self.lines_collection: LinesCollection = lines_collection or LinesCollection()\n    self.modules_collection: ModulesCollection = modules_collection or ModulesCollection()\n    self.allow_inspection: bool = allow_inspection\n    self.store_source: bool = store_source\n    self.finder: ModuleFinder = ModuleFinder(search_paths)\n    self._time_stats: dict = {\n        \"time_spent_visiting\": 0,\n        \"time_spent_inspecting\": 0,\n    }\n</code></pre>"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader.expand_exports","title":"expand_exports","text":"<pre><code>expand_exports(\n    module: Module, seen: set | None = None\n) -&gt; None\n</code></pre> <p>Expand exports: try to recursively expand all module exports.</p> <p>Parameters:</p> <ul> <li> module             (<code>Module</code>)         \u2013          <p>The module to recurse on.</p> </li> <li> seen             (<code>set | None</code>, default:                 <code>None</code> )         \u2013          <p>Used to avoid infinite recursion.</p> </li> </ul> Source code in <code>src/griffe/loader.py</code> <pre><code>def expand_exports(self, module: Module, seen: set | None = None) -&gt; None:\n\"\"\"Expand exports: try to recursively expand all module exports.\n\n    Parameters:\n        module: The module to recurse on.\n        seen: Used to avoid infinite recursion.\n    \"\"\"\n    seen = seen or set()\n    seen.add(module.path)\n    if module.exports is None:\n        return\n    expanded = set()\n    for export in module.exports:\n        if isinstance(export, ExprName):\n            module_path = export.canonical_path.rsplit(\".\", 1)[0]  # remove trailing .__all__\n            try:\n                next_module = self.modules_collection.get_member(module_path)\n            except KeyError:\n                logger.debug(f\"Cannot expand '{export.canonical_path}', try pre-loading corresponding package\")\n                continue\n            if next_module.path not in seen:\n                self.expand_exports(next_module, seen)\n                try:\n                    expanded |= next_module.exports\n                except TypeError:\n                    logger.warning(f\"Unsupported item in {module.path}.__all__: {export} (use strings only)\")\n        else:\n            expanded.add(export)\n    module.exports = expanded\n</code></pre>"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader.expand_wildcards","title":"expand_wildcards","text":"<pre><code>expand_wildcards(\n    obj: Object,\n    *,\n    external: bool = False,\n    seen: set | None = None\n) -&gt; None\n</code></pre> <p>Expand wildcards: try to recursively expand all found wildcards.</p> <p>Parameters:</p> <ul> <li> obj             (<code>Object</code>)         \u2013          <p>The object and its members to recurse on.</p> </li> <li> external             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>When true, try to load unspecified modules to expand wildcards.</p> </li> <li> seen             (<code>set | None</code>, default:                 <code>None</code> )         \u2013          <p>Used to avoid infinite recursion.</p> </li> </ul> Source code in <code>src/griffe/loader.py</code> <pre><code>def expand_wildcards(\n    self,\n    obj: Object,\n    *,\n    external: bool = False,\n    seen: set | None = None,\n) -&gt; None:\n\"\"\"Expand wildcards: try to recursively expand all found wildcards.\n\n    Parameters:\n        obj: The object and its members to recurse on.\n        external: When true, try to load unspecified modules to expand wildcards.\n        seen: Used to avoid infinite recursion.\n    \"\"\"\n    expanded = []\n    to_remove = []\n    seen = seen or set()\n    seen.add(obj.path)\n\n    for member in obj.members.values():\n        if member.is_alias and member.wildcard:  # type: ignore[union-attr]  # we know it's an alias\n            package = member.wildcard.split(\".\", 1)[0]  # type: ignore[union-attr]\n            not_loaded = obj.package.path != package and package not in self.modules_collection\n            if not_loaded:\n                if not external:\n                    continue\n                try:\n                    self.load_module(package, try_relative_path=False)\n                except ImportError as error:\n                    logger.debug(f\"Could not expand wildcard import {member.name} in {obj.path}: {error}\")\n                    continue\n            try:\n                target = self.modules_collection.get_member(member.target_path)  # type: ignore[union-attr]\n            except KeyError:\n                logger.debug(\n                    f\"Could not expand wildcard import {member.name} in {obj.path}: \"\n                    f\"{cast(Alias, member).target_path} not found in modules collection\",\n                )\n                continue\n            if target.path not in seen:\n                try:\n                    self.expand_wildcards(target, external=external, seen=seen)\n                except (AliasResolutionError, CyclicAliasError) as error:\n                    logger.debug(f\"Could not expand wildcard import {member.name} in {obj.path}: {error}\")\n                    continue\n            expanded.extend(self._expand_wildcard(member))  # type: ignore[arg-type]\n            to_remove.append(member.name)\n        elif not member.is_alias and member.is_module and member.path not in seen:\n            self.expand_wildcards(member, external=external, seen=seen)  # type: ignore[arg-type]\n\n    for name in to_remove:\n        obj.del_member(name)\n\n    for new_member, alias_lineno, alias_endlineno in expanded:\n        overwrite = False\n        already_present = new_member.name in obj.members\n        self_alias = new_member.is_alias and cast(Alias, new_member).target_path == f\"{obj.path}.{new_member.name}\"\n        if already_present:\n            old_member = obj.get_member(new_member.name)\n            old_lineno = old_member.alias_lineno if old_member.is_alias else old_member.lineno\n            overwrite = alias_lineno &gt; (old_lineno or 0)  # type: ignore[operator]\n        if not self_alias and (not already_present or overwrite):\n            alias = Alias(\n                new_member.name,\n                new_member,\n                lineno=alias_lineno,\n                endlineno=alias_endlineno,\n                parent=obj,  # type: ignore[arg-type]\n            )\n            if already_present:\n                prev_member = obj.get_member(new_member.name)\n                with suppress(AliasResolutionError, CyclicAliasError):\n                    if prev_member.is_module:\n                        if prev_member.is_alias:\n                            prev_member = prev_member.final_target\n                        if alias.final_target is prev_member:\n                            # alias named after the module it targets:\n                            # skip to avoid cyclic aliases\n                            continue\n            obj.set_member(new_member.name, alias)\n</code></pre>"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader.load_module","title":"load_module","text":"<pre><code>load_module(\n    module: str | Path,\n    *,\n    submodules: bool = True,\n    try_relative_path: bool = True\n) -&gt; Module\n</code></pre> <p>Load a module.</p> <p>Parameters:</p> <ul> <li> module             (<code>str | Path</code>)         \u2013          <p>The module name or path.</p> </li> <li> submodules             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to recurse on the submodules.</p> </li> <li> try_relative_path             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to try finding the module as a relative path.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>LoadingError</code>           \u2013          <p>When loading a module failed for various reasons.</p> </li> <li> <code>ModuleNotFoundError</code>           \u2013          <p>When a module was not found and inspection is disallowed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013          <p>A module.</p> </li> </ul> Source code in <code>src/griffe/loader.py</code> <pre><code>def load_module(\n    self,\n    module: str | Path,\n    *,\n    submodules: bool = True,\n    try_relative_path: bool = True,\n) -&gt; Module:\n\"\"\"Load a module.\n\n    Parameters:\n        module: The module name or path.\n        submodules: Whether to recurse on the submodules.\n        try_relative_path: Whether to try finding the module as a relative path.\n\n    Raises:\n        LoadingError: When loading a module failed for various reasons.\n        ModuleNotFoundError: When a module was not found and inspection is disallowed.\n\n    Returns:\n        A module.\n    \"\"\"\n    module_name: str\n    if module in _builtin_modules:\n        logger.debug(f\"{module} is a builtin module\")\n        if self.allow_inspection:\n            logger.debug(f\"Inspecting {module}\")\n            module_name = module  # type: ignore[assignment]\n            top_module = self._inspect_module(module)  # type: ignore[arg-type]\n            self.modules_collection.set_member(top_module.path, top_module)\n            return self.modules_collection.get_member(module_name)\n        raise LoadingError(\"Cannot load builtin module without inspection\")\n    try:\n        module_name, package = self.finder.find_spec(module, try_relative_path=try_relative_path)\n    except ModuleNotFoundError:\n        logger.debug(f\"Could not find {module}\")\n        if self.allow_inspection:\n            logger.debug(f\"Trying inspection on {module}\")\n            module_name = module  # type: ignore[assignment]\n            top_module = self._inspect_module(module)  # type: ignore[arg-type]\n            self.modules_collection.set_member(top_module.path, top_module)\n        else:\n            raise\n    else:\n        logger.debug(f\"Found {module}: loading\")\n        try:\n            top_module = self._load_package(package, submodules=submodules)\n        except LoadingError as error:\n            logger.exception(str(error))  # noqa: TRY401\n            raise\n    return self.modules_collection.get_member(module_name)\n</code></pre>"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader.resolve_aliases","title":"resolve_aliases","text":"<pre><code>resolve_aliases(\n    *,\n    implicit: bool = False,\n    external: bool = False,\n    max_iterations: int | None = None\n) -&gt; tuple[set[str], int]\n</code></pre> <p>Resolve aliases.</p> <p>Parameters:</p> <ul> <li> implicit             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>When false, only try to resolve an alias if it is explicitely exported.</p> </li> <li> external             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>When false, don't try to load unspecified modules to resolve aliases.</p> </li> <li> max_iterations             (<code>int | None</code>, default:                 <code>None</code> )         \u2013          <p>Maximum number of iterations on the loader modules collection.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[set[str], int]</code>         \u2013          <p>The unresolved aliases and the number of iterations done.</p> </li> </ul> Source code in <code>src/griffe/loader.py</code> <pre><code>def resolve_aliases(\n    self,\n    *,\n    implicit: bool = False,\n    external: bool = False,\n    max_iterations: int | None = None,\n) -&gt; tuple[set[str], int]:\n\"\"\"Resolve aliases.\n\n    Parameters:\n        implicit: When false, only try to resolve an alias if it is explicitely exported.\n        external: When false, don't try to load unspecified modules to resolve aliases.\n        max_iterations: Maximum number of iterations on the loader modules collection.\n\n    Returns:\n        The unresolved aliases and the number of iterations done.\n    \"\"\"\n    if max_iterations is None:\n        max_iterations = float(\"inf\")  # type: ignore[assignment]\n    prev_unresolved: set[str] = set()\n    unresolved: set[str] = set(\"0\")  # init to enter loop\n    iteration = 0\n    collection = self.modules_collection.members\n    for exports_module in list(collection.values()):\n        self.expand_exports(exports_module)\n    for wildcards_module in list(collection.values()):\n        self.expand_wildcards(wildcards_module, external=external)\n    load_failures: set[str] = set()\n    while unresolved and unresolved != prev_unresolved and iteration &lt; max_iterations:  # type: ignore[operator]\n        prev_unresolved = unresolved - {\"0\"}\n        unresolved = set()\n        resolved: set[str] = set()\n        iteration += 1\n        for module_name in list(collection.keys()):\n            module = collection[module_name]\n            next_resolved, next_unresolved = self.resolve_module_aliases(\n                module,\n                implicit=implicit,\n                external=external,\n                load_failures=load_failures,\n            )\n            resolved |= next_resolved\n            unresolved |= next_unresolved\n        logger.debug(\n            f\"Iteration {iteration} finished, {len(resolved)} aliases resolved, still {len(unresolved)} to go\",\n        )\n    return unresolved, iteration\n</code></pre>"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader.resolve_module_aliases","title":"resolve_module_aliases","text":"<pre><code>resolve_module_aliases(\n    obj: Object | Alias,\n    *,\n    implicit: bool = False,\n    external: bool = False,\n    seen: set[str] | None = None,\n    load_failures: set[str] | None = None\n) -&gt; tuple[set[str], set[str]]\n</code></pre> <p>Follow aliases: try to recursively resolve all found aliases.</p> <p>Parameters:</p> <ul> <li> obj             (<code>Object | Alias</code>)         \u2013          <p>The object and its members to recurse on.</p> </li> <li> implicit             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>When false, only try to resolve an alias if it is explicitely exported.</p> </li> <li> external             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>When false, don't try to load unspecified modules to resolve aliases.</p> </li> <li> seen             (<code>set[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Used to avoid infinite recursion.</p> </li> <li> load_failures             (<code>set[str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Set of external packages we failed to load (to prevent retries).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[set[str], set[str]]</code>         \u2013          <p>Both sets of resolved and unresolved aliases.</p> </li> </ul> Source code in <code>src/griffe/loader.py</code> <pre><code>def resolve_module_aliases(\n    self,\n    obj: Object | Alias,\n    *,\n    implicit: bool = False,\n    external: bool = False,\n    seen: set[str] | None = None,\n    load_failures: set[str] | None = None,\n) -&gt; tuple[set[str], set[str]]:\n\"\"\"Follow aliases: try to recursively resolve all found aliases.\n\n    Parameters:\n        obj: The object and its members to recurse on.\n        implicit: When false, only try to resolve an alias if it is explicitely exported.\n        external: When false, don't try to load unspecified modules to resolve aliases.\n        seen: Used to avoid infinite recursion.\n        load_failures: Set of external packages we failed to load (to prevent retries).\n\n    Returns:\n        Both sets of resolved and unresolved aliases.\n    \"\"\"\n    resolved = set()\n    unresolved = set()\n    if load_failures is None:\n        load_failures = set()\n    seen = seen or set()\n    seen.add(obj.path)\n\n    for member in obj.members.values():\n        if member.is_alias:\n            if member.wildcard or member.resolved:  # type: ignore[union-attr]\n                continue\n            if not implicit and not member.is_explicitely_exported:\n                continue\n            try:\n                member.resolve_target()  # type: ignore[union-attr]\n            except AliasResolutionError as error:\n                target = error.alias.target_path\n                unresolved.add(member.path)\n                package = target.split(\".\", 1)[0]\n                load_module = (\n                    external\n                    and package not in load_failures\n                    and obj.package.path != package\n                    and package not in self.modules_collection\n                )\n                if load_module:\n                    logger.debug(f\"Failed to resolve alias {member.path} -&gt; {target}\")\n                    try:\n                        self.load_module(package, try_relative_path=False)\n                    except ImportError as error:\n                        logger.debug(f\"Could not follow alias {member.path}: {error}\")\n                        load_failures.add(package)\n            except CyclicAliasError as error:\n                logger.debug(str(error))\n            else:\n                logger.debug(f\"Alias {member.path} was resolved to {member.final_target.path}\")  # type: ignore[union-attr]\n                resolved.add(member.path)\n        elif member.kind in {Kind.MODULE, Kind.CLASS} and member.path not in seen:\n            sub_resolved, sub_unresolved = self.resolve_module_aliases(\n                member,\n                implicit=implicit,\n                external=external,\n                seen=seen,\n                load_failures=load_failures,\n            )\n            resolved |= sub_resolved\n            unresolved |= sub_unresolved\n\n    return resolved, unresolved\n</code></pre>"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader.stats","title":"stats","text":"<pre><code>stats() -&gt; dict\n</code></pre> <p>Compute some statistics.</p> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Some statistics.</p> </li> </ul> Source code in <code>src/griffe/loader.py</code> <pre><code>def stats(self) -&gt; dict:\n\"\"\"Compute some statistics.\n\n    Returns:\n        Some statistics.\n    \"\"\"\n    return {**stats(self), **self._time_stats}\n</code></pre>"},{"location":"reference/griffe/loader/#griffe.loader.load","title":"load","text":"<pre><code>load(\n    module: str | Path,\n    *,\n    submodules: bool = True,\n    try_relative_path: bool = True,\n    extensions: Extensions | None = None,\n    search_paths: Sequence[str | Path] | None = None,\n    docstring_parser: Parser | None = None,\n    docstring_options: dict[str, Any] | None = None,\n    lines_collection: LinesCollection | None = None,\n    modules_collection: ModulesCollection | None = None,\n    allow_inspection: bool = True\n) -&gt; Module\n</code></pre> <p>Load and return a module.</p> <p>Example: <pre><code>import griffe\n\nmodule = griffe.load(...)\n</code></pre></p> <p>This is a shortcut for:</p> <pre><code>from griffe.loader import GriffeLoader\n\nloader = GriffeLoader(...)\nmodule = loader.load_module(...)\n</code></pre> <p>See the documentation for the loader: <code>GriffeLoader</code>.</p> <p>Parameters:</p> <ul> <li> module             (<code>str | Path</code>)         \u2013          <p>The module name or path.</p> </li> <li> submodules             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to recurse on the submodules.</p> </li> <li> try_relative_path             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to try finding the module as a relative path.</p> </li> <li> extensions             (<code>Extensions | None</code>, default:                 <code>None</code> )         \u2013          <p>The extensions to use.</p> </li> <li> search_paths             (<code>Sequence[str | Path] | None</code>, default:                 <code>None</code> )         \u2013          <p>The paths to search into.</p> </li> <li> docstring_parser             (<code>Parser | None</code>, default:                 <code>None</code> )         \u2013          <p>The docstring parser to use. By default, no parsing is done.</p> </li> <li> docstring_options             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional docstring parsing options.</p> </li> <li> lines_collection             (<code>LinesCollection | None</code>, default:                 <code>None</code> )         \u2013          <p>A collection of source code lines.</p> </li> <li> modules_collection             (<code>ModulesCollection | None</code>, default:                 <code>None</code> )         \u2013          <p>A collection of modules.</p> </li> <li> allow_inspection             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to allow inspecting modules when visiting them is not possible.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013          <p>A loaded module.</p> </li> </ul> Source code in <code>src/griffe/loader.py</code> <pre><code>def load(\n    module: str | Path,\n    *,\n    submodules: bool = True,\n    try_relative_path: bool = True,\n    extensions: Extensions | None = None,\n    search_paths: Sequence[str | Path] | None = None,\n    docstring_parser: Parser | None = None,\n    docstring_options: dict[str, Any] | None = None,\n    lines_collection: LinesCollection | None = None,\n    modules_collection: ModulesCollection | None = None,\n    allow_inspection: bool = True,\n) -&gt; Module:\n\"\"\"Load and return a module.\n\n    Example:\n    ```python\n    import griffe\n\n    module = griffe.load(...)\n    ```\n\n    This is a shortcut for:\n\n    ```python\n    from griffe.loader import GriffeLoader\n\n    loader = GriffeLoader(...)\n    module = loader.load_module(...)\n    ```\n\n    See the documentation for the loader: [`GriffeLoader`][griffe.loader.GriffeLoader].\n\n    Parameters:\n        module: The module name or path.\n        submodules: Whether to recurse on the submodules.\n        try_relative_path: Whether to try finding the module as a relative path.\n        extensions: The extensions to use.\n        search_paths: The paths to search into.\n        docstring_parser: The docstring parser to use. By default, no parsing is done.\n        docstring_options: Additional docstring parsing options.\n        lines_collection: A collection of source code lines.\n        modules_collection: A collection of modules.\n        allow_inspection: Whether to allow inspecting modules when visiting them is not possible.\n\n    Returns:\n        A loaded module.\n    \"\"\"\n    return GriffeLoader(\n        extensions=extensions,\n        search_paths=search_paths,\n        docstring_parser=docstring_parser,\n        docstring_options=docstring_options,\n        lines_collection=lines_collection,\n        modules_collection=modules_collection,\n        allow_inspection=allow_inspection,\n    ).load_module(\n        module=module,\n        submodules=submodules,\n        try_relative_path=try_relative_path,\n    )\n</code></pre>"},{"location":"reference/griffe/logger/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> logger","text":""},{"location":"reference/griffe/logger/#griffe.logger","title":"logger","text":"<p>This module contains logging utilities.</p> <p>We provide the <code>patch_loggers</code> function so dependant libraries can patch loggers as they see fit.</p> <p>For example, to fit in the MkDocs logging configuration and prefix each log message with the module name:</p> <pre><code>import logging\nfrom griffe.logger import patch_loggers\n\n\nclass LoggerAdapter(logging.LoggerAdapter):\n    def __init__(self, prefix, logger):\n        super().__init__(logger, {})\n        self.prefix = prefix\n\n    def process(self, msg, kwargs):\n        return f\"{self.prefix}: {msg}\", kwargs\n\n\ndef get_logger(name):\n    logger = logging.getLogger(f\"mkdocs.plugins.{name}\")\n    return LoggerAdapter(name, logger)\n\n\npatch_loggers(get_logger)\n</code></pre> <p>Classes:</p> <ul> <li> LogLevel         \u2013          <p>Enumeration of available log levels.</p> </li> </ul> <p>Functions:</p> <ul> <li> get_logger           \u2013            <p>Create and return a new logger instance.</p> </li> <li> patch_loggers           \u2013            <p>Patch loggers.</p> </li> </ul>"},{"location":"reference/griffe/logger/#griffe.logger.LogLevel","title":"LogLevel","text":"<p>             Bases: <code>Enum</code></p> <p>Enumeration of available log levels.</p>"},{"location":"reference/griffe/logger/#griffe.logger.get_logger","title":"get_logger","text":"<pre><code>get_logger(name: str) -&gt; _Logger\n</code></pre> <p>Create and return a new logger instance.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013          <p>The logger name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_Logger</code>         \u2013          <p>The logger.</p> </li> </ul> Source code in <code>src/griffe/logger.py</code> <pre><code>def get_logger(name: str) -&gt; _Logger:\n\"\"\"Create and return a new logger instance.\n\n    Parameters:\n        name: The logger name.\n\n    Returns:\n        The logger.\n    \"\"\"\n    return _Logger(name)\n</code></pre>"},{"location":"reference/griffe/logger/#griffe.logger.patch_loggers","title":"patch_loggers","text":"<pre><code>patch_loggers(\n    get_logger_func: Callable[[str], Any]\n) -&gt; None\n</code></pre> <p>Patch loggers.</p> <p>Parameters:</p> <ul> <li> get_logger_func             (<code>Callable[[str], Any]</code>)         \u2013          <p>A function accepting a name as parameter and returning a logger.</p> </li> </ul> Source code in <code>src/griffe/logger.py</code> <pre><code>def patch_loggers(get_logger_func: Callable[[str], Any]) -&gt; None:\n\"\"\"Patch loggers.\n\n    Parameters:\n        get_logger_func: A function accepting a name as parameter and returning a logger.\n    \"\"\"\n    _Logger._patch_loggers(get_logger_func)\n</code></pre>"},{"location":"reference/griffe/merger/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> merger","text":""},{"location":"reference/griffe/merger/#griffe.merger","title":"merger","text":"<p>This module contains utilities to merge data together.</p> <p>Functions:</p> <ul> <li> merge_stubs           \u2013            <p>Merge stubs into a module.</p> </li> </ul>"},{"location":"reference/griffe/merger/#griffe.merger.merge_stubs","title":"merge_stubs","text":"<pre><code>merge_stubs(mod1: Module, mod2: Module) -&gt; Module\n</code></pre> <p>Merge stubs into a module.</p> <p>Parameters:</p> <ul> <li> mod1             (<code>Module</code>)         \u2013          <p>A regular module or stubs module.</p> </li> <li> mod2             (<code>Module</code>)         \u2013          <p>A regular module or stubs module.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When both modules are regular modules (no stubs is passed).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013          <p>The regular module.</p> </li> </ul> Source code in <code>src/griffe/merger.py</code> <pre><code>def merge_stubs(mod1: Module, mod2: Module) -&gt; Module:\n\"\"\"Merge stubs into a module.\n\n    Parameters:\n        mod1: A regular module or stubs module.\n        mod2: A regular module or stubs module.\n\n    Raises:\n        ValueError: When both modules are regular modules (no stubs is passed).\n\n    Returns:\n        The regular module.\n    \"\"\"\n    logger.debug(f\"Trying to merge {mod1.filepath} and {mod2.filepath}\")\n    if mod1.filepath.suffix == \".pyi\":  # type: ignore[union-attr]\n        stubs = mod1\n        module = mod2\n    elif mod2.filepath.suffix == \".pyi\":  # type: ignore[union-attr]\n        stubs = mod2\n        module = mod1\n    else:\n        raise ValueError(\"cannot merge regular (non-stubs) modules together\")\n    _merge_module_stubs(module, stubs)\n    return module\n</code></pre>"},{"location":"reference/griffe/mixins/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> mixins","text":""},{"location":"reference/griffe/mixins/#griffe.mixins","title":"mixins","text":"<p>This module contains some mixins classes about accessing and setting members.</p> <p>Classes:</p> <ul> <li> DelMembersMixin         \u2013          <p>Mixin class to share methods for deleting members.</p> </li> <li> GetMembersMixin         \u2013          <p>Mixin class to share methods for accessing members.</p> </li> <li> ObjectAliasMixin         \u2013          <p>A mixin for methods that appear both in objects and aliases, unchanged.</p> </li> <li> SerializationMixin         \u2013          <p>A mixin that adds de/serialization conveniences.</p> </li> <li> SetMembersMixin         \u2013          <p>Mixin class to share methods for setting members.</p> </li> </ul>"},{"location":"reference/griffe/mixins/#griffe.mixins.DelMembersMixin","title":"DelMembersMixin","text":"<p>Mixin class to share methods for deleting members.</p> <p>Methods:</p> <ul> <li> __delitem__           \u2013            <p>Delete a member with its name or path.</p> </li> <li> del_member           \u2013            <p>Delete a member with its name or path.</p> </li> </ul>"},{"location":"reference/griffe/mixins/#griffe.mixins.DelMembersMixin.__delitem__","title":"__delitem__","text":"<pre><code>__delitem__(key: str | Sequence[str]) -&gt; None\n</code></pre> <p>Delete a member with its name or path.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Members will be looked up in both declared members and inherited ones, triggering computation of the latter.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; del griffe_object[\"foo\"]\n&gt;&gt;&gt; del griffe_object[\"path.to.bar\"]\n&gt;&gt;&gt; del griffe_object[(\"path\", \"to\", \"qux\")]\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def __delitem__(self, key: str | Sequence[str]) -&gt; None:\n\"\"\"Delete a member with its name or path.\n\n    This method is part of the consumer API:\n    do not use when producing Griffe trees!\n\n    Members will be looked up in both declared members and inherited ones,\n    triggering computation of the latter.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; del griffe_object[\"foo\"]\n        &gt;&gt;&gt; del griffe_object[\"path.to.bar\"]\n        &gt;&gt;&gt; del griffe_object[(\"path\", \"to\", \"qux\")]\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        try:\n            del self.members[name]  # type: ignore[attr-defined]\n        except KeyError:\n            del self.inherited_members[name]  # type: ignore[attr-defined]\n    else:\n        del self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/mixins/#griffe.mixins.DelMembersMixin.del_member","title":"del_member","text":"<pre><code>del_member(key: str | Sequence[str]) -&gt; None\n</code></pre> <p>Delete a member with its name or path.</p> <p>This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).</p> <p>Members will be looked up in declared members only, not inherited ones.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; griffe_object.del_member(\"foo\")\n&gt;&gt;&gt; griffe_object.del_member(\"path.to.bar\")\n&gt;&gt;&gt; griffe_object.del_member((\"path\", \"to\", \"qux\"))\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def del_member(self, key: str | Sequence[str]) -&gt; None:\n\"\"\"Delete a member with its name or path.\n\n    This method is part of the producer API:\n    you can use it safely while building Griffe trees\n    (for example in Griffe extensions).\n\n    Members will be looked up in declared members only, not inherited ones.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; griffe_object.del_member(\"foo\")\n        &gt;&gt;&gt; griffe_object.del_member(\"path.to.bar\")\n        &gt;&gt;&gt; griffe_object.del_member((\"path\", \"to\", \"qux\"))\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        del self.members[name]  # type: ignore[attr-defined]\n    else:\n        self.members[parts[0]].del_member(parts[1:])  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/mixins/#griffe.mixins.GetMembersMixin","title":"GetMembersMixin","text":"<p>Mixin class to share methods for accessing members.</p> <p>Methods:</p> <ul> <li> __getitem__           \u2013            <p>Get a member with its name or path.</p> </li> <li> get_member           \u2013            <p>Get a member with its name or path.</p> </li> </ul>"},{"location":"reference/griffe/mixins/#griffe.mixins.GetMembersMixin.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key: str | Sequence[str]) -&gt; Any\n</code></pre> <p>Get a member with its name or path.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Members will be looked up in both declared members and inherited ones, triggering computation of the latter.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; foo = griffe_object[\"foo\"]\n&gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n&gt;&gt;&gt; qux = griffe_object[(\"path\", \"to\", \"qux\")]\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def __getitem__(self, key: str | Sequence[str]) -&gt; Any:\n\"\"\"Get a member with its name or path.\n\n    This method is part of the consumer API:\n    do not use when producing Griffe trees!\n\n    Members will be looked up in both declared members and inherited ones,\n    triggering computation of the latter.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; foo = griffe_object[\"foo\"]\n        &gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n        &gt;&gt;&gt; qux = griffe_object[(\"path\", \"to\", \"qux\")]\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        return self.all_members[parts[0]]  # type: ignore[attr-defined]\n    return self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/mixins/#griffe.mixins.GetMembersMixin.get_member","title":"get_member","text":"<pre><code>get_member(key: str | Sequence[str]) -&gt; Any\n</code></pre> <p>Get a member with its name or path.</p> <p>This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).</p> <p>Members will be looked up in declared members only, not inherited ones.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; foo = griffe_object[\"foo\"]\n&gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n&gt;&gt;&gt; bar = griffe_object[(\"path\", \"to\", \"bar\")]\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def get_member(self, key: str | Sequence[str]) -&gt; Any:\n\"\"\"Get a member with its name or path.\n\n    This method is part of the producer API:\n    you can use it safely while building Griffe trees\n    (for example in Griffe extensions).\n\n    Members will be looked up in declared members only, not inherited ones.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; foo = griffe_object[\"foo\"]\n        &gt;&gt;&gt; bar = griffe_object[\"path.to.bar\"]\n        &gt;&gt;&gt; bar = griffe_object[(\"path\", \"to\", \"bar\")]\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        return self.members[parts[0]]  # type: ignore[attr-defined]\n    return self.members[parts[0]].get_member(parts[1:])  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/mixins/#griffe.mixins.ObjectAliasMixin","title":"ObjectAliasMixin","text":"<p>A mixin for methods that appear both in objects and aliases, unchanged.</p> <p>Methods:</p> <ul> <li> is_exported           \u2013            <p>Tell if this object/alias is implicitely exported by its parent.</p> </li> <li> is_public           \u2013            <p>Whether this object is considered public.</p> </li> </ul> <p>Attributes:</p> <ul> <li> all_members             (<code>dict[str, Object | Alias]</code>)         \u2013          <p>All members (declared and inherited).</p> </li> <li> attributes             (<code>dict[str, Attribute]</code>)         \u2013          <p>Return the attribute members.</p> </li> <li> classes             (<code>dict[str, Class]</code>)         \u2013          <p>Return the class members.</p> </li> <li> functions             (<code>dict[str, Function]</code>)         \u2013          <p>Return the function members.</p> </li> <li> is_explicitely_exported             (<code>bool</code>)         \u2013          <p>Tell if this object/alias is explicitely exported by its parent.</p> </li> <li> is_implicitely_exported             (<code>bool</code>)         \u2013          <p>Tell if this object/alias is implicitely exported by its parent.</p> </li> <li> modules             (<code>dict[str, Module]</code>)         \u2013          <p>Return the module members.</p> </li> </ul>"},{"location":"reference/griffe/mixins/#griffe.mixins.ObjectAliasMixin.all_members","title":"all_members  <code>property</code>","text":"<pre><code>all_members: dict[str, Object | Alias]\n</code></pre> <p>All members (declared and inherited).</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p>"},{"location":"reference/griffe/mixins/#griffe.mixins.ObjectAliasMixin.attributes","title":"attributes  <code>property</code>","text":"<pre><code>attributes: dict[str, Attribute]\n</code></pre> <p>Return the attribute members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Attribute]</code>         \u2013          <p>A dictionary of attributes.</p> </li> </ul>"},{"location":"reference/griffe/mixins/#griffe.mixins.ObjectAliasMixin.classes","title":"classes  <code>property</code>","text":"<pre><code>classes: dict[str, Class]\n</code></pre> <p>Return the class members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Class]</code>         \u2013          <p>A dictionary of classes.</p> </li> </ul>"},{"location":"reference/griffe/mixins/#griffe.mixins.ObjectAliasMixin.functions","title":"functions  <code>property</code>","text":"<pre><code>functions: dict[str, Function]\n</code></pre> <p>Return the function members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Function]</code>         \u2013          <p>A dictionary of functions.</p> </li> </ul>"},{"location":"reference/griffe/mixins/#griffe.mixins.ObjectAliasMixin.is_explicitely_exported","title":"is_explicitely_exported  <code>property</code>","text":"<pre><code>is_explicitely_exported: bool\n</code></pre> <p>Tell if this object/alias is explicitely exported by its parent.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/mixins/#griffe.mixins.ObjectAliasMixin.is_implicitely_exported","title":"is_implicitely_exported  <code>property</code>","text":"<pre><code>is_implicitely_exported: bool\n</code></pre> <p>Tell if this object/alias is implicitely exported by its parent.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/mixins/#griffe.mixins.ObjectAliasMixin.modules","title":"modules  <code>property</code>","text":"<pre><code>modules: dict[str, Module]\n</code></pre> <p>Return the module members.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Returns:</p> <ul> <li> <code>dict[str, Module]</code>         \u2013          <p>A dictionary of modules.</p> </li> </ul>"},{"location":"reference/griffe/mixins/#griffe.mixins.ObjectAliasMixin.is_exported","title":"is_exported","text":"<pre><code>is_exported(*, explicitely: bool = True) -&gt; bool\n</code></pre> <p>Tell if this object/alias is implicitely exported by its parent.</p> <p>Parameters:</p> <ul> <li> explicitely             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to only return True when <code>__all__</code> is defined.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>def is_exported(self, *, explicitely: bool = True) -&gt; bool:\n\"\"\"Tell if this object/alias is implicitely exported by its parent.\n\n    Parameters:\n        explicitely: Whether to only return True when `__all__` is defined.\n\n    Returns:\n        True or False.\n    \"\"\"\n    return self.parent.member_is_exported(self, explicitely=explicitely)  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/mixins/#griffe.mixins.ObjectAliasMixin.is_public","title":"is_public","text":"<pre><code>is_public(\n    *, strict: bool = False, check_name: bool = True\n) -&gt; bool\n</code></pre> <p>Whether this object is considered public.</p> <p>In modules, developers can mark objects as public thanks to the <code>__all__</code> variable. In classes however, there is no convention or standard to do so.</p> <p>Therefore, to decide whether an object is public, we follow this algorithm:</p> <ul> <li>If the object's <code>public</code> attribute is set (boolean), return its value.</li> <li>In strict mode, the object is public only if it is explicitely exported (listed in <code>__all__</code>).     Strict mode should only be used for module members.</li> <li>Otherwise, if name checks are enabled, the object is private if its name starts with an underscore.</li> <li>Otherwise, if the object is an alias, and is neither inherited from a base class,     nor a member of a parent alias, it is not public.</li> <li>Otherwise, the object is public.</li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>def is_public(\n    self,\n    *,\n    strict: bool = False,\n    check_name: bool = True,\n) -&gt; bool:\n\"\"\"Whether this object is considered public.\n\n    In modules, developers can mark objects as public thanks to the `__all__` variable.\n    In classes however, there is no convention or standard to do so.\n\n    Therefore, to decide whether an object is public, we follow this algorithm:\n\n    - If the object's `public` attribute is set (boolean), return its value.\n    - In strict mode, the object is public only if it is explicitely exported (listed in `__all__`).\n        Strict mode should only be used for module members.\n    - Otherwise, if name checks are enabled, the object is private if its name starts with an underscore.\n    - Otherwise, if the object is an alias, and is neither inherited from a base class,\n        nor a member of a parent alias, it is not public.\n    - Otherwise, the object is public.\n    \"\"\"\n    if self.public is not None:  # type: ignore[attr-defined]\n        return self.public  # type: ignore[attr-defined]\n    if self.is_explicitely_exported:\n        return True\n    if strict:\n        return False\n    if check_name and self.name.startswith(\"_\"):  # type: ignore[attr-defined]\n        return False\n    if self.is_alias and not (self.inherited or self.parent.is_alias):  # type: ignore[attr-defined]\n        return False\n    return True\n</code></pre>"},{"location":"reference/griffe/mixins/#griffe.mixins.SerializationMixin","title":"SerializationMixin","text":"<p>A mixin that adds de/serialization conveniences.</p> <p>Methods:</p> <ul> <li> as_json           \u2013            <p>Return this object's data as a JSON string.</p> </li> <li> from_json           \u2013            <p>Create an instance of this class from a JSON string.</p> </li> </ul>"},{"location":"reference/griffe/mixins/#griffe.mixins.SerializationMixin.as_json","title":"as_json","text":"<pre><code>as_json(*, full: bool = False, **kwargs: Any) -&gt; str\n</code></pre> <p>Return this object's data as a JSON string.</p> <p>Parameters:</p> <ul> <li> full             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to return full info, or just base info.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options passed to encoder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>A JSON string.</p> </li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>def as_json(self, *, full: bool = False, **kwargs: Any) -&gt; str:\n\"\"\"Return this object's data as a JSON string.\n\n    Parameters:\n        full: Whether to return full info, or just base info.\n        **kwargs: Additional serialization options passed to encoder.\n\n    Returns:\n        A JSON string.\n    \"\"\"\n    from griffe.encoders import JSONEncoder  # avoid circular import\n\n    return json.dumps(self, cls=JSONEncoder, full=full, **kwargs)\n</code></pre>"},{"location":"reference/griffe/mixins/#griffe.mixins.SerializationMixin.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_string: str, **kwargs: Any) -&gt; _ObjType\n</code></pre> <p>Create an instance of this class from a JSON string.</p> <p>Parameters:</p> <ul> <li> json_string             (<code>str</code>)         \u2013          <p>JSON to decode into Object.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional options passed to decoder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_ObjType</code>         \u2013          <p>An Object instance.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>           \u2013          <p>When the json_string does not represent and object of the class from which this classmethod has been called.</p> </li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>@classmethod\ndef from_json(cls: type[_ObjType], json_string: str, **kwargs: Any) -&gt; _ObjType:  # noqa: PYI019\n\"\"\"Create an instance of this class from a JSON string.\n\n    Parameters:\n        json_string: JSON to decode into Object.\n        **kwargs: Additional options passed to decoder.\n\n    Returns:\n        An Object instance.\n\n    Raises:\n        TypeError: When the json_string does not represent and object\n            of the class from which this classmethod has been called.\n    \"\"\"\n    from griffe.encoders import json_decoder  # avoid circular import\n\n    kwargs.setdefault(\"object_hook\", json_decoder)\n    obj = json.loads(json_string, **kwargs)\n    if not isinstance(obj, cls):\n        raise TypeError(f\"provided JSON object is not of type {cls}\")\n    return obj\n</code></pre>"},{"location":"reference/griffe/mixins/#griffe.mixins.SetMembersMixin","title":"SetMembersMixin","text":"<p>             Bases: <code>DelMembersMixin</code></p> <p>Mixin class to share methods for setting members.</p> <p>Methods:</p> <ul> <li> __delitem__           \u2013            <p>Delete a member with its name or path.</p> </li> <li> __setitem__           \u2013            <p>Set a member with its name or path.</p> </li> <li> del_member           \u2013            <p>Delete a member with its name or path.</p> </li> <li> set_member           \u2013            <p>Set a member with its name or path.</p> </li> </ul>"},{"location":"reference/griffe/mixins/#griffe.mixins.SetMembersMixin.__delitem__","title":"__delitem__","text":"<pre><code>__delitem__(key: str | Sequence[str]) -&gt; None\n</code></pre> <p>Delete a member with its name or path.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Members will be looked up in both declared members and inherited ones, triggering computation of the latter.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; del griffe_object[\"foo\"]\n&gt;&gt;&gt; del griffe_object[\"path.to.bar\"]\n&gt;&gt;&gt; del griffe_object[(\"path\", \"to\", \"qux\")]\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def __delitem__(self, key: str | Sequence[str]) -&gt; None:\n\"\"\"Delete a member with its name or path.\n\n    This method is part of the consumer API:\n    do not use when producing Griffe trees!\n\n    Members will be looked up in both declared members and inherited ones,\n    triggering computation of the latter.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; del griffe_object[\"foo\"]\n        &gt;&gt;&gt; del griffe_object[\"path.to.bar\"]\n        &gt;&gt;&gt; del griffe_object[(\"path\", \"to\", \"qux\")]\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        try:\n            del self.members[name]  # type: ignore[attr-defined]\n        except KeyError:\n            del self.inherited_members[name]  # type: ignore[attr-defined]\n    else:\n        del self.all_members[parts[0]][parts[1:]]  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/mixins/#griffe.mixins.SetMembersMixin.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(\n    key: str | Sequence[str], value: Object | Alias\n) -&gt; None\n</code></pre> <p>Set a member with its name or path.</p> <p>This method is part of the consumer API: do not use when producing Griffe trees!</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> <li> value             (<code>Object | Alias</code>)         \u2013          <p>The member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; griffe_object[\"foo\"] = foo\n&gt;&gt;&gt; griffe_object[\"path.to.bar\"] = bar\n&gt;&gt;&gt; griffe_object[(\"path\", \"to\", \"qux\")] = qux\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def __setitem__(self, key: str | Sequence[str], value: Object | Alias) -&gt; None:\n\"\"\"Set a member with its name or path.\n\n    This method is part of the consumer API:\n    do not use when producing Griffe trees!\n\n    Parameters:\n        key: The name or path of the member.\n        value: The member.\n\n    Examples:\n        &gt;&gt;&gt; griffe_object[\"foo\"] = foo\n        &gt;&gt;&gt; griffe_object[\"path.to.bar\"] = bar\n        &gt;&gt;&gt; griffe_object[(\"path\", \"to\", \"qux\")] = qux\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        self.members[name] = value  # type: ignore[attr-defined]\n        if self.is_collection:  # type: ignore[attr-defined]\n            value._modules_collection = self  # type: ignore[union-attr]\n        else:\n            value.parent = self  # type: ignore[assignment]\n    else:\n        self.members[parts[0]][parts[1:]] = value  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/mixins/#griffe.mixins.SetMembersMixin.del_member","title":"del_member","text":"<pre><code>del_member(key: str | Sequence[str]) -&gt; None\n</code></pre> <p>Delete a member with its name or path.</p> <p>This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).</p> <p>Members will be looked up in declared members only, not inherited ones.</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; griffe_object.del_member(\"foo\")\n&gt;&gt;&gt; griffe_object.del_member(\"path.to.bar\")\n&gt;&gt;&gt; griffe_object.del_member((\"path\", \"to\", \"qux\"))\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def del_member(self, key: str | Sequence[str]) -&gt; None:\n\"\"\"Delete a member with its name or path.\n\n    This method is part of the producer API:\n    you can use it safely while building Griffe trees\n    (for example in Griffe extensions).\n\n    Members will be looked up in declared members only, not inherited ones.\n\n    Parameters:\n        key: The name or path of the member.\n\n    Examples:\n        &gt;&gt;&gt; griffe_object.del_member(\"foo\")\n        &gt;&gt;&gt; griffe_object.del_member(\"path.to.bar\")\n        &gt;&gt;&gt; griffe_object.del_member((\"path\", \"to\", \"qux\"))\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        del self.members[name]  # type: ignore[attr-defined]\n    else:\n        self.members[parts[0]].del_member(parts[1:])  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/mixins/#griffe.mixins.SetMembersMixin.set_member","title":"set_member","text":"<pre><code>set_member(\n    key: str | Sequence[str], value: Object | Alias\n) -&gt; None\n</code></pre> <p>Set a member with its name or path.</p> <p>This method is part of the producer API: you can use it safely while building Griffe trees (for example in Griffe extensions).</p> <p>Parameters:</p> <ul> <li> key             (<code>str | Sequence[str]</code>)         \u2013          <p>The name or path of the member.</p> </li> <li> value             (<code>Object | Alias</code>)         \u2013          <p>The member.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; griffe_object.set_member(\"foo\", foo)\n&gt;&gt;&gt; griffe_object.set_member(\"path.to.bar\", bar)\n&gt;&gt;&gt; griffe_object.set_member((\"path\", \"to\", \"qux\", qux)\n</code></pre> Source code in <code>src/griffe/mixins.py</code> <pre><code>def set_member(self, key: str | Sequence[str], value: Object | Alias) -&gt; None:\n\"\"\"Set a member with its name or path.\n\n    This method is part of the producer API:\n    you can use it safely while building Griffe trees\n    (for example in Griffe extensions).\n\n    Parameters:\n        key: The name or path of the member.\n        value: The member.\n\n    Examples:\n        &gt;&gt;&gt; griffe_object.set_member(\"foo\", foo)\n        &gt;&gt;&gt; griffe_object.set_member(\"path.to.bar\", bar)\n        &gt;&gt;&gt; griffe_object.set_member((\"path\", \"to\", \"qux\", qux)\n    \"\"\"\n    parts = _get_parts(key)\n    if len(parts) == 1:\n        name = parts[0]\n        if name in self.members:  # type: ignore[attr-defined]\n            member = self.members[name]  # type: ignore[attr-defined]\n            if not member.is_alias:\n                # when reassigning a module to an existing one,\n                # try to merge them as one regular and one stubs module\n                # (implicit support for .pyi modules)\n                if member.is_module and not (member.is_namespace_package or member.is_namespace_subpackage):\n                    with suppress(AliasResolutionError, CyclicAliasError):\n                        if value.is_module and value.filepath != member.filepath:\n                            with suppress(ValueError):\n                                value = merge_stubs(member, value)  # type: ignore[arg-type]\n                for alias in member.aliases.values():\n                    with suppress(CyclicAliasError):\n                        alias.target = value\n        self.members[name] = value  # type: ignore[attr-defined]\n        if self.is_collection:  # type: ignore[attr-defined]\n            value._modules_collection = self  # type: ignore[union-attr]\n        else:\n            value.parent = self  # type: ignore[assignment]\n    else:\n        self.members[parts[0]].set_member(parts[1:], value)  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/stats/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> stats","text":""},{"location":"reference/griffe/stats/#griffe.stats","title":"stats","text":"<p>This module contains utilities to compute loading statistics.</p> <p>Functions:</p> <ul> <li> stats           \u2013            <p>Return some loading statistics.</p> </li> </ul>"},{"location":"reference/griffe/stats/#griffe.stats.stats","title":"stats","text":"<pre><code>stats(loader: GriffeLoader) -&gt; dict\n</code></pre> <p>Return some loading statistics.</p> <p>Parameters:</p> <ul> <li> loader             (<code>GriffeLoader</code>)         \u2013          <p>The loader to compute stats from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013          <p>Some statistics.</p> </li> </ul> Source code in <code>src/griffe/stats.py</code> <pre><code>def stats(loader: GriffeLoader) -&gt; dict:\n\"\"\"Return some loading statistics.\n\n    Parameters:\n        loader: The loader to compute stats from.\n\n    Returns:\n        Some statistics.\n    \"\"\"\n    modules_by_extension = defaultdict(\n        int,\n        {\n            \"\": 0,\n            \".py\": 0,\n            \".pyi\": 0,\n            \".pyc\": 0,\n            \".pyo\": 0,\n            \".pyd\": 0,\n            \".so\": 0,\n        },\n    )\n    top_modules = loader.modules_collection.members.values()\n    for module in top_modules:\n        _sum_extensions(modules_by_extension, module)\n    n_lines = sum(len(lines) for lines in loader.lines_collection.values())\n    return {\n        \"packages\": len(top_modules),\n        \"modules\": len(top_modules) + sum(_n_modules(mod) for mod in top_modules),\n        \"classes\": sum(_n_classes(mod) for mod in top_modules),\n        \"functions\": sum(_n_functions(mod) for mod in top_modules),\n        \"attributes\": sum(_n_attributes(mod) for mod in top_modules),\n        \"modules_by_extension\": modules_by_extension,\n        \"lines\": n_lines,\n    }\n</code></pre>"},{"location":"reference/griffe/tests/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> tests","text":""},{"location":"reference/griffe/tests/#griffe.tests","title":"tests","text":"<p>Test helpers and pytest fixtures.</p> <p>Functions:</p> <ul> <li> htree           \u2013            <p>Link objects together, horizontally.</p> </li> <li> module_vtree           \u2013            <p>Link objects together, vertically.</p> </li> <li> temporary_inspected_module           \u2013            <p>Create and inspect a temporary module with the given code.</p> </li> <li> temporary_pyfile           \u2013            <p>Create a Python file containing the given code in a temporary directory.</p> </li> <li> temporary_pypackage           \u2013            <p>Create a package containing the given modules in a temporary directory.</p> </li> <li> temporary_visited_module           \u2013            <p>Create and visit a temporary module with the given code.</p> </li> <li> temporary_visited_package           \u2013            <p>Create and visit a temporary package.</p> </li> <li> vtree           \u2013            <p>Link objects together, vertically.</p> </li> </ul>"},{"location":"reference/griffe/tests/#griffe.tests.htree","title":"htree","text":"<pre><code>htree(*objects: Object) -&gt; Object\n</code></pre> <p>Link objects together, horizontally.</p> <p>Parameters:</p> <ul> <li> *objects             (<code>Object</code>, default:                 <code>()</code> )         \u2013          <p>A sequence of objects. All objects starting at the second become members of the first.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When no objects are provided.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Object</code>         \u2013          <p>The first given object, with all the other objects as members of it.</p> </li> </ul> Source code in <code>src/griffe/tests.py</code> <pre><code>def htree(*objects: Object) -&gt; Object:\n\"\"\"Link objects together, horizontally.\n\n    Parameters:\n        *objects: A sequence of objects. All objects starting at the second become members of the first.\n\n    Raises:\n        ValueError: When no objects are provided.\n\n    Returns:\n        The first given object, with all the other objects as members of it.\n    \"\"\"\n    if not objects:\n        raise ValueError(\"At least one object must be provided\")\n    top = objects[0]\n    for obj in objects[1:]:\n        top.set_member(obj.name, obj)\n    return top\n</code></pre>"},{"location":"reference/griffe/tests/#griffe.tests.module_vtree","title":"module_vtree","text":"<pre><code>module_vtree(\n    path: str,\n    *,\n    leaf_package: bool = True,\n    return_leaf: bool = False\n) -&gt; Module\n</code></pre> <p>Link objects together, vertically.</p> <p>Parameters:</p> <ul> <li> path             (<code>str</code>)         \u2013          <p>The complete module path, like <code>\"a.b.c.d\"</code>.</p> </li> <li> leaf_package             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether the deepest module should also be a package.</p> </li> <li> return_leaf             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to return the leaf instead of the root.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When no objects are provided.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013          <p>The top or leaf module.</p> </li> </ul> Source code in <code>src/griffe/tests.py</code> <pre><code>def module_vtree(path: str, *, leaf_package: bool = True, return_leaf: bool = False) -&gt; Module:\n\"\"\"Link objects together, vertically.\n\n    Parameters:\n        path: The complete module path, like `\"a.b.c.d\"`.\n        leaf_package: Whether the deepest module should also be a package.\n        return_leaf: Whether to return the leaf instead of the root.\n\n    Raises:\n        ValueError: When no objects are provided.\n\n    Returns:\n        The top or leaf module.\n    \"\"\"\n    parts = path.split(\".\")\n    modules = [Module(name, filepath=Path(*parts[:index], \"__init__.py\")) for index, name in enumerate(parts)]\n    if not leaf_package:\n        try:\n            filepath = modules[-1].filepath.with_stem(parts[-1])  # type: ignore[union-attr]\n        except AttributeError:  # TODO: remove once Python 3.8 is dropped\n            filepath = modules[-1].filepath.with_name(f\"{parts[-1]}.py\")  # type: ignore[union-attr]\n        modules[-1]._filepath = filepath\n    return vtree(*modules, return_leaf=return_leaf)  # type: ignore[return-value]\n</code></pre>"},{"location":"reference/griffe/tests/#griffe.tests.temporary_inspected_module","title":"temporary_inspected_module","text":"<pre><code>temporary_inspected_module(\n    code: str,\n    *,\n    module_name: str = \"module\",\n    import_paths: list[Path] | None = None,\n    extensions: Extensions | None = None,\n    parent: Module | None = None,\n    docstring_parser: Parser | None = None,\n    docstring_options: dict[str, Any] | None = None,\n    lines_collection: LinesCollection | None = None,\n    modules_collection: ModulesCollection | None = None\n) -&gt; Iterator[Module]\n</code></pre> <p>Create and inspect a temporary module with the given code.</p> <p>Parameters:</p> <ul> <li> code             (<code>str</code>)         \u2013          <p>The code of the module.</p> </li> <li> module_name             (<code>str</code>, default:                 <code>'module'</code> )         \u2013          <p>The name of the temporary module.</p> </li> <li> import_paths             (<code>list[Path] | None</code>, default:                 <code>None</code> )         \u2013          <p>Paths to import the module from.</p> </li> <li> extensions             (<code>Extensions | None</code>, default:                 <code>None</code> )         \u2013          <p>The extensions to use when visiting the AST.</p> </li> <li> parent             (<code>Module | None</code>, default:                 <code>None</code> )         \u2013          <p>The optional parent of this module.</p> </li> <li> docstring_parser             (<code>Parser | None</code>, default:                 <code>None</code> )         \u2013          <p>The docstring parser to use. By default, no parsing is done.</p> </li> <li> docstring_options             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional docstring parsing options.</p> </li> <li> lines_collection             (<code>LinesCollection | None</code>, default:                 <code>None</code> )         \u2013          <p>A collection of source code lines.</p> </li> <li> modules_collection             (<code>ModulesCollection | None</code>, default:                 <code>None</code> )         \u2013          <p>A collection of modules.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>Module</code>         \u2013          <p>The inspected module.</p> </li> </ul> Source code in <code>src/griffe/tests.py</code> <pre><code>@contextmanager\ndef temporary_inspected_module(\n    code: str,\n    *,\n    module_name: str = \"module\",\n    import_paths: list[Path] | None = None,\n    extensions: Extensions | None = None,\n    parent: Module | None = None,\n    docstring_parser: Parser | None = None,\n    docstring_options: dict[str, Any] | None = None,\n    lines_collection: LinesCollection | None = None,\n    modules_collection: ModulesCollection | None = None,\n) -&gt; Iterator[Module]:\n\"\"\"Create and inspect a temporary module with the given code.\n\n    Parameters:\n        code: The code of the module.\n        module_name: The name of the temporary module.\n        import_paths: Paths to import the module from.\n        extensions: The extensions to use when visiting the AST.\n        parent: The optional parent of this module.\n        docstring_parser: The docstring parser to use. By default, no parsing is done.\n        docstring_options: Additional docstring parsing options.\n        lines_collection: A collection of source code lines.\n        modules_collection: A collection of modules.\n\n    Yields:\n        The inspected module.\n    \"\"\"\n    with temporary_pyfile(code, module_name=module_name) as (_, path):\n        try:\n            module = inspect(\n                module_name,\n                filepath=path,\n                import_paths=import_paths,\n                extensions=extensions,\n                parent=parent,\n                docstring_parser=docstring_parser,\n                docstring_options=docstring_options,\n                lines_collection=lines_collection,\n                modules_collection=modules_collection,\n            )\n            module.modules_collection[module_name] = module\n            yield module\n        finally:\n            if module_name in sys.modules:\n                del sys.modules[module_name]\n            invalidate_caches()\n</code></pre>"},{"location":"reference/griffe/tests/#griffe.tests.temporary_pyfile","title":"temporary_pyfile","text":"<pre><code>temporary_pyfile(\n    code: str, *, module_name: str = \"module\"\n) -&gt; Iterator[tuple[str, Path]]\n</code></pre> <p>Create a Python file containing the given code in a temporary directory.</p> <p>Parameters:</p> <ul> <li> code             (<code>str</code>)         \u2013          <p>The code to write to the temporary file.</p> </li> <li> module_name             (<code>str</code>, default:                 <code>'module'</code> )         \u2013          <p>The name of the temporary module.</p> </li> </ul> <p>Yields:</p> <ul> <li> module_name (            <code>str</code> )        \u2013          <p>The module name, as to dynamically import it.</p> </li> <li> module_path (            <code>Path</code> )        \u2013          <p>The module path.</p> </li> </ul> Source code in <code>src/griffe/tests.py</code> <pre><code>@contextmanager\ndef temporary_pyfile(code: str, *, module_name: str = \"module\") -&gt; Iterator[tuple[str, Path]]:\n\"\"\"Create a Python file containing the given code in a temporary directory.\n\n    Parameters:\n        code: The code to write to the temporary file.\n        module_name: The name of the temporary module.\n\n    Yields:\n        module_name: The module name, as to dynamically import it.\n        module_path: The module path.\n    \"\"\"\n    with tempfile.TemporaryDirectory(prefix=TMPDIR_PREFIX) as tmpdir:\n        tmpfile = Path(tmpdir) / f\"{module_name}.py\"\n        tmpfile.write_text(dedent(code))\n        yield module_name, tmpfile\n</code></pre>"},{"location":"reference/griffe/tests/#griffe.tests.temporary_pypackage","title":"temporary_pypackage","text":"<pre><code>temporary_pypackage(\n    package: str,\n    modules: Sequence[str]\n    | Mapping[str, str]\n    | None = None,\n    *,\n    init: bool = True\n) -&gt; Iterator[TmpPackage]\n</code></pre> <p>Create a package containing the given modules in a temporary directory.</p> <p>Parameters:</p> <ul> <li> package             (<code>str</code>)         \u2013          <p>The package name. Example: <code>\"a\"</code> gives a package named <code>a</code>, while <code>\"a/b\"</code> gives a namespace package named <code>a</code> with a package inside named <code>b</code>. If <code>init</code> is false, then <code>b</code> is also a namespace package.</p> </li> <li> modules             (<code>Sequence[str] | Mapping[str, str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional modules to create in the package. If a list, simply touch the files: <code>[\"b.py\", \"c/d.py\", \"e/f\"]</code>. If a dict, keys are the file names and values their contents: <code>{\"b.py\": \"b = 1\", \"c/d.py\": \"print('hey from c')\"}</code>.</p> </li> <li> init             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to create an <code>__init__</code> module in the leaf package.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>TmpPackage</code>         \u2013          <p>A named tuple with the following fields:</p> <ul> <li><code>tmp_dir</code>: The temporary directory containing the package.</li> <li><code>name</code>: The package name, as to dynamically import it.</li> <li><code>path</code>: The package path.</li> </ul> </li> </ul> Source code in <code>src/griffe/tests.py</code> <pre><code>@contextmanager\ndef temporary_pypackage(\n    package: str,\n    modules: Sequence[str] | Mapping[str, str] | None = None,\n    *,\n    init: bool = True,\n) -&gt; Iterator[TmpPackage]:\n\"\"\"Create a package containing the given modules in a temporary directory.\n\n    Parameters:\n        package: The package name. Example: `\"a\"` gives\n            a package named `a`, while `\"a/b\"` gives a namespace package\n            named `a` with a package inside named `b`.\n            If `init` is false, then `b` is also a namespace package.\n        modules: Additional modules to create in the package.\n            If a list, simply touch the files: `[\"b.py\", \"c/d.py\", \"e/f\"]`.\n            If a dict, keys are the file names and values their contents:\n            `{\"b.py\": \"b = 1\", \"c/d.py\": \"print('hey from c')\"}`.\n        init: Whether to create an `__init__` module in the leaf package.\n\n    Yields:\n        A named tuple with the following fields:\n\n            - `tmp_dir`: The temporary directory containing the package.\n            - `name`: The package name, as to dynamically import it.\n            - `path`: The package path.\n    \"\"\"\n    modules = modules or {}\n    if isinstance(modules, list):\n        modules = {mod: \"\" for mod in modules}\n    mkdir_kwargs = {\"parents\": True, \"exist_ok\": True}\n    with tempfile.TemporaryDirectory(prefix=TMPDIR_PREFIX) as tmpdir:\n        tmpdirpath = Path(tmpdir)\n        package_name = \".\".join(Path(package).parts)\n        package_path = tmpdirpath / package\n        package_path.mkdir(**mkdir_kwargs)\n        if init:\n            package_path.joinpath(\"__init__.py\").touch()\n        for module_name, module_contents in modules.items():  # type: ignore[union-attr]\n            current_path = package_path\n            for part in Path(module_name).parts:\n                if part.endswith((\".py\", \".pyi\")):\n                    current_path.joinpath(part).write_text(dedent(module_contents))\n                else:\n                    current_path /= part\n                    current_path.mkdir(**mkdir_kwargs)\n                    current_path.joinpath(\"__init__.py\").touch()\n        yield TmpPackage(tmpdirpath, package_name, package_path)\n</code></pre>"},{"location":"reference/griffe/tests/#griffe.tests.temporary_visited_module","title":"temporary_visited_module","text":"<pre><code>temporary_visited_module(\n    code: str,\n    *,\n    module_name: str = \"module\",\n    extensions: Extensions | None = None,\n    parent: Module | None = None,\n    docstring_parser: Parser | None = None,\n    docstring_options: dict[str, Any] | None = None,\n    lines_collection: LinesCollection | None = None,\n    modules_collection: ModulesCollection | None = None\n) -&gt; Iterator[Module]\n</code></pre> <p>Create and visit a temporary module with the given code.</p> <p>Parameters:</p> <ul> <li> code             (<code>str</code>)         \u2013          <p>The code of the module.</p> </li> <li> module_name             (<code>str</code>, default:                 <code>'module'</code> )         \u2013          <p>The name of the temporary module.</p> </li> <li> extensions             (<code>Extensions | None</code>, default:                 <code>None</code> )         \u2013          <p>The extensions to use when visiting the AST.</p> </li> <li> parent             (<code>Module | None</code>, default:                 <code>None</code> )         \u2013          <p>The optional parent of this module.</p> </li> <li> docstring_parser             (<code>Parser | None</code>, default:                 <code>None</code> )         \u2013          <p>The docstring parser to use. By default, no parsing is done.</p> </li> <li> docstring_options             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional docstring parsing options.</p> </li> <li> lines_collection             (<code>LinesCollection | None</code>, default:                 <code>None</code> )         \u2013          <p>A collection of source code lines.</p> </li> <li> modules_collection             (<code>ModulesCollection | None</code>, default:                 <code>None</code> )         \u2013          <p>A collection of modules.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>Module</code>         \u2013          <p>The visited module.</p> </li> </ul> Source code in <code>src/griffe/tests.py</code> <pre><code>@contextmanager\ndef temporary_visited_module(\n    code: str,\n    *,\n    module_name: str = \"module\",\n    extensions: Extensions | None = None,\n    parent: Module | None = None,\n    docstring_parser: Parser | None = None,\n    docstring_options: dict[str, Any] | None = None,\n    lines_collection: LinesCollection | None = None,\n    modules_collection: ModulesCollection | None = None,\n) -&gt; Iterator[Module]:\n\"\"\"Create and visit a temporary module with the given code.\n\n    Parameters:\n        code: The code of the module.\n        module_name: The name of the temporary module.\n        extensions: The extensions to use when visiting the AST.\n        parent: The optional parent of this module.\n        docstring_parser: The docstring parser to use. By default, no parsing is done.\n        docstring_options: Additional docstring parsing options.\n        lines_collection: A collection of source code lines.\n        modules_collection: A collection of modules.\n\n    Yields:\n        The visited module.\n    \"\"\"\n    with temporary_pyfile(code, module_name=module_name) as (_, path):\n        module = visit(\n            module_name,\n            filepath=path,\n            code=dedent(code),\n            extensions=extensions,\n            parent=parent,\n            docstring_parser=docstring_parser,\n            docstring_options=docstring_options,\n            lines_collection=lines_collection,\n            modules_collection=modules_collection,\n        )\n        module.modules_collection[module_name] = module\n        yield module\n</code></pre>"},{"location":"reference/griffe/tests/#griffe.tests.temporary_visited_package","title":"temporary_visited_package","text":"<pre><code>temporary_visited_package(\n    package: str,\n    modules: Sequence[str]\n    | Mapping[str, str]\n    | None = None,\n    *,\n    init: bool = True\n) -&gt; Iterator[Module]\n</code></pre> <p>Create and visit a temporary package.</p> <p>Parameters:</p> <ul> <li> package             (<code>str</code>)         \u2013          <p>The package name. Example: <code>\"a\"</code> gives a package named <code>a</code>, while <code>\"a/b\"</code> gives a namespace package named <code>a</code> with a package inside named <code>b</code>. If <code>init</code> is false, then <code>b</code> is also a namespace package.</p> </li> <li> modules             (<code>Sequence[str] | Mapping[str, str] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional modules to create in the package. If a list, simply touch the files: <code>[\"b.py\", \"c/d.py\", \"e/f\"]</code>. If a dict, keys are the file names and values their contents: <code>{\"b.py\": \"b = 1\", \"c/d.py\": \"print('hey from c')\"}</code>.</p> </li> <li> init             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to create an <code>__init__</code> module in the leaf package.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>Module</code>         \u2013          <p>A module.</p> </li> </ul> Source code in <code>src/griffe/tests.py</code> <pre><code>@contextmanager\ndef temporary_visited_package(\n    package: str,\n    modules: Sequence[str] | Mapping[str, str] | None = None,\n    *,\n    init: bool = True,\n) -&gt; Iterator[Module]:\n\"\"\"Create and visit a temporary package.\n\n    Parameters:\n        package: The package name. Example: `\"a\"` gives\n            a package named `a`, while `\"a/b\"` gives a namespace package\n            named `a` with a package inside named `b`.\n            If `init` is false, then `b` is also a namespace package.\n        modules: Additional modules to create in the package.\n            If a list, simply touch the files: `[\"b.py\", \"c/d.py\", \"e/f\"]`.\n            If a dict, keys are the file names and values their contents:\n            `{\"b.py\": \"b = 1\", \"c/d.py\": \"print('hey from c')\"}`.\n        init: Whether to create an `__init__` module in the leaf package.\n\n    Yields:\n        A module.\n    \"\"\"\n    with temporary_pypackage(package, modules, init=init) as tmp_package:\n        loader = GriffeLoader(search_paths=[tmp_package.tmpdir])\n        yield loader.load_module(tmp_package.name)\n</code></pre>"},{"location":"reference/griffe/tests/#griffe.tests.vtree","title":"vtree","text":"<pre><code>vtree(\n    *objects: Object, return_leaf: bool = False\n) -&gt; Object\n</code></pre> <p>Link objects together, vertically.</p> <p>Parameters:</p> <ul> <li> *objects             (<code>Object</code>, default:                 <code>()</code> )         \u2013          <p>A sequence of objects. The first one is at the top of the tree.</p> </li> <li> return_leaf             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to return the leaf instead of the root.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>When no objects are provided.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Object</code>         \u2013          <p>The top or leaf object.</p> </li> </ul> Source code in <code>src/griffe/tests.py</code> <pre><code>def vtree(*objects: Object, return_leaf: bool = False) -&gt; Object:\n\"\"\"Link objects together, vertically.\n\n    Parameters:\n        *objects: A sequence of objects. The first one is at the top of the tree.\n        return_leaf: Whether to return the leaf instead of the root.\n\n    Raises:\n        ValueError: When no objects are provided.\n\n    Returns:\n        The top or leaf object.\n    \"\"\"\n    if not objects:\n        raise ValueError(\"At least one object must be provided\")\n    top = objects[0]\n    leaf = top\n    for obj in objects[1:]:\n        leaf.set_member(obj.name, obj)\n        leaf = obj\n    return leaf if return_leaf else top\n</code></pre>"},{"location":"reference/griffe/agents/","title":"Index","text":""},{"location":"reference/griffe/agents/#griffe.agents","title":"agents","text":"<p>These modules contain the different agents that are able to extract data.</p> <p>Modules:</p> <ul> <li> inspector         \u2013          <p>This module defines introspection mechanisms.</p> </li> <li> nodes         \u2013          <p>This module contains utilities for extracting information from nodes.</p> </li> <li> visitor         \u2013          <p>Code parsing and data extraction utilies.</p> </li> </ul>"},{"location":"reference/griffe/agents/inspector/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> inspector","text":""},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector","title":"inspector","text":"<p>This module defines introspection mechanisms.</p> <p>Sometimes we cannot get the source code of a module or an object, typically built-in modules like <code>itertools</code>. The only way to know what they are made of is to actually import them and inspect their contents.</p> <p>Sometimes, even if the source code is available, loading the object is desired because it was created or modified dynamically, and our node visitor is not powerful enough to infer all these dynamic modifications. In this case, we always try to visit the code first, and only then we load the object to update the data with introspection.</p> <p>This module exposes a public function, <code>inspect()</code>, which inspects the module using <code>inspect.getmembers()</code>, and returns a new <code>Module</code> instance, populating its members recursively, by using a <code>NodeVisitor</code>-like class.</p> <p>The inspection agent works similarly to the regular \"node visitor\" agent, in that it maintains a state with the current object being handled, and recursively handle its members.</p> <p>Classes:</p> <ul> <li> Inspector         \u2013          <p>This class is used to instantiate an inspector.</p> </li> </ul> <p>Functions:</p> <ul> <li> inspect           \u2013            <p>Inspect a module.</p> </li> </ul>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector","title":"Inspector","text":"<pre><code>Inspector(\n    module_name: str,\n    filepath: Path | None,\n    extensions: Extensions,\n    parent: Module | None = None,\n    docstring_parser: Parser | None = None,\n    docstring_options: dict[str, Any] | None = None,\n    lines_collection: LinesCollection | None = None,\n    modules_collection: ModulesCollection | None = None,\n)\n</code></pre> <p>This class is used to instantiate an inspector.</p> <p>Inspectors iterate on objects members to extract data from them.</p> <p>Parameters:</p> <ul> <li> module_name             (<code>str</code>)         \u2013          <p>The module name.</p> </li> <li> filepath             (<code>Path | None</code>)         \u2013          <p>The optional filepath.</p> </li> <li> extensions             (<code>Extensions</code>)         \u2013          <p>Extensions to use when inspecting.</p> </li> <li> parent             (<code>Module | None</code>, default:                 <code>None</code> )         \u2013          <p>The module parent.</p> </li> <li> docstring_parser             (<code>Parser | None</code>, default:                 <code>None</code> )         \u2013          <p>The docstring parser to use.</p> </li> <li> docstring_options             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>The docstring parsing options.</p> </li> <li> lines_collection             (<code>LinesCollection | None</code>, default:                 <code>None</code> )         \u2013          <p>A collection of source code lines.</p> </li> <li> modules_collection             (<code>ModulesCollection | None</code>, default:                 <code>None</code> )         \u2013          <p>A collection of modules.</p> </li> </ul> <p>Methods:</p> <ul> <li> generic_inspect           \u2013            <p>Extend the base generic inspection with extensions.</p> </li> <li> get_module           \u2013            <p>Build and return the object representing the module attached to this inspector.</p> </li> <li> handle_attribute           \u2013            <p>Handle an attribute.</p> </li> <li> handle_function           \u2013            <p>Handle a function.</p> </li> <li> inspect           \u2013            <p>Extend the base inspection with extensions.</p> </li> <li> inspect_attribute           \u2013            <p>Inspect an attribute.</p> </li> <li> inspect_builtin_function           \u2013            <p>Inspect a builtin function.</p> </li> <li> inspect_builtin_method           \u2013            <p>Inspect a builtin method.</p> </li> <li> inspect_cached_property           \u2013            <p>Inspect a cached property.</p> </li> <li> inspect_class           \u2013            <p>Inspect a class.</p> </li> <li> inspect_classmethod           \u2013            <p>Inspect a class method.</p> </li> <li> inspect_coroutine           \u2013            <p>Inspect a coroutine.</p> </li> <li> inspect_function           \u2013            <p>Inspect a function.</p> </li> <li> inspect_method           \u2013            <p>Inspect a method.</p> </li> <li> inspect_method_descriptor           \u2013            <p>Inspect a method descriptor.</p> </li> <li> inspect_module           \u2013            <p>Inspect a module.</p> </li> <li> inspect_property           \u2013            <p>Inspect a property.</p> </li> <li> inspect_staticmethod           \u2013            <p>Inspect a static method.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def __init__(\n    self,\n    module_name: str,\n    filepath: Path | None,\n    extensions: Extensions,\n    parent: Module | None = None,\n    docstring_parser: Parser | None = None,\n    docstring_options: dict[str, Any] | None = None,\n    lines_collection: LinesCollection | None = None,\n    modules_collection: ModulesCollection | None = None,\n) -&gt; None:\n\"\"\"Initialize the inspector.\n\n    Parameters:\n        module_name: The module name.\n        filepath: The optional filepath.\n        extensions: Extensions to use when inspecting.\n        parent: The module parent.\n        docstring_parser: The docstring parser to use.\n        docstring_options: The docstring parsing options.\n        lines_collection: A collection of source code lines.\n        modules_collection: A collection of modules.\n    \"\"\"\n    super().__init__()\n    self.module_name: str = module_name\n    self.filepath: Path | None = filepath\n    self.extensions: Extensions = extensions.attach_inspector(self)\n    self.parent: Module | None = parent\n    self.current: Module | Class = None  # type: ignore[assignment]\n    self.docstring_parser: Parser | None = docstring_parser\n    self.docstring_options: dict[str, Any] = docstring_options or {}\n    self.lines_collection: LinesCollection = lines_collection or LinesCollection()\n    self.modules_collection: ModulesCollection = modules_collection or ModulesCollection()\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.generic_inspect","title":"generic_inspect","text":"<pre><code>generic_inspect(node: ObjectNode) -&gt; None\n</code></pre> <p>Extend the base generic inspection with extensions.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013          <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def generic_inspect(self, node: ObjectNode) -&gt; None:\n\"\"\"Extend the base generic inspection with extensions.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    for before_inspector in self.extensions.before_children_inspection:\n        before_inspector.inspect(node)\n\n    for child in node.children:\n        target_path = child.alias_target_path\n        if target_path:\n            self.current.set_member(child.name, Alias(child.name, target_path))\n        else:\n            self.inspect(child)\n\n    for after_inspector in self.extensions.after_children_inspection:\n        after_inspector.inspect(node)\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.get_module","title":"get_module","text":"<pre><code>get_module(\n    import_paths: Sequence[str | Path] | None = None,\n) -&gt; Module\n</code></pre> <p>Build and return the object representing the module attached to this inspector.</p> <p>This method triggers a complete inspection of the module members.</p> <p>Parameters:</p> <ul> <li> import_paths             (<code>Sequence[str | Path] | None</code>, default:                 <code>None</code> )         \u2013          <p>Paths replacing <code>sys.path</code> to import the module.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013          <p>A module instance.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def get_module(self, import_paths: Sequence[str | Path] | None = None) -&gt; Module:\n\"\"\"Build and return the object representing the module attached to this inspector.\n\n    This method triggers a complete inspection of the module members.\n\n    Parameters:\n        import_paths: Paths replacing `sys.path` to import the module.\n\n    Returns:\n        A module instance.\n    \"\"\"\n    import_path = self.module_name\n    if self.parent is not None:\n        import_path = f\"{self.parent.path}.{import_path}\"\n    value = dynamic_import(import_path, import_paths)\n    parent = None\n    if self.parent is not None:\n        for part in self.parent.path.split(\".\"):\n            parent = ObjectNode(None, name=part, parent=parent)\n    module_node = ObjectNode(value, self.module_name, parent=parent)\n    self.inspect(module_node)\n    return self.current.module\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.handle_attribute","title":"handle_attribute","text":"<pre><code>handle_attribute(\n    node: ObjectNode, annotation: str | Expr | None = None\n) -&gt; None\n</code></pre> <p>Handle an attribute.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013          <p>The node to inspect.</p> </li> <li> annotation             (<code>str | Expr | None</code>, default:                 <code>None</code> )         \u2013          <p>A potentiel annotation.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def handle_attribute(self, node: ObjectNode, annotation: str | Expr | None = None) -&gt; None:\n\"\"\"Handle an attribute.\n\n    Parameters:\n        node: The node to inspect.\n        annotation: A potentiel annotation.\n    \"\"\"\n    self.extensions.call(\"on_node\", node=node)\n    self.extensions.call(\"on_attribute_node\", node=node)\n\n    # TODO: to improve\n    parent = self.current\n    labels: set[str] = set()\n\n    if parent.kind is ObjectKind.MODULE:\n        labels.add(\"module\")\n    elif parent.kind is ObjectKind.CLASS:\n        labels.add(\"class\")\n    elif parent.kind is ObjectKind.FUNCTION:\n        if parent.name != \"__init__\":\n            return\n        parent = parent.parent\n        labels.add(\"instance\")\n\n    try:\n        value = repr(node.obj)\n    except Exception:  # noqa: BLE001\n        value = None\n    try:\n        docstring = self._get_docstring(node)\n    except Exception:  # noqa: BLE001\n        docstring = None\n\n    attribute = Attribute(\n        name=node.name,\n        value=value,\n        annotation=annotation,\n        docstring=docstring,\n    )\n    attribute.labels |= labels\n    parent.set_member(node.name, attribute)\n\n    if node.name == \"__all__\":\n        parent.exports = set(node.obj)\n    self.extensions.call(\"on_instance\", node=node, obj=attribute)\n    self.extensions.call(\"on_attribute_instance\", node=node, attr=attribute)\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.handle_function","title":"handle_function","text":"<pre><code>handle_function(\n    node: ObjectNode, labels: set | None = None\n) -&gt; None\n</code></pre> <p>Handle a function.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013          <p>The node to inspect.</p> </li> <li> labels             (<code>set | None</code>, default:                 <code>None</code> )         \u2013          <p>Labels to add to the data object.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def handle_function(self, node: ObjectNode, labels: set | None = None) -&gt; None:\n\"\"\"Handle a function.\n\n    Parameters:\n        node: The node to inspect.\n        labels: Labels to add to the data object.\n    \"\"\"\n    self.extensions.call(\"on_node\", node=node)\n    self.extensions.call(\"on_function_node\", node=node)\n\n    try:\n        signature = getsignature(node.obj)\n    except Exception:  # noqa: BLE001\n        # so many exceptions can be raised here:\n        # AttributeError, NameError, RuntimeError, ValueError, TokenError, TypeError\n        parameters = None\n        returns = None\n    else:\n        parameters = Parameters(\n            *[_convert_parameter(parameter, parent=self.current) for parameter in signature.parameters.values()],\n        )\n        return_annotation = signature.return_annotation\n        returns = (\n            None\n            if return_annotation is empty\n            else _convert_object_to_annotation(return_annotation, parent=self.current)\n        )\n\n    obj: Attribute | Function\n    labels = labels or set()\n    if \"property\" in labels:\n        obj = Attribute(\n            name=node.name,\n            value=None,\n            annotation=returns,\n            docstring=self._get_docstring(node),\n        )\n    else:\n        obj = Function(\n            name=node.name,\n            parameters=parameters,\n            returns=returns,\n            docstring=self._get_docstring(node),\n        )\n    obj.labels |= labels\n    self.current.set_member(node.name, obj)\n    self.extensions.call(\"on_instance\", node=node, obj=obj)\n    if obj.is_attribute:\n        self.extensions.call(\"on_attribute_instance\", node=node, attr=obj)\n    else:\n        self.extensions.call(\"on_function_instance\", node=node, func=obj)\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect","title":"inspect","text":"<pre><code>inspect(node: ObjectNode) -&gt; None\n</code></pre> <p>Extend the base inspection with extensions.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013          <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def inspect(self, node: ObjectNode) -&gt; None:\n\"\"\"Extend the base inspection with extensions.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    for before_inspector in self.extensions.before_inspection:\n        before_inspector.inspect(node)\n    getattr(self, f\"inspect_{node.kind}\", self.generic_inspect)(node)\n    for after_inspector in self.extensions.after_inspection:\n        after_inspector.inspect(node)\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_attribute","title":"inspect_attribute","text":"<pre><code>inspect_attribute(node: ObjectNode) -&gt; None\n</code></pre> <p>Inspect an attribute.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013          <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def inspect_attribute(self, node: ObjectNode) -&gt; None:\n\"\"\"Inspect an attribute.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    self.handle_attribute(node)\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_builtin_function","title":"inspect_builtin_function","text":"<pre><code>inspect_builtin_function(node: ObjectNode) -&gt; None\n</code></pre> <p>Inspect a builtin function.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013          <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def inspect_builtin_function(self, node: ObjectNode) -&gt; None:\n\"\"\"Inspect a builtin function.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    self.handle_function(node, {\"builtin\"})\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_builtin_method","title":"inspect_builtin_method","text":"<pre><code>inspect_builtin_method(node: ObjectNode) -&gt; None\n</code></pre> <p>Inspect a builtin method.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013          <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def inspect_builtin_method(self, node: ObjectNode) -&gt; None:\n\"\"\"Inspect a builtin method.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    self.handle_function(node, {\"builtin\"})\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_cached_property","title":"inspect_cached_property","text":"<pre><code>inspect_cached_property(node: ObjectNode) -&gt; None\n</code></pre> <p>Inspect a cached property.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013          <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def inspect_cached_property(self, node: ObjectNode) -&gt; None:\n\"\"\"Inspect a cached property.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    node.obj = node.obj.func\n    self.handle_function(node, {\"cached\", \"property\"})\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_class","title":"inspect_class","text":"<pre><code>inspect_class(node: ObjectNode) -&gt; None\n</code></pre> <p>Inspect a class.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013          <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def inspect_class(self, node: ObjectNode) -&gt; None:\n\"\"\"Inspect a class.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    self.extensions.call(\"on_node\", node=node)\n    self.extensions.call(\"on_class_node\", node=node)\n\n    bases = []\n    for base in node.obj.__bases__:\n        if base is object:\n            continue\n        bases.append(f\"{base.__module__}.{base.__qualname__}\")\n\n    class_ = Class(\n        name=node.name,\n        docstring=self._get_docstring(node),\n        bases=bases,\n    )\n    self.current.set_member(node.name, class_)\n    self.current = class_\n    self.extensions.call(\"on_instance\", node=node, obj=class_)\n    self.extensions.call(\"on_class_instance\", node=node, cls=class_)\n    self.generic_inspect(node)\n    self.extensions.call(\"on_members\", node=node, obj=class_)\n    self.extensions.call(\"on_class_members\", node=node, cls=class_)\n    self.current = self.current.parent  # type: ignore[assignment]\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_classmethod","title":"inspect_classmethod","text":"<pre><code>inspect_classmethod(node: ObjectNode) -&gt; None\n</code></pre> <p>Inspect a class method.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013          <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def inspect_classmethod(self, node: ObjectNode) -&gt; None:\n\"\"\"Inspect a class method.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    self.handle_function(node, {\"classmethod\"})\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_coroutine","title":"inspect_coroutine","text":"<pre><code>inspect_coroutine(node: ObjectNode) -&gt; None\n</code></pre> <p>Inspect a coroutine.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013          <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def inspect_coroutine(self, node: ObjectNode) -&gt; None:\n\"\"\"Inspect a coroutine.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    self.handle_function(node, {\"async\"})\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_function","title":"inspect_function","text":"<pre><code>inspect_function(node: ObjectNode) -&gt; None\n</code></pre> <p>Inspect a function.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013          <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def inspect_function(self, node: ObjectNode) -&gt; None:\n\"\"\"Inspect a function.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    self.handle_function(node)\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_method","title":"inspect_method","text":"<pre><code>inspect_method(node: ObjectNode) -&gt; None\n</code></pre> <p>Inspect a method.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013          <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def inspect_method(self, node: ObjectNode) -&gt; None:\n\"\"\"Inspect a method.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    self.handle_function(node)\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_method_descriptor","title":"inspect_method_descriptor","text":"<pre><code>inspect_method_descriptor(node: ObjectNode) -&gt; None\n</code></pre> <p>Inspect a method descriptor.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013          <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def inspect_method_descriptor(self, node: ObjectNode) -&gt; None:\n\"\"\"Inspect a method descriptor.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    self.handle_function(node, {\"method descriptor\"})\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_module","title":"inspect_module","text":"<pre><code>inspect_module(node: ObjectNode) -&gt; None\n</code></pre> <p>Inspect a module.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013          <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def inspect_module(self, node: ObjectNode) -&gt; None:\n\"\"\"Inspect a module.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    self.extensions.call(\"on_node\", node=node)\n    self.extensions.call(\"on_module_node\", node=node)\n    self.current = module = Module(\n        name=self.module_name,\n        filepath=self.filepath,\n        parent=self.parent,\n        docstring=self._get_docstring(node),\n        lines_collection=self.lines_collection,\n        modules_collection=self.modules_collection,\n    )\n    self.extensions.call(\"on_instance\", node=node, obj=module)\n    self.extensions.call(\"on_module_instance\", node=node, mod=module)\n    self.generic_inspect(node)\n    self.extensions.call(\"on_members\", node=node, obj=module)\n    self.extensions.call(\"on_module_members\", node=node, mod=module)\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_property","title":"inspect_property","text":"<pre><code>inspect_property(node: ObjectNode) -&gt; None\n</code></pre> <p>Inspect a property.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013          <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def inspect_property(self, node: ObjectNode) -&gt; None:\n\"\"\"Inspect a property.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    self.handle_function(node, {\"property\"})\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_staticmethod","title":"inspect_staticmethod","text":"<pre><code>inspect_staticmethod(node: ObjectNode) -&gt; None\n</code></pre> <p>Inspect a static method.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013          <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def inspect_staticmethod(self, node: ObjectNode) -&gt; None:\n\"\"\"Inspect a static method.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    self.handle_function(node, {\"staticmethod\"})\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.inspect","title":"inspect","text":"<pre><code>inspect(\n    module_name: str,\n    *,\n    filepath: Path | None = None,\n    import_paths: Sequence[str | Path] | None = None,\n    extensions: Extensions | None = None,\n    parent: Module | None = None,\n    docstring_parser: Parser | None = None,\n    docstring_options: dict[str, Any] | None = None,\n    lines_collection: LinesCollection | None = None,\n    modules_collection: ModulesCollection | None = None\n) -&gt; Module\n</code></pre> <p>Inspect a module.</p> <p>Parameters:</p> <ul> <li> module_name             (<code>str</code>)         \u2013          <p>The module name (as when importing [from] it).</p> </li> <li> filepath             (<code>Path | None</code>, default:                 <code>None</code> )         \u2013          <p>The module file path.</p> </li> <li> import_paths             (<code>Sequence[str | Path] | None</code>, default:                 <code>None</code> )         \u2013          <p>Paths to import the module from.</p> </li> <li> extensions             (<code>Extensions | None</code>, default:                 <code>None</code> )         \u2013          <p>The extensions to use when inspecting the module.</p> </li> <li> parent             (<code>Module | None</code>, default:                 <code>None</code> )         \u2013          <p>The optional parent of this module.</p> </li> <li> docstring_parser             (<code>Parser | None</code>, default:                 <code>None</code> )         \u2013          <p>The docstring parser to use. By default, no parsing is done.</p> </li> <li> docstring_options             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional docstring parsing options.</p> </li> <li> lines_collection             (<code>LinesCollection | None</code>, default:                 <code>None</code> )         \u2013          <p>A collection of source code lines.</p> </li> <li> modules_collection             (<code>ModulesCollection | None</code>, default:                 <code>None</code> )         \u2013          <p>A collection of modules.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013          <p>The module, with its members populated.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def inspect(\n    module_name: str,\n    *,\n    filepath: Path | None = None,\n    import_paths: Sequence[str | Path] | None = None,\n    extensions: Extensions | None = None,\n    parent: Module | None = None,\n    docstring_parser: Parser | None = None,\n    docstring_options: dict[str, Any] | None = None,\n    lines_collection: LinesCollection | None = None,\n    modules_collection: ModulesCollection | None = None,\n) -&gt; Module:\n\"\"\"Inspect a module.\n\n    Parameters:\n        module_name: The module name (as when importing [from] it).\n        filepath: The module file path.\n        import_paths: Paths to import the module from.\n        extensions: The extensions to use when inspecting the module.\n        parent: The optional parent of this module.\n        docstring_parser: The docstring parser to use. By default, no parsing is done.\n        docstring_options: Additional docstring parsing options.\n        lines_collection: A collection of source code lines.\n        modules_collection: A collection of modules.\n\n    Returns:\n        The module, with its members populated.\n    \"\"\"\n    import_paths = list(import_paths) if import_paths else []\n    if filepath and filepath.parent not in import_paths:\n        import_paths.insert(0, filepath.parent)\n    return Inspector(\n        module_name,\n        filepath,\n        extensions or Extensions(),\n        parent,\n        docstring_parser=docstring_parser,\n        docstring_options=docstring_options,\n        lines_collection=lines_collection,\n        modules_collection=modules_collection,\n    ).get_module(import_paths)\n</code></pre>"},{"location":"reference/griffe/agents/visitor/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> visitor","text":""},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor","title":"visitor","text":"<p>Code parsing and data extraction utilies.</p> <p>This module exposes a public function, <code>visit()</code>, which parses the module code using <code>parse()</code>, and returns a new <code>Module</code> instance, populating its members recursively, by using a <code>NodeVisitor</code>-like class.</p> <p>Classes:</p> <ul> <li> Visitor         \u2013          <p>This class is used to instantiate a visitor.</p> </li> </ul> <p>Functions:</p> <ul> <li> visit           \u2013            <p>Parse and visit a module file.</p> </li> </ul>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor","title":"Visitor","text":"<pre><code>Visitor(\n    module_name: str,\n    filepath: Path,\n    code: str,\n    extensions: Extensions,\n    parent: Module | None = None,\n    docstring_parser: Parser | None = None,\n    docstring_options: dict[str, Any] | None = None,\n    lines_collection: LinesCollection | None = None,\n    modules_collection: ModulesCollection | None = None,\n)\n</code></pre> <p>This class is used to instantiate a visitor.</p> <p>Visitors iterate on AST nodes to extract data from them.</p> <p>Parameters:</p> <ul> <li> module_name             (<code>str</code>)         \u2013          <p>The module name.</p> </li> <li> filepath             (<code>Path</code>)         \u2013          <p>The module filepath.</p> </li> <li> code             (<code>str</code>)         \u2013          <p>The module source code.</p> </li> <li> extensions             (<code>Extensions</code>)         \u2013          <p>The extensions to use when visiting.</p> </li> <li> parent             (<code>Module | None</code>, default:                 <code>None</code> )         \u2013          <p>An optional parent for the final module object.</p> </li> <li> docstring_parser             (<code>Parser | None</code>, default:                 <code>None</code> )         \u2013          <p>The docstring parser to use.</p> </li> <li> docstring_options             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>The docstring parsing options.</p> </li> <li> lines_collection             (<code>LinesCollection | None</code>, default:                 <code>None</code> )         \u2013          <p>A collection of source code lines.</p> </li> <li> modules_collection             (<code>ModulesCollection | None</code>, default:                 <code>None</code> )         \u2013          <p>A collection of modules.</p> </li> </ul> <p>Methods:</p> <ul> <li> decorators_to_labels           \u2013            <p>Build and return a set of labels based on decorators.</p> </li> <li> generic_visit           \u2013            <p>Extend the base generic visit with extensions.</p> </li> <li> get_base_property           \u2013            <p>Check decorators to return the base property in case of setters and deleters.</p> </li> <li> get_module           \u2013            <p>Build and return the object representing the module attached to this visitor.</p> </li> <li> handle_attribute           \u2013            <p>Handle an attribute (assignment) node.</p> </li> <li> handle_function           \u2013            <p>Handle a function definition node.</p> </li> <li> visit           \u2013            <p>Extend the base visit with extensions.</p> </li> <li> visit_annassign           \u2013            <p>Visit an annotated assignment node.</p> </li> <li> visit_assign           \u2013            <p>Visit an assignment node.</p> </li> <li> visit_asyncfunctiondef           \u2013            <p>Visit an async function definition node.</p> </li> <li> visit_augassign           \u2013            <p>Visit an augmented assignment node.</p> </li> <li> visit_classdef           \u2013            <p>Visit a class definition node.</p> </li> <li> visit_functiondef           \u2013            <p>Visit a function definition node.</p> </li> <li> visit_if           \u2013            <p>Visit an \"if\" node.</p> </li> <li> visit_import           \u2013            <p>Visit an import node.</p> </li> <li> visit_importfrom           \u2013            <p>Visit an \"import from\" node.</p> </li> <li> visit_module           \u2013            <p>Visit a module node.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def __init__(\n    self,\n    module_name: str,\n    filepath: Path,\n    code: str,\n    extensions: Extensions,\n    parent: Module | None = None,\n    docstring_parser: Parser | None = None,\n    docstring_options: dict[str, Any] | None = None,\n    lines_collection: LinesCollection | None = None,\n    modules_collection: ModulesCollection | None = None,\n) -&gt; None:\n\"\"\"Initialize the visitor.\n\n    Parameters:\n        module_name: The module name.\n        filepath: The module filepath.\n        code: The module source code.\n        extensions: The extensions to use when visiting.\n        parent: An optional parent for the final module object.\n        docstring_parser: The docstring parser to use.\n        docstring_options: The docstring parsing options.\n        lines_collection: A collection of source code lines.\n        modules_collection: A collection of modules.\n    \"\"\"\n    super().__init__()\n    self.module_name: str = module_name\n    self.filepath: Path = filepath\n    self.code: str = code\n    self.extensions: Extensions = extensions.attach_visitor(self)\n    self.parent: Module | None = parent\n    self.current: Module | Class = None  # type: ignore[assignment]\n    self.docstring_parser: Parser | None = docstring_parser\n    self.docstring_options: dict[str, Any] = docstring_options or {}\n    self.lines_collection: LinesCollection = lines_collection or LinesCollection()\n    self.modules_collection: ModulesCollection = modules_collection or ModulesCollection()\n    self.type_guarded: bool = False\n</code></pre>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.decorators_to_labels","title":"decorators_to_labels","text":"<pre><code>decorators_to_labels(\n    decorators: list[Decorator],\n) -&gt; set[str]\n</code></pre> <p>Build and return a set of labels based on decorators.</p> <p>Parameters:</p> <ul> <li> decorators             (<code>list[Decorator]</code>)         \u2013          <p>The decorators to check.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>set[str]</code>         \u2013          <p>A set of labels.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def decorators_to_labels(self, decorators: list[Decorator]) -&gt; set[str]:\n\"\"\"Build and return a set of labels based on decorators.\n\n    Parameters:\n        decorators: The decorators to check.\n\n    Returns:\n        A set of labels.\n    \"\"\"\n    labels = set()\n    for decorator in decorators:\n        callable_path = decorator.callable_path\n        if callable_path in builtin_decorators:\n            labels.add(builtin_decorators[callable_path])\n        elif callable_path in stdlib_decorators:\n            labels |= stdlib_decorators[callable_path]\n    return labels\n</code></pre>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.generic_visit","title":"generic_visit","text":"<pre><code>generic_visit(node: AST) -&gt; None\n</code></pre> <p>Extend the base generic visit with extensions.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST</code>)         \u2013          <p>The node to visit.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def generic_visit(self, node: ast.AST) -&gt; None:\n\"\"\"Extend the base generic visit with extensions.\n\n    Parameters:\n        node: The node to visit.\n    \"\"\"\n    for before_visitor in self.extensions.before_children_visit:\n        before_visitor.visit(node)\n    for child in ast_children(node):\n        self.visit(child)\n    for after_visitor in self.extensions.after_children_visit:\n        after_visitor.visit(node)\n</code></pre>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.get_base_property","title":"get_base_property","text":"<pre><code>get_base_property(\n    decorators: list[Decorator], function: Function\n) -&gt; str | None\n</code></pre> <p>Check decorators to return the base property in case of setters and deleters.</p> <p>Parameters:</p> <ul> <li> decorators             (<code>list[Decorator]</code>)         \u2013          <p>The decorators to check.</p> </li> </ul> <p>Returns:</p> <ul> <li> base_property (            <code>str | None</code> )        \u2013          <p>The property for which the setter/deleted is set.</p> </li> <li> property_function (            <code>str | None</code> )        \u2013          <p>Either <code>\"setter\"</code> or <code>\"deleter\"</code>.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def get_base_property(self, decorators: list[Decorator], function: Function) -&gt; str | None:\n\"\"\"Check decorators to return the base property in case of setters and deleters.\n\n    Parameters:\n        decorators: The decorators to check.\n\n    Returns:\n        base_property: The property for which the setter/deleted is set.\n        property_function: Either `\"setter\"` or `\"deleter\"`.\n    \"\"\"\n    for decorator in decorators:\n        try:\n            path, prop_function = decorator.callable_path.rsplit(\".\", 1)\n        except ValueError:\n            continue\n        property_setter_or_deleter = (\n            prop_function in {\"setter\", \"deleter\"}\n            and path == function.path\n            and self.current.get_member(function.name).has_labels({\"property\"})\n        )\n        if property_setter_or_deleter:\n            return prop_function\n    return None\n</code></pre>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.get_module","title":"get_module","text":"<pre><code>get_module() -&gt; Module\n</code></pre> <p>Build and return the object representing the module attached to this visitor.</p> <p>This method triggers a complete visit of the module nodes.</p> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013          <p>A module instance.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def get_module(self) -&gt; Module:\n\"\"\"Build and return the object representing the module attached to this visitor.\n\n    This method triggers a complete visit of the module nodes.\n\n    Returns:\n        A module instance.\n    \"\"\"\n    # optimization: equivalent to ast.parse, but with optimize=1 to remove assert statements\n    # TODO: with options, could use optimize=2 to remove docstrings\n    top_node = compile(self.code, mode=\"exec\", filename=str(self.filepath), flags=ast.PyCF_ONLY_AST, optimize=1)\n    self.visit(top_node)\n    return self.current.module\n</code></pre>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.handle_attribute","title":"handle_attribute","text":"<pre><code>handle_attribute(\n    node: Assign | AnnAssign,\n    annotation: str | Expr | None = None,\n) -&gt; None\n</code></pre> <p>Handle an attribute (assignment) node.</p> <p>Parameters:</p> <ul> <li> node             (<code>Assign | AnnAssign</code>)         \u2013          <p>The node to visit.</p> </li> <li> annotation             (<code>str | Expr | None</code>, default:                 <code>None</code> )         \u2013          <p>A potential annotation.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def handle_attribute(\n    self,\n    node: ast.Assign | ast.AnnAssign,\n    annotation: str | Expr | None = None,\n) -&gt; None:\n\"\"\"Handle an attribute (assignment) node.\n\n    Parameters:\n        node: The node to visit.\n        annotation: A potential annotation.\n    \"\"\"\n    self.extensions.call(\"on_node\", node=node)\n    self.extensions.call(\"on_attribute_node\", node=node)\n    parent = self.current\n    labels = set()\n\n    if parent.kind is Kind.MODULE:\n        try:\n            names = get_names(node)\n        except KeyError:  # unsupported nodes, like subscript\n            return\n        labels.add(\"module-attribute\")\n    elif parent.kind is Kind.CLASS:\n        try:\n            names = get_names(node)\n        except KeyError:  # unsupported nodes, like subscript\n            return\n\n        if isinstance(annotation, Expr) and annotation.is_classvar:\n            # explicit classvar: class attribute only\n            annotation = annotation.slice  # type: ignore[attr-defined]\n            labels.add(\"class-attribute\")\n        elif node.value:\n            # attribute assigned at class-level: available in instances as well\n            labels.add(\"class-attribute\")\n            labels.add(\"instance-attribute\")\n        else:\n            # annotated attribute only: not available at class-level\n            labels.add(\"instance-attribute\")\n\n    elif parent.kind is Kind.FUNCTION:\n        if parent.name != \"__init__\":\n            return\n        try:\n            names = get_instance_names(node)\n        except KeyError:  # unsupported nodes, like subscript\n            return\n        parent = parent.parent  # type: ignore[assignment]\n        labels.add(\"instance-attribute\")\n\n    if not names:\n        return\n\n    value = safe_get_expression(node.value, parent=self.current, parse_strings=False)\n\n    try:\n        docstring = self._get_docstring(ast_next(node), strict=True)\n    except (LastNodeError, AttributeError):\n        docstring = None\n\n    for name in names:\n        # TODO: handle assigns like x.y = z\n        # we need to resolve x.y and add z in its member\n        if \".\" in name:\n            continue\n\n        if name in parent.members:\n            # assigning multiple times\n            # TODO: might be better to inspect\n            if isinstance(node.parent, (ast.If, ast.ExceptHandler)):  # type: ignore[union-attr]\n                continue  # prefer \"no-exception\" case\n\n            existing_member = parent.members[name]\n            with suppress(AliasResolutionError, CyclicAliasError):\n                labels |= existing_member.labels\n                # forward previous docstring and annotation instead of erasing them\n                if existing_member.docstring and not docstring:\n                    docstring = existing_member.docstring\n                with suppress(AttributeError):\n                    if existing_member.annotation and not annotation:  # type: ignore[union-attr]\n                        annotation = existing_member.annotation  # type: ignore[union-attr]\n\n        attribute = Attribute(\n            name=name,\n            value=value,\n            annotation=annotation,\n            lineno=node.lineno,\n            endlineno=node.end_lineno,\n            docstring=docstring,\n            runtime=not self.type_guarded,\n        )\n        attribute.labels |= labels\n        parent.set_member(name, attribute)\n\n        if name == \"__all__\":\n            with suppress(AttributeError):\n                parent.exports = safe_get__all__(node, self.current)  # type: ignore[arg-type]\n        self.extensions.call(\"on_instance\", node=node, obj=attribute)\n        self.extensions.call(\"on_attribute_instance\", node=node, attr=attribute)\n</code></pre>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.handle_function","title":"handle_function","text":"<pre><code>handle_function(\n    node: AsyncFunctionDef | FunctionDef,\n    labels: set | None = None,\n) -&gt; None\n</code></pre> <p>Handle a function definition node.</p> <p>Parameters:</p> <ul> <li> node             (<code>AsyncFunctionDef | FunctionDef</code>)         \u2013          <p>The node to visit.</p> </li> <li> labels             (<code>set | None</code>, default:                 <code>None</code> )         \u2013          <p>Labels to add to the data object.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def handle_function(self, node: ast.AsyncFunctionDef | ast.FunctionDef, labels: set | None = None) -&gt; None:\n\"\"\"Handle a function definition node.\n\n    Parameters:\n        node: The node to visit.\n        labels: Labels to add to the data object.\n    \"\"\"\n    self.extensions.call(\"on_node\", node=node)\n    self.extensions.call(\"on_function_node\", node=node)\n\n    labels = labels or set()\n\n    # handle decorators\n    decorators = []\n    overload = False\n    if node.decorator_list:\n        lineno = node.decorator_list[0].lineno\n        for decorator_node in node.decorator_list:\n            decorator_value = safe_get_expression(decorator_node, parent=self.current, parse_strings=False)\n            if decorator_value is None:\n                continue\n            decorator = Decorator(\n                decorator_value,\n                lineno=decorator_node.lineno,\n                endlineno=decorator_node.end_lineno,\n            )\n            decorators.append(decorator)\n            overload |= decorator.callable_path in typing_overload\n    else:\n        lineno = node.lineno\n\n    labels |= self.decorators_to_labels(decorators)\n\n    if \"property\" in labels:\n        attribute = Attribute(\n            name=node.name,\n            value=None,\n            annotation=safe_get_annotation(node.returns, parent=self.current),\n            lineno=node.lineno,\n            endlineno=node.end_lineno,\n            docstring=self._get_docstring(node),\n            runtime=not self.type_guarded,\n        )\n        attribute.labels |= labels\n        self.current.set_member(node.name, attribute)\n        self.extensions.call(\"on_instance\", node=node, obj=attribute)\n        self.extensions.call(\"on_attribute_instance\", node=node, attr=attribute)\n        return\n\n    # handle parameters\n    parameters = Parameters()\n    annotation: str | Expr | None\n\n    posonlyargs = node.args.posonlyargs\n\n    # TODO: probably some optimizations to do here\n    args_kinds_defaults: Iterable = reversed(\n        (\n            *zip_longest(\n                reversed(\n                    (\n                        *zip_longest(\n                            posonlyargs,\n                            [],\n                            fillvalue=ParameterKind.positional_only,\n                        ),\n                        *zip_longest(node.args.args, [], fillvalue=ParameterKind.positional_or_keyword),\n                    ),\n                ),\n                reversed(node.args.defaults),\n                fillvalue=None,\n            ),\n        ),\n    )\n    arg: ast.arg\n    kind: ParameterKind\n    arg_default: ast.AST | None\n    for (arg, kind), arg_default in args_kinds_defaults:\n        annotation = safe_get_annotation(arg.annotation, parent=self.current)\n        default = safe_get_expression(arg_default, parent=self.current, parse_strings=False)\n        parameters.add(Parameter(arg.arg, annotation=annotation, kind=kind, default=default))\n\n    if node.args.vararg:\n        annotation = safe_get_annotation(node.args.vararg.annotation, parent=self.current)\n        parameters.add(\n            Parameter(\n                node.args.vararg.arg,\n                annotation=annotation,\n                kind=ParameterKind.var_positional,\n                default=\"()\",\n            ),\n        )\n\n    # TODO: probably some optimizations to do here\n    kwargs_defaults: Iterable = reversed(\n        (\n            *zip_longest(\n                reversed(node.args.kwonlyargs),\n                reversed(node.args.kw_defaults),\n                fillvalue=None,\n            ),\n        ),\n    )\n    kwarg: ast.arg\n    kwarg_default: ast.AST | None\n    for kwarg, kwarg_default in kwargs_defaults:\n        annotation = safe_get_annotation(kwarg.annotation, parent=self.current)\n        default = safe_get_expression(kwarg_default, parent=self.current, parse_strings=False)\n        parameters.add(\n            Parameter(kwarg.arg, annotation=annotation, kind=ParameterKind.keyword_only, default=default),\n        )\n\n    if node.args.kwarg:\n        annotation = safe_get_annotation(node.args.kwarg.annotation, parent=self.current)\n        parameters.add(\n            Parameter(\n                node.args.kwarg.arg,\n                annotation=annotation,\n                kind=ParameterKind.var_keyword,\n                default=\"{}\",\n            ),\n        )\n\n    function = Function(\n        name=node.name,\n        lineno=lineno,\n        endlineno=node.end_lineno,\n        parameters=parameters,\n        returns=safe_get_annotation(node.returns, parent=self.current),\n        decorators=decorators,\n        docstring=self._get_docstring(node),\n        runtime=not self.type_guarded,\n        parent=self.current,\n    )\n\n    property_function = self.get_base_property(decorators, function)\n\n    if overload:\n        self.current.overloads[function.name].append(function)\n    elif property_function:\n        base_property: Function = self.current.members[node.name]  # type: ignore[assignment]\n        if property_function == \"setter\":\n            base_property.setter = function\n            base_property.labels.add(\"writable\")\n        elif property_function == \"deleter\":\n            base_property.deleter = function\n            base_property.labels.add(\"deletable\")\n    else:\n        self.current.set_member(node.name, function)\n        if self.current.kind in {Kind.MODULE, Kind.CLASS} and self.current.overloads[function.name]:\n            function.overloads = self.current.overloads[function.name]\n            del self.current.overloads[function.name]\n\n    function.labels |= labels\n\n    self.extensions.call(\"on_instance\", node=node, obj=function)\n    self.extensions.call(\"on_function_instance\", node=node, func=function)\n    if self.current.kind is Kind.CLASS and function.name == \"__init__\":\n        self.current = function  # type: ignore[assignment]  # temporary assign a function\n        self.generic_visit(node)\n        self.current = self.current.parent  # type: ignore[assignment]\n</code></pre>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit","title":"visit","text":"<pre><code>visit(node: AST) -&gt; None\n</code></pre> <p>Extend the base visit with extensions.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST</code>)         \u2013          <p>The node to visit.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def visit(self, node: ast.AST) -&gt; None:\n\"\"\"Extend the base visit with extensions.\n\n    Parameters:\n        node: The node to visit.\n    \"\"\"\n    for before_visitor in self.extensions.before_visit:\n        before_visitor.visit(node)\n    getattr(self, f\"visit_{ast_kind(node)}\", self.generic_visit)(node)\n    for after_visitor in self.extensions.after_visit:\n        after_visitor.visit(node)\n</code></pre>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_annassign","title":"visit_annassign","text":"<pre><code>visit_annassign(node: AnnAssign) -&gt; None\n</code></pre> <p>Visit an annotated assignment node.</p> <p>Parameters:</p> <ul> <li> node             (<code>AnnAssign</code>)         \u2013          <p>The node to visit.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def visit_annassign(self, node: ast.AnnAssign) -&gt; None:\n\"\"\"Visit an annotated assignment node.\n\n    Parameters:\n        node: The node to visit.\n    \"\"\"\n    self.handle_attribute(node, safe_get_annotation(node.annotation, parent=self.current))\n</code></pre>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_assign","title":"visit_assign","text":"<pre><code>visit_assign(node: Assign) -&gt; None\n</code></pre> <p>Visit an assignment node.</p> <p>Parameters:</p> <ul> <li> node             (<code>Assign</code>)         \u2013          <p>The node to visit.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def visit_assign(self, node: ast.Assign) -&gt; None:\n\"\"\"Visit an assignment node.\n\n    Parameters:\n        node: The node to visit.\n    \"\"\"\n    self.handle_attribute(node)\n</code></pre>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_asyncfunctiondef","title":"visit_asyncfunctiondef","text":"<pre><code>visit_asyncfunctiondef(node: AsyncFunctionDef) -&gt; None\n</code></pre> <p>Visit an async function definition node.</p> <p>Parameters:</p> <ul> <li> node             (<code>AsyncFunctionDef</code>)         \u2013          <p>The node to visit.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def visit_asyncfunctiondef(self, node: ast.AsyncFunctionDef) -&gt; None:\n\"\"\"Visit an async function definition node.\n\n    Parameters:\n        node: The node to visit.\n    \"\"\"\n    self.handle_function(node, labels={\"async\"})\n</code></pre>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_augassign","title":"visit_augassign","text":"<pre><code>visit_augassign(node: AugAssign) -&gt; None\n</code></pre> <p>Visit an augmented assignment node.</p> <p>Parameters:</p> <ul> <li> node             (<code>AugAssign</code>)         \u2013          <p>The node to visit.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def visit_augassign(self, node: ast.AugAssign) -&gt; None:\n\"\"\"Visit an augmented assignment node.\n\n    Parameters:\n        node: The node to visit.\n    \"\"\"\n    with suppress(AttributeError):\n        all_augment = (\n            node.target.id == \"__all__\"  # type: ignore[union-attr]\n            and self.current.is_module\n            and isinstance(node.op, ast.Add)\n        )\n        if all_augment:\n            # we assume exports is not None at this point\n            self.current.exports.extend(safe_get__all__(node, self.current))  # type: ignore[arg-type,union-attr]\n</code></pre>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_classdef","title":"visit_classdef","text":"<pre><code>visit_classdef(node: ClassDef) -&gt; None\n</code></pre> <p>Visit a class definition node.</p> <p>Parameters:</p> <ul> <li> node             (<code>ClassDef</code>)         \u2013          <p>The node to visit.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def visit_classdef(self, node: ast.ClassDef) -&gt; None:\n\"\"\"Visit a class definition node.\n\n    Parameters:\n        node: The node to visit.\n    \"\"\"\n    self.extensions.call(\"on_node\", node=node)\n    self.extensions.call(\"on_class_node\", node=node)\n\n    # handle decorators\n    decorators = []\n    if node.decorator_list:\n        lineno = node.decorator_list[0].lineno\n        for decorator_node in node.decorator_list:\n            decorators.append(\n                Decorator(\n                    safe_get_expression(decorator_node, parent=self.current, parse_strings=False),  # type: ignore[arg-type]\n                    lineno=decorator_node.lineno,\n                    endlineno=decorator_node.end_lineno,\n                ),\n            )\n    else:\n        lineno = node.lineno\n\n    # handle base classes\n    bases = []\n    if node.bases:\n        for base in node.bases:\n            bases.append(safe_get_base_class(base, parent=self.current))\n\n    class_ = Class(\n        name=node.name,\n        lineno=lineno,\n        endlineno=node.end_lineno,\n        docstring=self._get_docstring(node),\n        decorators=decorators,\n        bases=bases,  # type: ignore[arg-type]\n        runtime=not self.type_guarded,\n    )\n    class_.labels |= self.decorators_to_labels(decorators)\n    self.current.set_member(node.name, class_)\n    self.current = class_\n    self.extensions.call(\"on_instance\", node=node, obj=class_)\n    self.extensions.call(\"on_class_instance\", node=node, cls=class_)\n    self.generic_visit(node)\n    self.extensions.call(\"on_members\", node=node, obj=class_)\n    self.extensions.call(\"on_class_members\", node=node, cls=class_)\n    self.current = self.current.parent  # type: ignore[assignment]\n</code></pre>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_functiondef","title":"visit_functiondef","text":"<pre><code>visit_functiondef(node: FunctionDef) -&gt; None\n</code></pre> <p>Visit a function definition node.</p> <p>Parameters:</p> <ul> <li> node             (<code>FunctionDef</code>)         \u2013          <p>The node to visit.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def visit_functiondef(self, node: ast.FunctionDef) -&gt; None:\n\"\"\"Visit a function definition node.\n\n    Parameters:\n        node: The node to visit.\n    \"\"\"\n    self.handle_function(node)\n</code></pre>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_if","title":"visit_if","text":"<pre><code>visit_if(node: If) -&gt; None\n</code></pre> <p>Visit an \"if\" node.</p> <p>Parameters:</p> <ul> <li> node             (<code>If</code>)         \u2013          <p>The node to visit.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def visit_if(self, node: ast.If) -&gt; None:\n\"\"\"Visit an \"if\" node.\n\n    Parameters:\n        node: The node to visit.\n    \"\"\"\n    if isinstance(node.parent, (ast.Module, ast.ClassDef)):  # type: ignore[attr-defined]\n        condition = safe_get_condition(node.test, parent=self.current, log_level=None)\n        if str(condition) in {\"typing.TYPE_CHECKING\", \"TYPE_CHECKING\"}:\n            self.type_guarded = True\n    self.generic_visit(node)\n    self.type_guarded = False\n</code></pre>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_import","title":"visit_import","text":"<pre><code>visit_import(node: Import) -&gt; None\n</code></pre> <p>Visit an import node.</p> <p>Parameters:</p> <ul> <li> node             (<code>Import</code>)         \u2013          <p>The node to visit.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def visit_import(self, node: ast.Import) -&gt; None:\n\"\"\"Visit an import node.\n\n    Parameters:\n        node: The node to visit.\n    \"\"\"\n    for name in node.names:\n        alias_path = name.name.split(\".\", 1)[0]\n        alias_name = name.asname or alias_path.split(\".\", 1)[0]\n        self.current.imports[alias_name] = alias_path\n        self.current.set_member(\n            alias_name,\n            Alias(\n                alias_name,\n                alias_path,\n                lineno=node.lineno,\n                endlineno=node.end_lineno,\n                runtime=not self.type_guarded,\n            ),\n        )\n</code></pre>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_importfrom","title":"visit_importfrom","text":"<pre><code>visit_importfrom(node: ImportFrom) -&gt; None\n</code></pre> <p>Visit an \"import from\" node.</p> <p>Parameters:</p> <ul> <li> node             (<code>ImportFrom</code>)         \u2013          <p>The node to visit.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def visit_importfrom(self, node: ast.ImportFrom) -&gt; None:\n\"\"\"Visit an \"import from\" node.\n\n    Parameters:\n        node: The node to visit.\n    \"\"\"\n    for name in node.names:\n        if not node.module and node.level == 1 and not name.asname:\n            # special case: when being in `a` and doing `from . import b`,\n            # we are effectively creating a member `b` in `a` that is pointing to `a.b`\n            # -&gt; cyclic alias! in that case, we just skip it, as both the member and module\n            # have the same name and can be accessed the same way\n            continue\n\n        alias_path = relative_to_absolute(node, name, self.current.module)\n        if name.name == \"*\":\n            alias_name = alias_path.replace(\".\", \"/\")\n            alias_path = alias_path.replace(\".*\", \"\")\n        else:\n            alias_name = name.asname or name.name\n            self.current.imports[alias_name] = alias_path\n        self.current.set_member(\n            alias_name,\n            Alias(\n                alias_name,\n                alias_path,\n                lineno=node.lineno,\n                endlineno=node.end_lineno,\n                runtime=not self.type_guarded,\n            ),\n        )\n</code></pre>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_module","title":"visit_module","text":"<pre><code>visit_module(node: Module) -&gt; None\n</code></pre> <p>Visit a module node.</p> <p>Parameters:</p> <ul> <li> node             (<code>Module</code>)         \u2013          <p>The node to visit.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def visit_module(self, node: ast.Module) -&gt; None:\n\"\"\"Visit a module node.\n\n    Parameters:\n        node: The node to visit.\n    \"\"\"\n    self.extensions.call(\"on_node\", node=node)\n    self.extensions.call(\"on_module_node\", node=node)\n    self.current = module = Module(\n        name=self.module_name,\n        filepath=self.filepath,\n        parent=self.parent,\n        docstring=self._get_docstring(node),\n        lines_collection=self.lines_collection,\n        modules_collection=self.modules_collection,\n    )\n    self.extensions.call(\"on_instance\", node=node, obj=module)\n    self.extensions.call(\"on_module_instance\", node=node, mod=module)\n    self.generic_visit(node)\n    self.extensions.call(\"on_members\", node=node, obj=module)\n    self.extensions.call(\"on_module_members\", node=node, mod=module)\n</code></pre>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.visit","title":"visit","text":"<pre><code>visit(\n    module_name: str,\n    filepath: Path,\n    code: str,\n    *,\n    extensions: Extensions | None = None,\n    parent: Module | None = None,\n    docstring_parser: Parser | None = None,\n    docstring_options: dict[str, Any] | None = None,\n    lines_collection: LinesCollection | None = None,\n    modules_collection: ModulesCollection | None = None\n) -&gt; Module\n</code></pre> <p>Parse and visit a module file.</p> <p>Parameters:</p> <ul> <li> module_name             (<code>str</code>)         \u2013          <p>The module name (as when importing [from] it).</p> </li> <li> filepath             (<code>Path</code>)         \u2013          <p>The module file path.</p> </li> <li> code             (<code>str</code>)         \u2013          <p>The module contents.</p> </li> <li> extensions             (<code>Extensions | None</code>, default:                 <code>None</code> )         \u2013          <p>The extensions to use when visiting the AST.</p> </li> <li> parent             (<code>Module | None</code>, default:                 <code>None</code> )         \u2013          <p>The optional parent of this module.</p> </li> <li> docstring_parser             (<code>Parser | None</code>, default:                 <code>None</code> )         \u2013          <p>The docstring parser to use. By default, no parsing is done.</p> </li> <li> docstring_options             (<code>dict[str, Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>Additional docstring parsing options.</p> </li> <li> lines_collection             (<code>LinesCollection | None</code>, default:                 <code>None</code> )         \u2013          <p>A collection of source code lines.</p> </li> <li> modules_collection             (<code>ModulesCollection | None</code>, default:                 <code>None</code> )         \u2013          <p>A collection of modules.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013          <p>The module, with its members populated.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def visit(\n    module_name: str,\n    filepath: Path,\n    code: str,\n    *,\n    extensions: Extensions | None = None,\n    parent: Module | None = None,\n    docstring_parser: Parser | None = None,\n    docstring_options: dict[str, Any] | None = None,\n    lines_collection: LinesCollection | None = None,\n    modules_collection: ModulesCollection | None = None,\n) -&gt; Module:\n\"\"\"Parse and visit a module file.\n\n    Parameters:\n        module_name: The module name (as when importing [from] it).\n        filepath: The module file path.\n        code: The module contents.\n        extensions: The extensions to use when visiting the AST.\n        parent: The optional parent of this module.\n        docstring_parser: The docstring parser to use. By default, no parsing is done.\n        docstring_options: Additional docstring parsing options.\n        lines_collection: A collection of source code lines.\n        modules_collection: A collection of modules.\n\n    Returns:\n        The module, with its members populated.\n    \"\"\"\n    return Visitor(\n        module_name,\n        filepath,\n        code,\n        extensions or Extensions(),\n        parent,\n        docstring_parser=docstring_parser,\n        docstring_options=docstring_options,\n        lines_collection=lines_collection,\n        modules_collection=modules_collection,\n    ).get_module()\n</code></pre>"},{"location":"reference/griffe/agents/nodes/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> nodes","text":""},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes","title":"nodes","text":"<p>This module contains utilities for extracting information from nodes.</p> <p>Classes:</p> <ul> <li> ObjectKind         \u2013          <p>Enumeration for the different kinds of objects.</p> </li> <li> ObjectNode         \u2013          <p>Helper class to represent an object tree.</p> </li> </ul> <p>Functions:</p> <ul> <li> ast_children           \u2013            <p>Return the children of an AST node.</p> </li> <li> ast_first_child           \u2013            <p>Return the first child of this node.</p> </li> <li> ast_kind           \u2013            <p>Return the kind of an AST node.</p> </li> <li> ast_last_child           \u2013            <p>Return the lasts child of this node.</p> </li> <li> ast_next           \u2013            <p>Return the next sibling of this node.</p> </li> <li> ast_next_siblings           \u2013            <p>Return the next siblings of this node, starting from the closest.</p> </li> <li> ast_previous           \u2013            <p>Return the previous sibling of this node.</p> </li> <li> ast_previous_siblings           \u2013            <p>Return the previous siblings of this node, starting from the closest.</p> </li> <li> ast_siblings           \u2013            <p>Return the siblings of this node.</p> </li> <li> get__all__           \u2013            <p>Get the values declared in <code>__all__</code>.</p> </li> <li> get_call_keyword_arguments           \u2013            <p>Get the list of keyword argument names and values from a Call node.</p> </li> <li> get_docstring           \u2013            <p>Extract a docstring.</p> </li> <li> get_expression           \u2013            <p>Build an expression from an AST.</p> </li> <li> get_instance_names           \u2013            <p>Extract names from an assignment node, only for instance attributes.</p> </li> <li> get_name           \u2013            <p>Extract name from an assignment node.</p> </li> <li> get_names           \u2013            <p>Extract names from an assignment node.</p> </li> <li> get_value           \u2013            <p>Get the string representation of a node.</p> </li> <li> relative_to_absolute           \u2013            <p>Convert a relative import path to an absolute one.</p> </li> <li> safe_get__all__           \u2013            <p>Safely (no exception) extract values in <code>__all__</code>.</p> </li> <li> safe_get_expression           \u2013            <p>Safely (no exception) build a resolvable annotation.</p> </li> <li> safe_get_value           \u2013            <p>Safely (no exception) get the string representation of a node.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectKind","title":"ObjectKind","text":"<p>             Bases: <code>Enum</code></p> <p>Enumeration for the different kinds of objects.</p> <p>Attributes:</p> <ul> <li> ATTRIBUTE             (<code>str</code>)         \u2013          <p>Attributes.</p> </li> <li> BUILTIN_FUNCTION             (<code>str</code>)         \u2013          <p>Built-in functions.</p> </li> <li> BUILTIN_METHOD             (<code>str</code>)         \u2013          <p>Built-in ethods.</p> </li> <li> CACHED_PROPERTY             (<code>str</code>)         \u2013          <p>Cached properties.</p> </li> <li> CLASS             (<code>str</code>)         \u2013          <p>Classes.</p> </li> <li> CLASSMETHOD             (<code>str</code>)         \u2013          <p>Class methods.</p> </li> <li> COROUTINE             (<code>str</code>)         \u2013          <p>Coroutines</p> </li> <li> FUNCTION             (<code>str</code>)         \u2013          <p>Functions.</p> </li> <li> METHOD             (<code>str</code>)         \u2013          <p>Methods.</p> </li> <li> METHOD_DESCRIPTOR             (<code>str</code>)         \u2013          <p>Method descriptors.</p> </li> <li> MODULE             (<code>str</code>)         \u2013          <p>Modules.</p> </li> <li> PROPERTY             (<code>str</code>)         \u2013          <p>Properties.</p> </li> <li> STATICMETHOD             (<code>str</code>)         \u2013          <p>Static methods.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectKind.ATTRIBUTE","title":"ATTRIBUTE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ATTRIBUTE: str = 'attribute'\n</code></pre> <p>Attributes.</p>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectKind.BUILTIN_FUNCTION","title":"BUILTIN_FUNCTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BUILTIN_FUNCTION: str = 'builtin_function'\n</code></pre> <p>Built-in functions.</p>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectKind.BUILTIN_METHOD","title":"BUILTIN_METHOD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BUILTIN_METHOD: str = 'builtin_method'\n</code></pre> <p>Built-in ethods.</p>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectKind.CACHED_PROPERTY","title":"CACHED_PROPERTY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CACHED_PROPERTY: str = 'cached_property'\n</code></pre> <p>Cached properties.</p>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectKind.CLASS","title":"CLASS  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CLASS: str = 'class'\n</code></pre> <p>Classes.</p>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectKind.CLASSMETHOD","title":"CLASSMETHOD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CLASSMETHOD: str = 'classmethod'\n</code></pre> <p>Class methods.</p>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectKind.COROUTINE","title":"COROUTINE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>COROUTINE: str = 'coroutine'\n</code></pre> <p>Coroutines</p>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectKind.FUNCTION","title":"FUNCTION  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FUNCTION: str = 'function'\n</code></pre> <p>Functions.</p>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectKind.METHOD","title":"METHOD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>METHOD: str = 'method'\n</code></pre> <p>Methods.</p>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectKind.METHOD_DESCRIPTOR","title":"METHOD_DESCRIPTOR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>METHOD_DESCRIPTOR: str = 'method_descriptor'\n</code></pre> <p>Method descriptors.</p>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectKind.MODULE","title":"MODULE  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MODULE: str = 'module'\n</code></pre> <p>Modules.</p>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectKind.PROPERTY","title":"PROPERTY  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>PROPERTY: str = 'property'\n</code></pre> <p>Properties.</p>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectKind.STATICMETHOD","title":"STATICMETHOD  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STATICMETHOD: str = 'staticmethod'\n</code></pre> <p>Static methods.</p>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode","title":"ObjectNode","text":"<pre><code>ObjectNode(\n    obj: Any, name: str, parent: ObjectNode | None = None\n)\n</code></pre> <p>Helper class to represent an object tree.</p> <p>It's not really a tree but more a backward-linked list: each node has a reference to its parent, but not to its child (for simplicity purposes and to avoid bugs).</p> <p>Each node stores an object, its name, and a reference to its parent node.</p> <p>Attributes:</p> <ul> <li> obj             (<code>Any</code>)         \u2013          <p>The actual Python object.</p> </li> <li> name             (<code>str</code>)         \u2013          <p>The Python object's name.</p> </li> <li> parent             (<code>ObjectNode | None</code>)         \u2013          <p>The parent node.</p> </li> </ul> <p>Parameters:</p> <ul> <li> obj             (<code>Any</code>)         \u2013          <p>A Python object.</p> </li> <li> name             (<code>str</code>)         \u2013          <p>The object's name.</p> </li> <li> parent             (<code>ObjectNode | None</code>, default:                 <code>None</code> )         \u2013          <p>The object's parent node.</p> </li> </ul> <p>Methods:</p> <ul> </ul> <p>Attributes:</p> <ul> <li> alias_target_path             (<code>str | None</code>)         \u2013          <p>Alias target path of this node, if the node should be an alias.</p> </li> <li> children             (<code>Sequence[ObjectNode]</code>)         \u2013          <p>Build and return the children of this node.</p> </li> <li> is_builtin_function             (<code>bool</code>)         \u2013          <p>Tell if this node's object is a builtin function.</p> </li> <li> is_builtin_method             (<code>bool</code>)         \u2013          <p>Tell if this node's object is a builtin method.</p> </li> <li> is_cached_property             (<code>bool</code>)         \u2013          <p>Tell if this node's object is a cached property.</p> </li> <li> is_class             (<code>bool</code>)         \u2013          <p>Tell if this node's object is a class.</p> </li> <li> is_classmethod             (<code>bool</code>)         \u2013          <p>Tell if this node's object is a classmethod.</p> </li> <li> is_coroutine             (<code>bool</code>)         \u2013          <p>Tell if this node's object is a coroutine.</p> </li> <li> is_function             (<code>bool</code>)         \u2013          <p>Tell if this node's object is a function.</p> </li> <li> is_method             (<code>bool</code>)         \u2013          <p>Tell if this node's object is a method.</p> </li> <li> is_method_descriptor             (<code>bool</code>)         \u2013          <p>Tell if this node's object is a method descriptor.</p> </li> <li> is_module             (<code>bool</code>)         \u2013          <p>Tell if this node's object is a module.</p> </li> <li> is_property             (<code>bool</code>)         \u2013          <p>Tell if this node's object is a property.</p> </li> <li> is_staticmethod             (<code>bool</code>)         \u2013          <p>Tell if this node's object is a staticmethod.</p> </li> <li> kind             (<code>ObjectKind</code>)         \u2013          <p>Return the kind of this node.</p> </li> <li> module             (<code>ObjectNode</code>)         \u2013          <p>The object's module.</p> </li> <li> parent_is_class             (<code>bool</code>)         \u2013          <p>Tell if the object of this node's parent is a class.</p> </li> <li> path             (<code>str</code>)         \u2013          <p>The object's (Python) path.</p> </li> </ul> Source code in <code>src/griffe/agents/nodes/_runtime.py</code> <pre><code>def __init__(self, obj: Any, name: str, parent: ObjectNode | None = None) -&gt; None:\n\"\"\"Initialize the object.\n\n    Arguments:\n        obj: A Python object.\n        name: The object's name.\n        parent: The object's parent node.\n    \"\"\"\n    try:\n        obj = inspect.unwrap(obj)\n    except Exception as error:  # noqa: BLE001\n        # inspect.unwrap at some point runs hasattr(obj, \"__wrapped__\"),\n        # which triggers the __getattr__ method of the object, which in\n        # turn can raise various exceptions. Probably not just __getattr__.\n        # See https://github.com/pawamoy/pytkdocs/issues/45\n        logger.debug(f\"Could not unwrap {name}: {error!r}\")\n\n    self.obj: Any = obj\n    self.name: str = name\n    self.parent: ObjectNode | None = parent\n</code></pre>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.alias_target_path","title":"alias_target_path  <code>cached</code> <code>property</code>","text":"<pre><code>alias_target_path: str | None\n</code></pre> <p>Alias target path of this node, if the node should be an alias.</p>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.children","title":"children  <code>cached</code> <code>property</code>","text":"<pre><code>children: Sequence[ObjectNode]\n</code></pre> <p>Build and return the children of this node.</p> <p>Returns:</p> <ul> <li> <code>Sequence[ObjectNode]</code>         \u2013          <p>A list of children.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_builtin_function","title":"is_builtin_function  <code>cached</code> <code>property</code>","text":"<pre><code>is_builtin_function: bool\n</code></pre> <p>Tell if this node's object is a builtin function.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>If this node's object is a builtin function.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_builtin_method","title":"is_builtin_method  <code>cached</code> <code>property</code>","text":"<pre><code>is_builtin_method: bool\n</code></pre> <p>Tell if this node's object is a builtin method.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>If this node's object is a builtin method.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_cached_property","title":"is_cached_property  <code>cached</code> <code>property</code>","text":"<pre><code>is_cached_property: bool\n</code></pre> <p>Tell if this node's object is a cached property.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>If this node's object is a cached property.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_class","title":"is_class  <code>cached</code> <code>property</code>","text":"<pre><code>is_class: bool\n</code></pre> <p>Tell if this node's object is a class.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>If this node's object is a class.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_classmethod","title":"is_classmethod  <code>cached</code> <code>property</code>","text":"<pre><code>is_classmethod: bool\n</code></pre> <p>Tell if this node's object is a classmethod.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>If this node's object is a classmethod.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_coroutine","title":"is_coroutine  <code>cached</code> <code>property</code>","text":"<pre><code>is_coroutine: bool\n</code></pre> <p>Tell if this node's object is a coroutine.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>If this node's object is a coroutine.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_function","title":"is_function  <code>cached</code> <code>property</code>","text":"<pre><code>is_function: bool\n</code></pre> <p>Tell if this node's object is a function.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>If this node's object is a function.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_method","title":"is_method  <code>cached</code> <code>property</code>","text":"<pre><code>is_method: bool\n</code></pre> <p>Tell if this node's object is a method.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>If this node's object is a method.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_method_descriptor","title":"is_method_descriptor  <code>cached</code> <code>property</code>","text":"<pre><code>is_method_descriptor: bool\n</code></pre> <p>Tell if this node's object is a method descriptor.</p> <p>Built-in methods (e.g. those implemented in C/Rust) are often method descriptors, rather than normal methods.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>If this node's object is a method descriptor.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_module","title":"is_module  <code>cached</code> <code>property</code>","text":"<pre><code>is_module: bool\n</code></pre> <p>Tell if this node's object is a module.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>The root of the tree.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_property","title":"is_property  <code>cached</code> <code>property</code>","text":"<pre><code>is_property: bool\n</code></pre> <p>Tell if this node's object is a property.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>If this node's object is a property.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_staticmethod","title":"is_staticmethod  <code>cached</code> <code>property</code>","text":"<pre><code>is_staticmethod: bool\n</code></pre> <p>Tell if this node's object is a staticmethod.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>If this node's object is a staticmethod.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.kind","title":"kind  <code>property</code>","text":"<pre><code>kind: ObjectKind\n</code></pre> <p>Return the kind of this node.</p> <p>Returns:</p> <ul> <li> <code>ObjectKind</code>         \u2013          <p>The node kind.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.module","title":"module  <code>property</code>","text":"<pre><code>module: ObjectNode\n</code></pre> <p>The object's module.</p>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.parent_is_class","title":"parent_is_class  <code>cached</code> <code>property</code>","text":"<pre><code>parent_is_class: bool\n</code></pre> <p>Tell if the object of this node's parent is a class.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>If the object of this node's parent is a class.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.path","title":"path  <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>The object's (Python) path.</p>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ast_children","title":"ast_children","text":"<pre><code>ast_children(node: AST) -&gt; Iterator[AST]\n</code></pre> <p>Return the children of an AST node.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST</code>)         \u2013          <p>The AST node.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>AST</code>         \u2013          <p>The node children.</p> </li> </ul> Source code in <code>src/griffe/agents/nodes/_ast.py</code> <pre><code>def ast_children(node: AST) -&gt; Iterator[AST]:\n\"\"\"Return the children of an AST node.\n\n    Parameters:\n        node: The AST node.\n\n    Yields:\n        The node children.\n    \"\"\"\n    for field_name in node._fields:\n        try:\n            field = getattr(node, field_name)\n        except AttributeError:\n            continue\n        if isinstance(field, AST):\n            field.parent = node  # type: ignore[attr-defined]\n            yield field\n        elif isinstance(field, list):\n            for child in field:\n                if isinstance(child, AST):\n                    child.parent = node  # type: ignore[attr-defined]\n                    yield child\n</code></pre>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ast_first_child","title":"ast_first_child","text":"<pre><code>ast_first_child(node: AST) -&gt; AST\n</code></pre> <p>Return the first child of this node.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST</code>)         \u2013          <p>The AST node.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>LastNodeError</code>           \u2013          <p>When the node does not have children.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AST</code>         \u2013          <p>The child.</p> </li> </ul> Source code in <code>src/griffe/agents/nodes/_ast.py</code> <pre><code>def ast_first_child(node: AST) -&gt; AST:\n\"\"\"Return the first child of this node.\n\n    Parameters:\n        node: The AST node.\n\n    Raises:\n        LastNodeError: When the node does not have children.\n\n    Returns:\n        The child.\n    \"\"\"\n    try:\n        return next(ast_children(node))\n    except StopIteration as error:\n        raise LastNodeError(\"there are no children node\") from error\n</code></pre>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ast_kind","title":"ast_kind","text":"<pre><code>ast_kind(node: AST) -&gt; str\n</code></pre> <p>Return the kind of an AST node.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST</code>)         \u2013          <p>The AST node.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The node kind.</p> </li> </ul> Source code in <code>src/griffe/agents/nodes/_ast.py</code> <pre><code>def ast_kind(node: AST) -&gt; str:\n\"\"\"Return the kind of an AST node.\n\n    Parameters:\n        node: The AST node.\n\n    Returns:\n        The node kind.\n    \"\"\"\n    return node.__class__.__name__.lower()\n</code></pre>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ast_last_child","title":"ast_last_child","text":"<pre><code>ast_last_child(node: AST) -&gt; AST\n</code></pre> <p>Return the lasts child of this node.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST</code>)         \u2013          <p>The AST node.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>LastNodeError</code>           \u2013          <p>When the node does not have children.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AST</code>         \u2013          <p>The child.</p> </li> </ul> Source code in <code>src/griffe/agents/nodes/_ast.py</code> <pre><code>def ast_last_child(node: AST) -&gt; AST:\n\"\"\"Return the lasts child of this node.\n\n    Parameters:\n        node: The AST node.\n\n    Raises:\n        LastNodeError: When the node does not have children.\n\n    Returns:\n        The child.\n    \"\"\"\n    try:\n        *_, last = ast_children(node)\n    except ValueError as error:\n        raise LastNodeError(\"there are no children node\") from error\n    return last\n</code></pre>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ast_next","title":"ast_next","text":"<pre><code>ast_next(node: AST) -&gt; AST\n</code></pre> <p>Return the next sibling of this node.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST</code>)         \u2013          <p>The AST node.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>LastNodeError</code>           \u2013          <p>When the node does not have next siblings.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AST</code>         \u2013          <p>The sibling.</p> </li> </ul> Source code in <code>src/griffe/agents/nodes/_ast.py</code> <pre><code>def ast_next(node: AST) -&gt; AST:\n\"\"\"Return the next sibling of this node.\n\n    Parameters:\n        node: The AST node.\n\n    Raises:\n        LastNodeError: When the node does not have next siblings.\n\n    Returns:\n        The sibling.\n    \"\"\"\n    try:\n        return next(ast_next_siblings(node))\n    except StopIteration:\n        raise LastNodeError(\"there is no next node\") from None\n</code></pre>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ast_next_siblings","title":"ast_next_siblings","text":"<pre><code>ast_next_siblings(node: AST) -&gt; Iterator[AST]\n</code></pre> <p>Return the next siblings of this node, starting from the closest.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST</code>)         \u2013          <p>The AST node.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>AST</code>         \u2013          <p>The next siblings.</p> </li> </ul> Source code in <code>src/griffe/agents/nodes/_ast.py</code> <pre><code>def ast_next_siblings(node: AST) -&gt; Iterator[AST]:\n\"\"\"Return the next siblings of this node, starting from the closest.\n\n    Parameters:\n        node: The AST node.\n\n    Yields:\n        The next siblings.\n    \"\"\"\n    siblings = ast_children(node.parent)  # type: ignore[attr-defined]\n    for sibling in siblings:\n        if sibling is node:\n            break\n    yield from siblings\n</code></pre>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ast_previous","title":"ast_previous","text":"<pre><code>ast_previous(node: AST) -&gt; AST\n</code></pre> <p>Return the previous sibling of this node.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST</code>)         \u2013          <p>The AST node.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>LastNodeError</code>           \u2013          <p>When the node does not have previous siblings.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AST</code>         \u2013          <p>The sibling.</p> </li> </ul> Source code in <code>src/griffe/agents/nodes/_ast.py</code> <pre><code>def ast_previous(node: AST) -&gt; AST:\n\"\"\"Return the previous sibling of this node.\n\n    Parameters:\n        node: The AST node.\n\n    Raises:\n        LastNodeError: When the node does not have previous siblings.\n\n    Returns:\n        The sibling.\n    \"\"\"\n    try:\n        *_, last = ast_previous_siblings(node)\n    except ValueError:\n        raise LastNodeError(\"there is no previous node\") from None\n    return last\n</code></pre>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ast_previous_siblings","title":"ast_previous_siblings","text":"<pre><code>ast_previous_siblings(node: AST) -&gt; Iterator[AST]\n</code></pre> <p>Return the previous siblings of this node, starting from the closest.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST</code>)         \u2013          <p>The AST node.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>AST</code>         \u2013          <p>The previous siblings.</p> </li> </ul> Source code in <code>src/griffe/agents/nodes/_ast.py</code> <pre><code>def ast_previous_siblings(node: AST) -&gt; Iterator[AST]:\n\"\"\"Return the previous siblings of this node, starting from the closest.\n\n    Parameters:\n        node: The AST node.\n\n    Yields:\n        The previous siblings.\n    \"\"\"\n    for sibling in ast_children(node.parent):  # type: ignore[attr-defined]\n        if sibling is not node:\n            yield sibling\n        else:\n            return\n</code></pre>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ast_siblings","title":"ast_siblings","text":"<pre><code>ast_siblings(node: AST) -&gt; Iterator[AST]\n</code></pre> <p>Return the siblings of this node.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST</code>)         \u2013          <p>The AST node.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>AST</code>         \u2013          <p>The siblings.</p> </li> </ul> Source code in <code>src/griffe/agents/nodes/_ast.py</code> <pre><code>def ast_siblings(node: AST) -&gt; Iterator[AST]:\n\"\"\"Return the siblings of this node.\n\n    Parameters:\n        node: The AST node.\n\n    Yields:\n        The siblings.\n    \"\"\"\n    siblings = ast_children(node.parent)  # type: ignore[attr-defined]\n    for sibling in siblings:\n        if sibling is not node:\n            yield sibling\n        else:\n            break\n    yield from siblings\n</code></pre>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get__all__","title":"get__all__","text":"<pre><code>get__all__(\n    node: Assign | AugAssign, parent: Module\n) -&gt; list[str | ExprName]\n</code></pre> <p>Get the values declared in <code>__all__</code>.</p> <p>Parameters:</p> <ul> <li> node             (<code>Assign | AugAssign</code>)         \u2013          <p>The assignment node.</p> </li> <li> parent             (<code>Module</code>)         \u2013          <p>The parent module.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str | ExprName]</code>         \u2013          <p>A set of names.</p> </li> </ul> Source code in <code>src/griffe/agents/nodes/_all.py</code> <pre><code>def get__all__(node: ast.Assign | ast.AugAssign, parent: Module) -&gt; list[str | ExprName]:\n\"\"\"Get the values declared in `__all__`.\n\n    Parameters:\n        node: The assignment node.\n        parent: The parent module.\n\n    Returns:\n        A set of names.\n    \"\"\"\n    if node.value is None:\n        return []\n    return _extract(node.value, parent)\n</code></pre>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_call_keyword_arguments","title":"get_call_keyword_arguments","text":"<pre><code>get_call_keyword_arguments(\n    node: Call, parent: Module | Class\n) -&gt; dict[str, Any]\n</code></pre> <p>Get the list of keyword argument names and values from a Call node.</p> <p>Parameters:</p> <ul> <li> node             (<code>Call</code>)         \u2013          <p>The node to extract the keyword arguments from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>The keyword argument names and values.</p> </li> </ul> Source code in <code>src/griffe/agents/nodes/_parameters.py</code> <pre><code>def get_call_keyword_arguments(node: ast.Call, parent: Module | Class) -&gt; dict[str, Any]:\n\"\"\"Get the list of keyword argument names and values from a Call node.\n\n    Parameters:\n        node: The node to extract the keyword arguments from.\n\n    Returns:\n        The keyword argument names and values.\n    \"\"\"\n    return {kw.arg: safe_get_expression(kw.value, parent) for kw in node.keywords if kw.arg}\n</code></pre>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_docstring","title":"get_docstring","text":"<pre><code>get_docstring(\n    node: AST, *, strict: bool = False\n) -&gt; tuple[str | None, int | None, int | None]\n</code></pre> <p>Extract a docstring.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST</code>)         \u2013          <p>The node to extract the docstring from.</p> </li> <li> strict             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to skip searching the body (functions).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[str | None, int | None, int | None]</code>         \u2013          <p>A tuple with the value and line numbers of the docstring.</p> </li> </ul> Source code in <code>src/griffe/agents/nodes/_docstrings.py</code> <pre><code>def get_docstring(\n    node: ast.AST,\n    *,\n    strict: bool = False,\n) -&gt; tuple[str | None, int | None, int | None]:\n\"\"\"Extract a docstring.\n\n    Parameters:\n        node: The node to extract the docstring from.\n        strict: Whether to skip searching the body (functions).\n\n    Returns:\n        A tuple with the value and line numbers of the docstring.\n    \"\"\"\n    # TODO: possible optimization using a type map\n    if isinstance(node, ast.Expr):\n        doc = node.value\n    elif node.body and isinstance(node.body[0], ast.Expr) and not strict:  # type: ignore[attr-defined]\n        doc = node.body[0].value  # type: ignore[attr-defined]\n    else:\n        return None, None, None\n    if isinstance(doc, ast.Constant) and isinstance(doc.value, str):\n        return doc.value, doc.lineno, doc.end_lineno\n    return None, None, None\n</code></pre>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_expression","title":"get_expression","text":"<pre><code>get_expression(\n    node: AST | None,\n    parent: Module | Class,\n    *,\n    parse_strings: bool | None = None\n) -&gt; Expr | None\n</code></pre> <p>Build an expression from an AST.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | None</code>)         \u2013          <p>The annotation node.</p> </li> <li> parent             (<code>Module | Class</code>)         \u2013          <p>The parent used to resolve the name.</p> </li> <li> parse_strings             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether to try and parse strings as type annotations.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Expr | None</code>         \u2013          <p>A string or resovable name or expression.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def get_expression(\n    node: ast.AST | None,\n    parent: Module | Class,\n    *,\n    parse_strings: bool | None = None,\n) -&gt; Expr | None:\n\"\"\"Build an expression from an AST.\n\n    Parameters:\n        node: The annotation node.\n        parent: The parent used to resolve the name.\n        parse_strings: Whether to try and parse strings as type annotations.\n\n    Returns:\n        A string or resovable name or expression.\n    \"\"\"\n    if node is None:\n        return None\n    if parse_strings is None:\n        try:\n            module = parent.module\n        except ValueError:\n            parse_strings = False\n        else:\n            parse_strings = not module.imports_future_annotations\n    return _build(node, parent, parse_strings=parse_strings)\n</code></pre>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_instance_names","title":"get_instance_names","text":"<pre><code>get_instance_names(node: AST) -&gt; list[str]\n</code></pre> <p>Extract names from an assignment node, only for instance attributes.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST</code>)         \u2013          <p>The node to extract names from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>         \u2013          <p>A list of names.</p> </li> </ul> Source code in <code>src/griffe/agents/nodes/_names.py</code> <pre><code>def get_instance_names(node: ast.AST) -&gt; list[str]:\n\"\"\"Extract names from an assignment node, only for instance attributes.\n\n    Parameters:\n        node: The node to extract names from.\n\n    Returns:\n        A list of names.\n    \"\"\"\n    return [name.split(\".\", 1)[1] for name in get_names(node) if name.startswith(\"self.\")]\n</code></pre>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_name","title":"get_name","text":"<pre><code>get_name(node: AST) -&gt; str\n</code></pre> <p>Extract name from an assignment node.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST</code>)         \u2013          <p>The node to extract names from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>A list of names.</p> </li> </ul> Source code in <code>src/griffe/agents/nodes/_names.py</code> <pre><code>def get_name(node: ast.AST) -&gt; str:\n\"\"\"Extract name from an assignment node.\n\n    Parameters:\n        node: The node to extract names from.\n\n    Returns:\n        A list of names.\n    \"\"\"\n    return _node_name_map[type(node)](node)\n</code></pre>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_names","title":"get_names","text":"<pre><code>get_names(node: AST) -&gt; list[str]\n</code></pre> <p>Extract names from an assignment node.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST</code>)         \u2013          <p>The node to extract names from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>         \u2013          <p>A list of names.</p> </li> </ul> Source code in <code>src/griffe/agents/nodes/_names.py</code> <pre><code>def get_names(node: ast.AST) -&gt; list[str]:\n\"\"\"Extract names from an assignment node.\n\n    Parameters:\n        node: The node to extract names from.\n\n    Returns:\n        A list of names.\n    \"\"\"\n    return _node_names_map[type(node)](node)\n</code></pre>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_value","title":"get_value","text":"<pre><code>get_value(node: AST | None) -&gt; str | None\n</code></pre> <p>Get the string representation of a node.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | None</code>)         \u2013          <p>The node to represent.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str | None</code>         \u2013          <p>The representing code for the node.</p> </li> </ul> Source code in <code>src/griffe/agents/nodes/_values.py</code> <pre><code>def get_value(node: ast.AST | None) -&gt; str | None:\n\"\"\"Get the string representation of a node.\n\n    Parameters:\n        node: The node to represent.\n\n    Returns:\n        The representing code for the node.\n    \"\"\"\n    if node is None:\n        return None\n    return _extract(node)\n</code></pre>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.relative_to_absolute","title":"relative_to_absolute","text":"<pre><code>relative_to_absolute(\n    node: ImportFrom, name: alias, current_module: Module\n) -&gt; str\n</code></pre> <p>Convert a relative import path to an absolute one.</p> <p>Parameters:</p> <ul> <li> node             (<code>ImportFrom</code>)         \u2013          <p>The \"from ... import ...\" AST node.</p> </li> <li> name             (<code>alias</code>)         \u2013          <p>The imported name.</p> </li> <li> current_module             (<code>Module</code>)         \u2013          <p>The module in which the import happens.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The absolute import path.</p> </li> </ul> Source code in <code>src/griffe/agents/nodes/_imports.py</code> <pre><code>def relative_to_absolute(node: ast.ImportFrom, name: ast.alias, current_module: Module) -&gt; str:\n\"\"\"Convert a relative import path to an absolute one.\n\n    Parameters:\n        node: The \"from ... import ...\" AST node.\n        name: The imported name.\n        current_module: The module in which the import happens.\n\n    Returns:\n        The absolute import path.\n    \"\"\"\n    level = node.level\n    if level &gt; 0 and current_module.is_package or current_module.is_subpackage:\n        level -= 1\n    while level &gt; 0 and current_module.parent is not None:\n        current_module = current_module.parent  # type: ignore[assignment]\n        level -= 1\n    base = current_module.path + \".\" if node.level &gt; 0 else \"\"\n    node_module = node.module + \".\" if node.module else \"\"\n    return base + node_module + name.name\n</code></pre>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.safe_get__all__","title":"safe_get__all__","text":"<pre><code>safe_get__all__(\n    node: Assign | AugAssign,\n    parent: Module,\n    log_level: LogLevel = LogLevel.debug,\n) -&gt; list[str | ExprName]\n</code></pre> <p>Safely (no exception) extract values in <code>__all__</code>.</p> <p>Parameters:</p> <ul> <li> node             (<code>Assign | AugAssign</code>)         \u2013          <p>The <code>__all__</code> assignment node.</p> </li> <li> parent             (<code>Module</code>)         \u2013          <p>The parent used to resolve the names.</p> </li> <li> log_level             (<code>LogLevel</code>, default:                 <code>debug</code> )         \u2013          <p>Log level to use to log a message.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str | ExprName]</code>         \u2013          <p>A list of strings or resovable names.</p> </li> </ul> Source code in <code>src/griffe/agents/nodes/_all.py</code> <pre><code>def safe_get__all__(\n    node: ast.Assign | ast.AugAssign,\n    parent: Module,\n    log_level: LogLevel = LogLevel.debug,  # TODO: set to error when we handle more things\n) -&gt; list[str | ExprName]:\n\"\"\"Safely (no exception) extract values in `__all__`.\n\n    Parameters:\n        node: The `__all__` assignment node.\n        parent: The parent used to resolve the names.\n        log_level: Log level to use to log a message.\n\n    Returns:\n        A list of strings or resovable names.\n    \"\"\"\n    try:\n        return get__all__(node, parent)\n    except Exception as error:  # noqa: BLE001\n        message = f\"Failed to extract `__all__` value: {get_value(node.value)}\"\n        with suppress(Exception):\n            message += f\" at {parent.relative_filepath}:{node.lineno}\"\n        if isinstance(error, KeyError):\n            message += f\": unsupported node {error}\"\n        else:\n            message += f\": {error}\"\n        getattr(logger, log_level.value)(message)\n        return []\n</code></pre>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.safe_get_expression","title":"safe_get_expression","text":"<pre><code>safe_get_expression(\n    node: AST | None,\n    parent: Module | Class,\n    *,\n    parse_strings: bool | None = None,\n    log_level: LogLevel | None = LogLevel.error,\n    msg_format: str = \"{path}:{lineno}: Failed to get expression from {node_class}: {error}\"\n) -&gt; Expr | None\n</code></pre> <p>Safely (no exception) build a resolvable annotation.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | None</code>)         \u2013          <p>The annotation node.</p> </li> <li> parent             (<code>Module | Class</code>)         \u2013          <p>The parent used to resolve the name.</p> </li> <li> parse_strings             (<code>bool | None</code>, default:                 <code>None</code> )         \u2013          <p>Whether to try and parse strings as type annotations.</p> </li> <li> log_level             (<code>LogLevel | None</code>, default:                 <code>error</code> )         \u2013          <p>Log level to use to log a message. None to disable logging.</p> </li> <li> msg_format             (<code>str</code>, default:                 <code>'{path}:{lineno}: Failed to get expression from {node_class}: {error}'</code> )         \u2013          <p>A format string for the log message. Available placeholders: path, lineno, node, error.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Expr | None</code>         \u2013          <p>A string or resovable name or expression.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def safe_get_expression(\n    node: ast.AST | None,\n    parent: Module | Class,\n    *,\n    parse_strings: bool | None = None,\n    log_level: LogLevel | None = LogLevel.error,\n    msg_format: str = \"{path}:{lineno}: Failed to get expression from {node_class}: {error}\",\n) -&gt; Expr | None:\n\"\"\"Safely (no exception) build a resolvable annotation.\n\n    Parameters:\n        node: The annotation node.\n        parent: The parent used to resolve the name.\n        parse_strings: Whether to try and parse strings as type annotations.\n        log_level: Log level to use to log a message. None to disable logging.\n        msg_format: A format string for the log message. Available placeholders:\n            path, lineno, node, error.\n\n    Returns:\n        A string or resovable name or expression.\n    \"\"\"\n    try:\n        return get_expression(node, parent, parse_strings=parse_strings)\n    except Exception as error:  # noqa: BLE001\n        if log_level is None:\n            return None\n        node_class = node.__class__.__name__\n        try:\n            path: Path | str = parent.relative_filepath\n        except ValueError:\n            path = \"&lt;in-memory&gt;\"\n        lineno = node.lineno  # type: ignore[union-attr]\n        error_str = f\"{error.__class__.__name__}: {error}\"\n        message = msg_format.format(path=path, lineno=lineno, node_class=node_class, error=error_str)\n        getattr(logger, log_level.value)(message)\n    return None\n</code></pre>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.safe_get_value","title":"safe_get_value","text":"<pre><code>safe_get_value(\n    node: AST | None, filepath: str | Path | None = None\n) -&gt; str | None\n</code></pre> <p>Safely (no exception) get the string representation of a node.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | None</code>)         \u2013          <p>The node to represent.</p> </li> <li> filepath             (<code>str | Path | None</code>, default:                 <code>None</code> )         \u2013          <p>An optional filepath from where the node comes.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str | None</code>         \u2013          <p>The representing code for the node.</p> </li> </ul> Source code in <code>src/griffe/agents/nodes/_values.py</code> <pre><code>def safe_get_value(node: ast.AST | None, filepath: str | Path | None = None) -&gt; str | None:\n\"\"\"Safely (no exception) get the string representation of a node.\n\n    Parameters:\n        node: The node to represent.\n        filepath: An optional filepath from where the node comes.\n\n    Returns:\n        The representing code for the node.\n    \"\"\"\n    try:\n        return get_value(node)\n    except Exception as error:\n        message = f\"Failed to represent node {node}\"\n        if filepath:\n            message += f\" at {filepath}:{node.lineno}\"  # type: ignore[union-attr]\n        message += f\": {error}\"\n        logger.exception(message)\n        return None\n</code></pre>"},{"location":"reference/griffe/docstrings/","title":"Index","text":""},{"location":"reference/griffe/docstrings/#griffe.docstrings","title":"docstrings","text":"<p>This module exposes objects related to docstrings.</p> <p>Modules:</p> <ul> <li> dataclasses         \u2013          <p>This module contains the dataclasses related to docstrings.</p> </li> <li> google         \u2013          <p>This module defines functions to parse Google-style docstrings into structured data.</p> </li> <li> numpy         \u2013          <p>This module defines functions to parse Numpy-style docstrings into structured data.</p> </li> <li> parsers         \u2013          <p>This module imports all the defined parsers.</p> </li> <li> sphinx         \u2013          <p>This module defines functions to parse Sphinx docstrings into structured data.</p> </li> <li> utils         \u2013          <p>This module contains utilities for docstrings parsers.</p> </li> </ul> <p>Classes:</p> <ul> <li> Parser         \u2013          <p>Enumeration for the different docstring parsers.</p> </li> </ul> <p>Functions:</p> <ul> <li> parse           \u2013            <p>Parse the docstring.</p> </li> </ul>"},{"location":"reference/griffe/docstrings/#griffe.docstrings.Parser","title":"Parser","text":"<p>             Bases: <code>Enum</code></p> <p>Enumeration for the different docstring parsers.</p>"},{"location":"reference/griffe/docstrings/#griffe.docstrings.parse","title":"parse","text":"<pre><code>parse(\n    docstring: Docstring,\n    parser: Literal[\"google\", \"numpy\", \"sphinx\"]\n    | Parser\n    | None,\n    **options: Any\n) -&gt; list[DocstringSection]\n</code></pre> <p>Parse the docstring.</p> <p>Parameters:</p> <ul> <li> docstring             (<code>Docstring</code>)         \u2013          <p>The docstring to parse.</p> </li> <li> parser             (<code>Literal['google', 'numpy', 'sphinx'] | Parser | None</code>)         \u2013          <p>The docstring parser to use. If None, return a single text section.</p> </li> <li> **options             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>The options accepted by the parser.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[DocstringSection]</code>         \u2013          <p>A list of docstring sections.</p> </li> </ul> Source code in <code>src/griffe/docstrings/parsers.py</code> <pre><code>def parse(\n    docstring: Docstring,\n    parser: Literal[\"google\", \"numpy\", \"sphinx\"] | Parser | None,\n    **options: Any,\n) -&gt; list[DocstringSection]:\n\"\"\"Parse the docstring.\n\n    Parameters:\n        docstring: The docstring to parse.\n        parser: The docstring parser to use. If None, return a single text section.\n        **options: The options accepted by the parser.\n\n    Returns:\n        A list of docstring sections.\n    \"\"\"\n    if parser:\n        if isinstance(parser, str):\n            parser = Parser(parser)\n        return parsers[parser](docstring, **options)  # type: ignore[operator]\n    return [DocstringSectionText(docstring.value)]\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> dataclasses","text":""},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses","title":"dataclasses","text":"<p>This module contains the dataclasses related to docstrings.</p> <p>Classes:</p> <ul> <li> DocstringAdmonition         \u2013          <p>This class represents an admonition.</p> </li> <li> DocstringAttribute         \u2013          <p>This class represents a documented module/class attribute.</p> </li> <li> DocstringClass         \u2013          <p>This class represents a documented class.</p> </li> <li> DocstringDeprecated         \u2013          <p>This class represents a documented deprecated item.</p> </li> <li> DocstringElement         \u2013          <p>This base class represents annotated, nameless elements.</p> </li> <li> DocstringFunction         \u2013          <p>This class represents a documented function.</p> </li> <li> DocstringModule         \u2013          <p>This class represents a documented module.</p> </li> <li> DocstringNamedElement         \u2013          <p>This base class represents annotated, named elements.</p> </li> <li> DocstringParameter         \u2013          <p>This class represent a documented function parameter.</p> </li> <li> DocstringRaise         \u2013          <p>This class represents a documented raise value.</p> </li> <li> DocstringReceive         \u2013          <p>This class represents a documented receive value.</p> </li> <li> DocstringReturn         \u2013          <p>This class represents a documented return value.</p> </li> <li> DocstringSection         \u2013          <p>This class represents a docstring section.</p> </li> <li> DocstringSectionAdmonition         \u2013          <p>This class represents an admonition section.</p> </li> <li> DocstringSectionAttributes         \u2013          <p>This class represents an attributes section.</p> </li> <li> DocstringSectionClasses         \u2013          <p>This class represents a classes section.</p> </li> <li> DocstringSectionDeprecated         \u2013          <p>This class represents a deprecated section.</p> </li> <li> DocstringSectionExamples         \u2013          <p>This class represents an examples section.</p> </li> <li> DocstringSectionFunctions         \u2013          <p>This class represents a functions/methods section.</p> </li> <li> DocstringSectionKind         \u2013          <p>The possible section kinds.</p> </li> <li> DocstringSectionModules         \u2013          <p>This class represents a modules section.</p> </li> <li> DocstringSectionOtherParameters         \u2013          <p>This class represents an other parameters section.</p> </li> <li> DocstringSectionParameters         \u2013          <p>This class represents a parameters section.</p> </li> <li> DocstringSectionRaises         \u2013          <p>This class represents a raises section.</p> </li> <li> DocstringSectionReceives         \u2013          <p>This class represents a receives section.</p> </li> <li> DocstringSectionReturns         \u2013          <p>This class represents a returns section.</p> </li> <li> DocstringSectionText         \u2013          <p>This class represents a text section.</p> </li> <li> DocstringSectionWarns         \u2013          <p>This class represents a warns section.</p> </li> <li> DocstringSectionYields         \u2013          <p>This class represents a yields section.</p> </li> <li> DocstringWarn         \u2013          <p>This class represents a documented warn value.</p> </li> <li> DocstringYield         \u2013          <p>This class represents a documented yield value.</p> </li> </ul>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringAdmonition","title":"DocstringAdmonition","text":"<p>             Bases: <code>DocstringElement</code></p> <p>This class represents an admonition.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this element's data as a dictionary.</p> </li> </ul> <p>Attributes:</p> <ul> <li> contents             (<code>str</code>)         \u2013          <p>Return the contents of this admonition.</p> </li> <li> kind             (<code>str | Expr | None</code>)         \u2013          <p>Return the kind of this admonition.</p> </li> </ul>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringAdmonition.contents","title":"contents  <code>property</code> <code>writable</code>","text":"<pre><code>contents: str\n</code></pre> <p>Return the contents of this admonition.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The admonition's contents.</p> </li> </ul>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringAdmonition.kind","title":"kind  <code>property</code> <code>writable</code>","text":"<pre><code>kind: str | Expr | None\n</code></pre> <p>Return the kind of this admonition.</p> <p>Returns:</p> <ul> <li> <code>str | Expr | None</code>         \u2013          <p>The admonition's kind.</p> </li> </ul>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringAdmonition.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return this element's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:  # noqa: ARG002\n\"\"\"Return this element's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return {\n        \"annotation\": self.annotation,\n        \"description\": self.description,\n    }\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringAttribute","title":"DocstringAttribute","text":"<p>             Bases: <code>DocstringNamedElement</code></p> <p>This class represents a documented module/class attribute.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this element's data as a dictionary.</p> </li> </ul>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringClass","title":"DocstringClass","text":"<p>             Bases: <code>DocstringNamedElement</code></p> <p>This class represents a documented class.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this element's data as a dictionary.</p> </li> </ul>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringClass.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return this element's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return this element's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    base = {\"name\": self.name, **super().as_dict(**kwargs)}\n    if self.value is not None:\n        base[\"value\"] = self.value\n    return base\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringDeprecated","title":"DocstringDeprecated","text":"<p>             Bases: <code>DocstringElement</code></p> <p>This class represents a documented deprecated item.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this element's data as a dictionary.</p> </li> </ul> <p>Attributes:</p> <ul> <li> version             (<code>str</code>)         \u2013          <p>Return the version of this deprecation.</p> </li> </ul>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringDeprecated.version","title":"version  <code>property</code> <code>writable</code>","text":"<pre><code>version: str\n</code></pre> <p>Return the version of this deprecation.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013          <p>The deprecation version.</p> </li> </ul>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringDeprecated.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return this element's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:  # noqa: ARG002\n\"\"\"Return this element's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return {\n        \"annotation\": self.annotation,\n        \"description\": self.description,\n    }\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringElement","title":"DocstringElement","text":"<pre><code>DocstringElement(\n    *,\n    description: str,\n    annotation: str | Expr | None = None\n)\n</code></pre> <p>This base class represents annotated, nameless elements.</p> <p>Attributes:</p> <ul> <li> annotation             (<code>str | Expr | None</code>)         \u2013          <p>The element annotation, if any.</p> </li> <li> description             (<code>str</code>)         \u2013          <p>The element description.</p> </li> </ul> <p>Parameters:</p> <ul> <li> annotation             (<code>str | Expr | None</code>, default:                 <code>None</code> )         \u2013          <p>The element annotation, if any.</p> </li> <li> description             (<code>str</code>)         \u2013          <p>The element description.</p> </li> </ul> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this element's data as a dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def __init__(self, *, description: str, annotation: str | Expr | None = None) -&gt; None:\n\"\"\"Initialize the element.\n\n    Parameters:\n        annotation: The element annotation, if any.\n        description: The element description.\n    \"\"\"\n    self.description: str = description\n    self.annotation: str | Expr | None = annotation\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringElement.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return this element's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:  # noqa: ARG002\n\"\"\"Return this element's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return {\n        \"annotation\": self.annotation,\n        \"description\": self.description,\n    }\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringFunction","title":"DocstringFunction","text":"<p>             Bases: <code>DocstringNamedElement</code></p> <p>This class represents a documented function.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this element's data as a dictionary.</p> </li> </ul>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringFunction.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return this element's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return this element's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    base = {\"name\": self.name, **super().as_dict(**kwargs)}\n    if self.value is not None:\n        base[\"value\"] = self.value\n    return base\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringModule","title":"DocstringModule","text":"<p>             Bases: <code>DocstringNamedElement</code></p> <p>This class represents a documented module.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this element's data as a dictionary.</p> </li> </ul>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringNamedElement","title":"DocstringNamedElement","text":"<pre><code>DocstringNamedElement(\n    name: str,\n    *,\n    description: str,\n    annotation: str | Expr | None = None,\n    value: str | None = None\n)\n</code></pre> <p>             Bases: <code>DocstringElement</code></p> <p>This base class represents annotated, named elements.</p> <p>Attributes:</p> <ul> <li> name             (<code>str</code>)         \u2013          <p>The element name.</p> </li> <li> value             (<code>str | None</code>)         \u2013          <p>The element value, as a string, if any.</p> </li> </ul> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013          <p>The element name.</p> </li> <li> description             (<code>str</code>)         \u2013          <p>The element description.</p> </li> <li> annotation             (<code>str | Expr | None</code>, default:                 <code>None</code> )         \u2013          <p>The element annotation, if any.</p> </li> <li> value             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>The element value, as a string.</p> </li> </ul> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this element's data as a dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    *,\n    description: str,\n    annotation: str | Expr | None = None,\n    value: str | None = None,\n) -&gt; None:\n\"\"\"Initialize the element.\n\n    Parameters:\n        name: The element name.\n        description: The element description.\n        annotation: The element annotation, if any.\n        value: The element value, as a string.\n    \"\"\"\n    super().__init__(description=description, annotation=annotation)\n    self.name: str = name\n    self.value: str | None = value\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringNamedElement.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return this element's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return this element's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    base = {\"name\": self.name, **super().as_dict(**kwargs)}\n    if self.value is not None:\n        base[\"value\"] = self.value\n    return base\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringParameter","title":"DocstringParameter","text":"<p>             Bases: <code>DocstringNamedElement</code></p> <p>This class represent a documented function parameter.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this element's data as a dictionary.</p> </li> </ul> <p>Attributes:</p> <ul> <li> default             (<code>str | None</code>)         \u2013          <p>Return the default value of this parameter.</p> </li> </ul>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringParameter.default","title":"default  <code>property</code> <code>writable</code>","text":"<pre><code>default: str | None\n</code></pre> <p>Return the default value of this parameter.</p> <p>Returns:</p> <ul> <li> <code>str | None</code>         \u2013          <p>The parameter's default.</p> </li> </ul>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringParameter.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return this element's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return this element's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    base = {\"name\": self.name, **super().as_dict(**kwargs)}\n    if self.value is not None:\n        base[\"value\"] = self.value\n    return base\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringRaise","title":"DocstringRaise","text":"<p>             Bases: <code>DocstringElement</code></p> <p>This class represents a documented raise value.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this element's data as a dictionary.</p> </li> </ul>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringReceive","title":"DocstringReceive","text":"<p>             Bases: <code>DocstringNamedElement</code></p> <p>This class represents a documented receive value.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this element's data as a dictionary.</p> </li> </ul>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringReturn","title":"DocstringReturn","text":"<p>             Bases: <code>DocstringNamedElement</code></p> <p>This class represents a documented return value.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this element's data as a dictionary.</p> </li> </ul>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSection","title":"DocstringSection","text":"<pre><code>DocstringSection(title: str | None = None)\n</code></pre> <p>This class represents a docstring section.</p> <p>Parameters:</p> <ul> <li> title             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>An optional title.</p> </li> </ul> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this section's data as a dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def __init__(self, title: str | None = None) -&gt; None:\n\"\"\"Initialize the section.\n\n    Parameters:\n        title: An optional title.\n    \"\"\"\n    self.title: str | None = title\n    self.value: Any = None\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSection.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return this section's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return this section's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    if hasattr(self.value, \"as_dict\"):  # noqa: SIM108\n        serialized_value = self.value.as_dict(**kwargs)\n    else:\n        serialized_value = self.value\n    base = {\"kind\": self.kind.value, \"value\": serialized_value}\n    if self.title:\n        base[\"title\"] = self.title\n    return base\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionAdmonition","title":"DocstringSectionAdmonition","text":"<pre><code>DocstringSectionAdmonition(\n    kind: str, text: str, title: str | None = None\n)\n</code></pre> <p>             Bases: <code>DocstringSection</code></p> <p>This class represents an admonition section.</p> <p>Parameters:</p> <ul> <li> kind             (<code>str</code>)         \u2013          <p>The admonition kind.</p> </li> <li> text             (<code>str</code>)         \u2013          <p>The admonition text.</p> </li> <li> title             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>An optional title.</p> </li> </ul> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this section's data as a dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def __init__(self, kind: str, text: str, title: str | None = None) -&gt; None:\n\"\"\"Initialize the section.\n\n    Parameters:\n        kind: The admonition kind.\n        text: The admonition text.\n        title: An optional title.\n    \"\"\"\n    super().__init__(title)\n    self.value: DocstringAdmonition = DocstringAdmonition(annotation=kind, description=text)\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionAdmonition.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return this section's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return this section's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    if hasattr(self.value, \"as_dict\"):  # noqa: SIM108\n        serialized_value = self.value.as_dict(**kwargs)\n    else:\n        serialized_value = self.value\n    base = {\"kind\": self.kind.value, \"value\": serialized_value}\n    if self.title:\n        base[\"title\"] = self.title\n    return base\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionAttributes","title":"DocstringSectionAttributes","text":"<pre><code>DocstringSectionAttributes(\n    value: list[DocstringAttribute],\n    title: str | None = None,\n)\n</code></pre> <p>             Bases: <code>DocstringSection</code></p> <p>This class represents an attributes section.</p> <p>Parameters:</p> <ul> <li> value             (<code>list[DocstringAttribute]</code>)         \u2013          <p>The section attributes.</p> </li> <li> title             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>An optional title.</p> </li> </ul> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this section's data as a dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def __init__(self, value: list[DocstringAttribute], title: str | None = None) -&gt; None:\n\"\"\"Initialize the section.\n\n    Parameters:\n        value: The section attributes.\n        title: An optional title.\n    \"\"\"\n    super().__init__(title)\n    self.value: list[DocstringAttribute] = value\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionAttributes.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return this section's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return this section's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    if hasattr(self.value, \"as_dict\"):  # noqa: SIM108\n        serialized_value = self.value.as_dict(**kwargs)\n    else:\n        serialized_value = self.value\n    base = {\"kind\": self.kind.value, \"value\": serialized_value}\n    if self.title:\n        base[\"title\"] = self.title\n    return base\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionClasses","title":"DocstringSectionClasses","text":"<pre><code>DocstringSectionClasses(\n    value: list[DocstringClass], title: str | None = None\n)\n</code></pre> <p>             Bases: <code>DocstringSection</code></p> <p>This class represents a classes section.</p> <p>Parameters:</p> <ul> <li> value             (<code>list[DocstringClass]</code>)         \u2013          <p>The section classes.</p> </li> <li> title             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>An optional title.</p> </li> </ul> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this section's data as a dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def __init__(self, value: list[DocstringClass], title: str | None = None) -&gt; None:\n\"\"\"Initialize the section.\n\n    Parameters:\n        value: The section classes.\n        title: An optional title.\n    \"\"\"\n    super().__init__(title)\n    self.value: list[DocstringClass] = value\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionClasses.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return this section's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return this section's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    if hasattr(self.value, \"as_dict\"):  # noqa: SIM108\n        serialized_value = self.value.as_dict(**kwargs)\n    else:\n        serialized_value = self.value\n    base = {\"kind\": self.kind.value, \"value\": serialized_value}\n    if self.title:\n        base[\"title\"] = self.title\n    return base\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionDeprecated","title":"DocstringSectionDeprecated","text":"<pre><code>DocstringSectionDeprecated(\n    version: str, text: str, title: str | None = None\n)\n</code></pre> <p>             Bases: <code>DocstringSection</code></p> <p>This class represents a deprecated section.</p> <p>Parameters:</p> <ul> <li> version             (<code>str</code>)         \u2013          <p>The deprecation version.</p> </li> <li> text             (<code>str</code>)         \u2013          <p>The deprecation text.</p> </li> <li> title             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>An optional title.</p> </li> </ul> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this section's data as a dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def __init__(self, version: str, text: str, title: str | None = None) -&gt; None:\n\"\"\"Initialize the section.\n\n    Parameters:\n        version: The deprecation version.\n        text: The deprecation text.\n        title: An optional title.\n    \"\"\"\n    super().__init__(title)\n    self.value: DocstringDeprecated = DocstringDeprecated(annotation=version, description=text)\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionDeprecated.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return this section's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return this section's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    if hasattr(self.value, \"as_dict\"):  # noqa: SIM108\n        serialized_value = self.value.as_dict(**kwargs)\n    else:\n        serialized_value = self.value\n    base = {\"kind\": self.kind.value, \"value\": serialized_value}\n    if self.title:\n        base[\"title\"] = self.title\n    return base\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionExamples","title":"DocstringSectionExamples","text":"<pre><code>DocstringSectionExamples(\n    value: list[tuple[Literal[text, examples], str]],\n    title: str | None = None,\n)\n</code></pre> <p>             Bases: <code>DocstringSection</code></p> <p>This class represents an examples section.</p> <p>Parameters:</p> <ul> <li> value             (<code>list[tuple[Literal[text, examples], str]]</code>)         \u2013          <p>The section examples.</p> </li> <li> title             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>An optional title.</p> </li> </ul> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this section's data as a dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def __init__(\n    self,\n    value: list[tuple[Literal[DocstringSectionKind.text, DocstringSectionKind.examples], str]],\n    title: str | None = None,\n) -&gt; None:\n\"\"\"Initialize the section.\n\n    Parameters:\n        value: The section examples.\n        title: An optional title.\n    \"\"\"\n    super().__init__(title)\n    self.value: list[tuple[Literal[DocstringSectionKind.text, DocstringSectionKind.examples], str]] = value\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionExamples.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return this section's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return this section's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    if hasattr(self.value, \"as_dict\"):  # noqa: SIM108\n        serialized_value = self.value.as_dict(**kwargs)\n    else:\n        serialized_value = self.value\n    base = {\"kind\": self.kind.value, \"value\": serialized_value}\n    if self.title:\n        base[\"title\"] = self.title\n    return base\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionFunctions","title":"DocstringSectionFunctions","text":"<pre><code>DocstringSectionFunctions(\n    value: list[DocstringFunction], title: str | None = None\n)\n</code></pre> <p>             Bases: <code>DocstringSection</code></p> <p>This class represents a functions/methods section.</p> <p>Parameters:</p> <ul> <li> value             (<code>list[DocstringFunction]</code>)         \u2013          <p>The section functions.</p> </li> <li> title             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>An optional title.</p> </li> </ul> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this section's data as a dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def __init__(self, value: list[DocstringFunction], title: str | None = None) -&gt; None:\n\"\"\"Initialize the section.\n\n    Parameters:\n        value: The section functions.\n        title: An optional title.\n    \"\"\"\n    super().__init__(title)\n    self.value: list[DocstringFunction] = value\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionFunctions.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return this section's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return this section's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    if hasattr(self.value, \"as_dict\"):  # noqa: SIM108\n        serialized_value = self.value.as_dict(**kwargs)\n    else:\n        serialized_value = self.value\n    base = {\"kind\": self.kind.value, \"value\": serialized_value}\n    if self.title:\n        base[\"title\"] = self.title\n    return base\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionKind","title":"DocstringSectionKind","text":"<p>             Bases: <code>Enum</code></p> <p>The possible section kinds.</p>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionModules","title":"DocstringSectionModules","text":"<pre><code>DocstringSectionModules(\n    value: list[DocstringModule], title: str | None = None\n)\n</code></pre> <p>             Bases: <code>DocstringSection</code></p> <p>This class represents a modules section.</p> <p>Parameters:</p> <ul> <li> value             (<code>list[DocstringModule]</code>)         \u2013          <p>The section modules.</p> </li> <li> title             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>An optional title.</p> </li> </ul> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this section's data as a dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def __init__(self, value: list[DocstringModule], title: str | None = None) -&gt; None:\n\"\"\"Initialize the section.\n\n    Parameters:\n        value: The section modules.\n        title: An optional title.\n    \"\"\"\n    super().__init__(title)\n    self.value: list[DocstringModule] = value\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionModules.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return this section's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return this section's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    if hasattr(self.value, \"as_dict\"):  # noqa: SIM108\n        serialized_value = self.value.as_dict(**kwargs)\n    else:\n        serialized_value = self.value\n    base = {\"kind\": self.kind.value, \"value\": serialized_value}\n    if self.title:\n        base[\"title\"] = self.title\n    return base\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionOtherParameters","title":"DocstringSectionOtherParameters","text":"<p>             Bases: <code>DocstringSectionParameters</code></p> <p>This class represents an other parameters section.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this section's data as a dictionary.</p> </li> </ul>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionOtherParameters.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return this section's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return this section's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    if hasattr(self.value, \"as_dict\"):  # noqa: SIM108\n        serialized_value = self.value.as_dict(**kwargs)\n    else:\n        serialized_value = self.value\n    base = {\"kind\": self.kind.value, \"value\": serialized_value}\n    if self.title:\n        base[\"title\"] = self.title\n    return base\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionParameters","title":"DocstringSectionParameters","text":"<pre><code>DocstringSectionParameters(\n    value: list[DocstringParameter],\n    title: str | None = None,\n)\n</code></pre> <p>             Bases: <code>DocstringSection</code></p> <p>This class represents a parameters section.</p> <p>Parameters:</p> <ul> <li> value             (<code>list[DocstringParameter]</code>)         \u2013          <p>The section parameters.</p> </li> <li> title             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>An optional title.</p> </li> </ul> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this section's data as a dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def __init__(self, value: list[DocstringParameter], title: str | None = None) -&gt; None:\n\"\"\"Initialize the section.\n\n    Parameters:\n        value: The section parameters.\n        title: An optional title.\n    \"\"\"\n    super().__init__(title)\n    self.value: list[DocstringParameter] = value\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionParameters.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return this section's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return this section's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    if hasattr(self.value, \"as_dict\"):  # noqa: SIM108\n        serialized_value = self.value.as_dict(**kwargs)\n    else:\n        serialized_value = self.value\n    base = {\"kind\": self.kind.value, \"value\": serialized_value}\n    if self.title:\n        base[\"title\"] = self.title\n    return base\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionRaises","title":"DocstringSectionRaises","text":"<pre><code>DocstringSectionRaises(\n    value: list[DocstringRaise], title: str | None = None\n)\n</code></pre> <p>             Bases: <code>DocstringSection</code></p> <p>This class represents a raises section.</p> <p>Parameters:</p> <ul> <li> value             (<code>list[DocstringRaise]</code>)         \u2013          <p>The section exceptions.</p> </li> <li> title             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>An optional title.</p> </li> </ul> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this section's data as a dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def __init__(self, value: list[DocstringRaise], title: str | None = None) -&gt; None:\n\"\"\"Initialize the section.\n\n    Parameters:\n        value: The section exceptions.\n        title: An optional title.\n    \"\"\"\n    super().__init__(title)\n    self.value: list[DocstringRaise] = value\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionRaises.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return this section's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return this section's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    if hasattr(self.value, \"as_dict\"):  # noqa: SIM108\n        serialized_value = self.value.as_dict(**kwargs)\n    else:\n        serialized_value = self.value\n    base = {\"kind\": self.kind.value, \"value\": serialized_value}\n    if self.title:\n        base[\"title\"] = self.title\n    return base\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionReceives","title":"DocstringSectionReceives","text":"<pre><code>DocstringSectionReceives(\n    value: list[DocstringReceive], title: str | None = None\n)\n</code></pre> <p>             Bases: <code>DocstringSection</code></p> <p>This class represents a receives section.</p> <p>Parameters:</p> <ul> <li> value             (<code>list[DocstringReceive]</code>)         \u2013          <p>The section received items.</p> </li> <li> title             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>An optional title.</p> </li> </ul> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this section's data as a dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def __init__(self, value: list[DocstringReceive], title: str | None = None) -&gt; None:\n\"\"\"Initialize the section.\n\n    Parameters:\n        value: The section received items.\n        title: An optional title.\n    \"\"\"\n    super().__init__(title)\n    self.value: list[DocstringReceive] = value\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionReceives.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return this section's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return this section's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    if hasattr(self.value, \"as_dict\"):  # noqa: SIM108\n        serialized_value = self.value.as_dict(**kwargs)\n    else:\n        serialized_value = self.value\n    base = {\"kind\": self.kind.value, \"value\": serialized_value}\n    if self.title:\n        base[\"title\"] = self.title\n    return base\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionReturns","title":"DocstringSectionReturns","text":"<pre><code>DocstringSectionReturns(\n    value: list[DocstringReturn], title: str | None = None\n)\n</code></pre> <p>             Bases: <code>DocstringSection</code></p> <p>This class represents a returns section.</p> <p>Parameters:</p> <ul> <li> value             (<code>list[DocstringReturn]</code>)         \u2013          <p>The section returned items.</p> </li> <li> title             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>An optional title.</p> </li> </ul> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this section's data as a dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def __init__(self, value: list[DocstringReturn], title: str | None = None) -&gt; None:\n\"\"\"Initialize the section.\n\n    Parameters:\n        value: The section returned items.\n        title: An optional title.\n    \"\"\"\n    super().__init__(title)\n    self.value: list[DocstringReturn] = value\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionReturns.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return this section's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return this section's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    if hasattr(self.value, \"as_dict\"):  # noqa: SIM108\n        serialized_value = self.value.as_dict(**kwargs)\n    else:\n        serialized_value = self.value\n    base = {\"kind\": self.kind.value, \"value\": serialized_value}\n    if self.title:\n        base[\"title\"] = self.title\n    return base\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionText","title":"DocstringSectionText","text":"<pre><code>DocstringSectionText(value: str, title: str | None = None)\n</code></pre> <p>             Bases: <code>DocstringSection</code></p> <p>This class represents a text section.</p> <p>Parameters:</p> <ul> <li> value             (<code>str</code>)         \u2013          <p>The section text.</p> </li> <li> title             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>An optional title.</p> </li> </ul> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this section's data as a dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def __init__(self, value: str, title: str | None = None) -&gt; None:\n\"\"\"Initialize the section.\n\n    Parameters:\n        value: The section text.\n        title: An optional title.\n    \"\"\"\n    super().__init__(title)\n    self.value: str = value\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionText.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return this section's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return this section's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    if hasattr(self.value, \"as_dict\"):  # noqa: SIM108\n        serialized_value = self.value.as_dict(**kwargs)\n    else:\n        serialized_value = self.value\n    base = {\"kind\": self.kind.value, \"value\": serialized_value}\n    if self.title:\n        base[\"title\"] = self.title\n    return base\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionWarns","title":"DocstringSectionWarns","text":"<pre><code>DocstringSectionWarns(\n    value: list[DocstringWarn], title: str | None = None\n)\n</code></pre> <p>             Bases: <code>DocstringSection</code></p> <p>This class represents a warns section.</p> <p>Parameters:</p> <ul> <li> value             (<code>list[DocstringWarn]</code>)         \u2013          <p>The section warnings.</p> </li> <li> title             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>An optional title.</p> </li> </ul> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this section's data as a dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def __init__(self, value: list[DocstringWarn], title: str | None = None) -&gt; None:\n\"\"\"Initialize the section.\n\n    Parameters:\n        value: The section warnings.\n        title: An optional title.\n    \"\"\"\n    super().__init__(title)\n    self.value: list[DocstringWarn] = value\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionWarns.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return this section's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return this section's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    if hasattr(self.value, \"as_dict\"):  # noqa: SIM108\n        serialized_value = self.value.as_dict(**kwargs)\n    else:\n        serialized_value = self.value\n    base = {\"kind\": self.kind.value, \"value\": serialized_value}\n    if self.title:\n        base[\"title\"] = self.title\n    return base\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionYields","title":"DocstringSectionYields","text":"<pre><code>DocstringSectionYields(\n    value: list[DocstringYield], title: str | None = None\n)\n</code></pre> <p>             Bases: <code>DocstringSection</code></p> <p>This class represents a yields section.</p> <p>Parameters:</p> <ul> <li> value             (<code>list[DocstringYield]</code>)         \u2013          <p>The section yielded items.</p> </li> <li> title             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>An optional title.</p> </li> </ul> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this section's data as a dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def __init__(self, value: list[DocstringYield], title: str | None = None) -&gt; None:\n\"\"\"Initialize the section.\n\n    Parameters:\n        value: The section yielded items.\n        title: An optional title.\n    \"\"\"\n    super().__init__(title)\n    self.value: list[DocstringYield] = value\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionYields.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Return this section's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013          <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return this section's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    if hasattr(self.value, \"as_dict\"):  # noqa: SIM108\n        serialized_value = self.value.as_dict(**kwargs)\n    else:\n        serialized_value = self.value\n    base = {\"kind\": self.kind.value, \"value\": serialized_value}\n    if self.title:\n        base[\"title\"] = self.title\n    return base\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringWarn","title":"DocstringWarn","text":"<p>             Bases: <code>DocstringElement</code></p> <p>This class represents a documented warn value.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this element's data as a dictionary.</p> </li> </ul>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringYield","title":"DocstringYield","text":"<p>             Bases: <code>DocstringNamedElement</code></p> <p>This class represents a documented yield value.</p> <p>Methods:</p> <ul> <li> as_dict           \u2013            <p>Return this element's data as a dictionary.</p> </li> </ul>"},{"location":"reference/griffe/docstrings/google/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> google","text":""},{"location":"reference/griffe/docstrings/google/#griffe.docstrings.google","title":"google","text":"<p>This module defines functions to parse Google-style docstrings into structured data.</p> <p>Functions:</p> <ul> <li> parse           \u2013            <p>Parse a docstring.</p> </li> </ul>"},{"location":"reference/griffe/docstrings/google/#griffe.docstrings.google.parse","title":"parse","text":"<pre><code>parse(\n    docstring: Docstring,\n    *,\n    ignore_init_summary: bool = False,\n    trim_doctest_flags: bool = True,\n    returns_multiple_items: bool = True,\n    warn_unknown_params: bool = True,\n    returns_named_value: bool = True,\n    returns_type_in_property_summary: bool = False,\n    **options: Any\n) -&gt; list[DocstringSection]\n</code></pre> <p>Parse a docstring.</p> <p>This function iterates on lines of a docstring to build sections. It then returns this list of sections.</p> <p>Parameters:</p> <ul> <li> docstring             (<code>Docstring</code>)         \u2013          <p>The docstring to parse.</p> </li> <li> ignore_init_summary             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to ignore the summary in <code>__init__</code> methods' docstrings.</p> </li> <li> trim_doctest_flags             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to remove doctest flags from Python example blocks.</p> </li> <li> returns_multiple_items             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether the <code>Returns</code> section has multiple items.</p> </li> <li> warn_unknown_params             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Warn about documented parameters not appearing in the signature.</p> </li> <li> returns_named_value             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to parse <code>thing: Description</code> in returns sections as a name and description, rather than a type and description. When true, type must be wrapped in parentheses: <code>(int): Description.</code>. When false, parentheses are optional but the items cannot be named: <code>int: Description</code>.</p> </li> <li> returns_type_in_property_summary             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to parse the return type of properties at the beginning of their summary: <code>str: Summary of the property</code>.</p> </li> <li> **options             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional parsing options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[DocstringSection]</code>         \u2013          <p>A list of docstring sections.</p> </li> </ul> Source code in <code>src/griffe/docstrings/google.py</code> <pre><code>def parse(\n    docstring: Docstring,\n    *,\n    ignore_init_summary: bool = False,\n    trim_doctest_flags: bool = True,\n    returns_multiple_items: bool = True,\n    warn_unknown_params: bool = True,\n    returns_named_value: bool = True,\n    returns_type_in_property_summary: bool = False,\n    **options: Any,\n) -&gt; list[DocstringSection]:\n\"\"\"Parse a docstring.\n\n    This function iterates on lines of a docstring to build sections.\n    It then returns this list of sections.\n\n    Parameters:\n        docstring: The docstring to parse.\n        ignore_init_summary: Whether to ignore the summary in `__init__` methods' docstrings.\n        trim_doctest_flags: Whether to remove doctest flags from Python example blocks.\n        returns_multiple_items: Whether the `Returns` section has multiple items.\n        warn_unknown_params: Warn about documented parameters not appearing in the signature.\n        returns_named_value: Whether to parse `thing: Description` in returns sections as a name and description,\n            rather than a type and description. When true, type must be wrapped in parentheses: `(int): Description.`.\n            When false, parentheses are optional but the items cannot be named: `int: Description`.\n        returns_type_in_property_summary: Whether to parse the return type of properties\n            at the beginning of their summary: `str: Summary of the property`.\n        **options: Additional parsing options.\n\n    Returns:\n        A list of docstring sections.\n    \"\"\"\n    sections: list[DocstringSection] = []\n    current_section = []\n\n    in_code_block = False\n    lines = docstring.lines\n\n    options = {\n        \"ignore_init_summary\": ignore_init_summary,\n        \"trim_doctest_flags\": trim_doctest_flags,\n        \"returns_multiple_items\": returns_multiple_items,\n        \"warn_unknown_params\": warn_unknown_params,\n        \"returns_named_value\": returns_named_value,\n        \"returns_type_in_property_summary\": returns_type_in_property_summary,\n        **options,\n    }\n\n    ignore_summary = (\n        options[\"ignore_init_summary\"]\n        and docstring.parent is not None\n        and docstring.parent.name == \"__init__\"\n        and docstring.parent.is_function\n        and docstring.parent.parent is not None\n        and docstring.parent.parent.is_class\n    )\n\n    offset = 2 if ignore_summary else 0\n\n    while offset &lt; len(lines):\n        line_lower = lines[offset].lower()\n\n        if in_code_block:\n            if line_lower.lstrip(\" \").startswith(\"```\"):\n                in_code_block = False\n            current_section.append(lines[offset])\n\n        elif line_lower.lstrip(\" \").startswith(\"```\"):\n            in_code_block = True\n            current_section.append(lines[offset])\n\n        elif match := _RE_ADMONITION.match(lines[offset]):\n            groups = match.groupdict()\n            title = groups[\"title\"]\n            admonition_type = groups[\"type\"]\n            is_section = admonition_type.lower() in _section_kind\n\n            has_previous_line = offset &gt; 0\n            blank_line_above = not has_previous_line or _is_empty_line(lines[offset - 1])\n            has_next_line = offset &lt; len(lines) - 1\n            has_next_lines = offset &lt; len(lines) - 2\n            blank_line_below = has_next_line and _is_empty_line(lines[offset + 1])\n            blank_lines_below = has_next_lines and _is_empty_line(lines[offset + 2])\n            indented_line_below = has_next_line and not blank_line_below and lines[offset + 1].startswith(\" \")\n            indented_lines_below = has_next_lines and not blank_lines_below and lines[offset + 2].startswith(\" \")\n            if not (indented_line_below or indented_lines_below):\n                # Do not warn when there are no contents,\n                # this is most probably not a section or admonition.\n                current_section.append(lines[offset])\n                offset += 1\n                continue\n            reasons = []\n            kind = \"section\" if is_section else \"admonition\"\n            if (indented_line_below or indented_lines_below) and not blank_line_above:\n                reasons.append(f\"Missing blank line above {kind}\")\n            if indented_lines_below and blank_line_below:\n                reasons.append(f\"Extraneous blank line below {kind} title\")\n            if reasons:\n                reasons_string = \"; \".join(reasons)\n                _warn(\n                    docstring,\n                    offset,\n                    f\"Possible {kind} skipped, reasons: {reasons_string}\",\n                    LogLevel.debug,\n                )\n                current_section.append(lines[offset])\n                offset += 1\n                continue\n\n            if is_section:\n                if current_section:\n                    if any(current_section):\n                        sections.append(DocstringSectionText(\"\\n\".join(current_section).rstrip(\"\\n\")))\n                    current_section = []\n                reader = _section_reader[_section_kind[admonition_type.lower()]]\n                section, offset = reader(docstring, offset=offset + 1, **options)  # type: ignore[operator]\n                if section:\n                    section.title = title\n                    sections.append(section)\n\n            else:\n                contents, offset = _read_block(docstring, offset=offset + 1)\n                if contents:\n                    if current_section:\n                        if any(current_section):\n                            sections.append(DocstringSectionText(\"\\n\".join(current_section).rstrip(\"\\n\")))\n                        current_section = []\n                    if title is None:\n                        title = admonition_type\n                    admonition_type = admonition_type.lower().replace(\" \", \"-\")\n                    sections.append(DocstringSectionAdmonition(kind=admonition_type, text=contents, title=title))\n                else:\n                    with suppress(IndexError):\n                        current_section.append(lines[offset])\n        else:\n            current_section.append(lines[offset])\n\n        offset += 1\n\n    if current_section:\n        sections.append(DocstringSectionText(\"\\n\".join(current_section).rstrip(\"\\n\")))\n\n    if (\n        returns_type_in_property_summary\n        and sections\n        and docstring.parent\n        and docstring.parent.is_attribute\n        and \"property\" in docstring.parent.labels\n    ):\n        lines = sections[0].value.lstrip().split(\"\\n\")\n        if \":\" in lines[0]:\n            annotation, line = lines[0].split(\":\", 1)\n            lines = [line, *lines[1:]]\n            sections[0].value = \"\\n\".join(lines)\n            sections.append(\n                DocstringSectionReturns(\n                    [DocstringReturn(\"\", description=\"\", annotation=parse_annotation(annotation, docstring))],\n                ),\n            )\n\n    return sections\n</code></pre>"},{"location":"reference/griffe/docstrings/numpy/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> numpy","text":""},{"location":"reference/griffe/docstrings/numpy/#griffe.docstrings.numpy","title":"numpy","text":"<p>This module defines functions to parse Numpy-style docstrings into structured data.</p> <p>Based on https://numpydoc.readthedocs.io/en/latest/format.html, it seems Numpydoc is a superset of RST. Since fully parsing RST is a non-goal of this project, some things are stripped from the Numpydoc specification.</p> <p>Rejected as non particularly Pythonic or useful as sections:</p> <ul> <li>See also: this section feels too subjective (specially crafted as a standard for Numpy itself),     and there are may ways to reference related items in a docstring, depending on the chosen markup.</li> <li>Methods: with a good documentation renderer, methods are easily made accessible or hidden.     Griffe also has a goal of making the merging of inherited methods configurable (on/off).</li> </ul> <p>Rejected as naturally handled by the user-chosen markup:</p> <ul> <li>Warnings: this is just markup.</li> <li>Notes: again, just markup.</li> <li>References: again, just markup.</li> </ul> <p>The following sections are supported:</p> <ul> <li>Deprecated (revisited): we expect a title instead of an RST directive.     Python has support for deprecating things, so it feels natural     to structure deprecations.</li> <li>Parameters: obviously.</li> <li>Returns: obviously.</li> <li>Yields: obviously.</li> <li>Receives: less used than Yields, but very natural/Pythonic as well.</li> <li>Other parameters: used here as documentation for keyword parameters.</li> <li>Raises: obviously.</li> <li>Warns: less used than Raises, but very natural/Pythonic as well.</li> <li>Examples: obviously. Special handling for non-code-blocks <code>&gt;&gt;&gt;</code>.</li> <li>Attributes: obviously.</li> </ul> <p>Functions:</p> <ul> <li> parse           \u2013            <p>Parse a docstring.</p> </li> </ul>"},{"location":"reference/griffe/docstrings/numpy/#griffe.docstrings.numpy.parse","title":"parse","text":"<pre><code>parse(\n    docstring: Docstring,\n    *,\n    ignore_init_summary: bool = False,\n    trim_doctest_flags: bool = True,\n    allow_section_blank_line: bool = False,\n    warn_unknown_params: bool = True,\n    **options: Any\n) -&gt; list[DocstringSection]\n</code></pre> <p>Parse a docstring.</p> <p>This function iterates on lines of a docstring to build sections. It then returns this list of sections.</p> <p>Parameters:</p> <ul> <li> docstring             (<code>Docstring</code>)         \u2013          <p>The docstring to parse.</p> </li> <li> ignore_init_summary             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to ignore the summary in <code>__init__</code> methods' docstrings.</p> </li> <li> trim_doctest_flags             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to remove doctest flags from Python example blocks.</p> </li> <li> allow_section_blank_line             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to continue a section if there's an empty line between items in a formatted block, like Parameters or Returns. If True, you can still create a new section using two empty lines.</p> </li> <li> warn_unknown_params             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Warn about documented parameters not appearing in the signature.</p> </li> <li> **options             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional parsing options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[DocstringSection]</code>         \u2013          <p>A list of docstring sections.</p> </li> </ul> Source code in <code>src/griffe/docstrings/numpy.py</code> <pre><code>def parse(\n    docstring: Docstring,\n    *,\n    ignore_init_summary: bool = False,\n    trim_doctest_flags: bool = True,\n    allow_section_blank_line: bool = False,\n    warn_unknown_params: bool = True,\n    **options: Any,\n) -&gt; list[DocstringSection]:\n\"\"\"Parse a docstring.\n\n    This function iterates on lines of a docstring to build sections.\n    It then returns this list of sections.\n\n    Parameters:\n        docstring: The docstring to parse.\n        ignore_init_summary: Whether to ignore the summary in `__init__` methods' docstrings.\n        trim_doctest_flags: Whether to remove doctest flags from Python example blocks.\n        allow_section_blank_line: Whether to continue a section if there's an empty line\n            between items in a formatted block, like Parameters or Returns.\n            If True, you can still create a new section using two empty lines.\n        warn_unknown_params: Warn about documented parameters not appearing in the signature.\n        **options: Additional parsing options.\n\n    Returns:\n        A list of docstring sections.\n    \"\"\"\n    sections: list[DocstringSection] = []\n    current_section = []\n\n    in_code_block = False\n    lines = docstring.lines\n\n    options = {\n        \"trim_doctest_flags\": trim_doctest_flags,\n        \"ignore_init_summary\": ignore_init_summary,\n        \"allow_section_blank_line\": allow_section_blank_line,\n        \"warn_unknown_params\": warn_unknown_params,\n        **options,\n    }\n\n    ignore_summary = (\n        options[\"ignore_init_summary\"]\n        and docstring.parent is not None\n        and docstring.parent.name == \"__init__\"\n        and docstring.parent.is_function\n        and docstring.parent.parent is not None\n        and docstring.parent.parent.is_class\n    )\n\n    offset = 2 if ignore_summary else 0\n\n    while offset &lt; len(lines):\n        line_lower = lines[offset].lower()\n\n        if in_code_block:\n            if line_lower.lstrip(\" \").startswith(\"```\"):\n                in_code_block = False\n            current_section.append(lines[offset])\n\n        elif line_lower in _section_kind and _is_dash_line(lines[offset + 1]):\n            if current_section:\n                if any(current_section):\n                    sections.append(DocstringSectionText(\"\\n\".join(current_section).rstrip(\"\\n\")))\n                current_section = []\n            reader = _section_reader[_section_kind[line_lower]]\n            section, offset = reader(docstring, offset=offset + 2, **options)  # type: ignore[operator]\n            if section:\n                sections.append(section)\n\n        elif line_lower.lstrip(\" \").startswith(\"```\"):\n            in_code_block = True\n            current_section.append(lines[offset])\n\n        else:\n            current_section.append(lines[offset])\n\n        offset += 1\n\n    if current_section:\n        sections.append(DocstringSectionText(\"\\n\".join(current_section).rstrip(\"\\n\")))\n\n    return sections\n</code></pre>"},{"location":"reference/griffe/docstrings/parsers/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> parsers","text":""},{"location":"reference/griffe/docstrings/parsers/#griffe.docstrings.parsers","title":"parsers","text":"<p>This module imports all the defined parsers.</p> <p>Classes:</p> <ul> <li> Parser         \u2013          <p>Enumeration for the different docstring parsers.</p> </li> </ul> <p>Functions:</p> <ul> <li> parse           \u2013            <p>Parse the docstring.</p> </li> </ul>"},{"location":"reference/griffe/docstrings/parsers/#griffe.docstrings.parsers.Parser","title":"Parser","text":"<p>             Bases: <code>Enum</code></p> <p>Enumeration for the different docstring parsers.</p>"},{"location":"reference/griffe/docstrings/parsers/#griffe.docstrings.parsers.parse","title":"parse","text":"<pre><code>parse(\n    docstring: Docstring,\n    parser: Literal[\"google\", \"numpy\", \"sphinx\"]\n    | Parser\n    | None,\n    **options: Any\n) -&gt; list[DocstringSection]\n</code></pre> <p>Parse the docstring.</p> <p>Parameters:</p> <ul> <li> docstring             (<code>Docstring</code>)         \u2013          <p>The docstring to parse.</p> </li> <li> parser             (<code>Literal['google', 'numpy', 'sphinx'] | Parser | None</code>)         \u2013          <p>The docstring parser to use. If None, return a single text section.</p> </li> <li> **options             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>The options accepted by the parser.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[DocstringSection]</code>         \u2013          <p>A list of docstring sections.</p> </li> </ul> Source code in <code>src/griffe/docstrings/parsers.py</code> <pre><code>def parse(\n    docstring: Docstring,\n    parser: Literal[\"google\", \"numpy\", \"sphinx\"] | Parser | None,\n    **options: Any,\n) -&gt; list[DocstringSection]:\n\"\"\"Parse the docstring.\n\n    Parameters:\n        docstring: The docstring to parse.\n        parser: The docstring parser to use. If None, return a single text section.\n        **options: The options accepted by the parser.\n\n    Returns:\n        A list of docstring sections.\n    \"\"\"\n    if parser:\n        if isinstance(parser, str):\n            parser = Parser(parser)\n        return parsers[parser](docstring, **options)  # type: ignore[operator]\n    return [DocstringSectionText(docstring.value)]\n</code></pre>"},{"location":"reference/griffe/docstrings/sphinx/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> sphinx","text":""},{"location":"reference/griffe/docstrings/sphinx/#griffe.docstrings.sphinx","title":"sphinx","text":"<p>This module defines functions to parse Sphinx docstrings into structured data.</p> <p>Credits to Patrick Lannigan (@plannigan) who originally added the parser in the pytkdocs project. See https://github.com/mkdocstrings/pytkdocs/pull/71.</p> <p>Classes:</p> <ul> <li> FieldType         \u2013          <p>Maps directive names to parser functions.</p> </li> <li> ParsedDirective         \u2013          <p>Directive information that has been parsed from a docstring.</p> </li> <li> ParsedValues         \u2013          <p>Values parsed from the docstring to be used to produce sections.</p> </li> </ul> <p>Functions:</p> <ul> <li> parse           \u2013            <p>Parse a Sphinx-styled docstring.</p> </li> </ul>"},{"location":"reference/griffe/docstrings/sphinx/#griffe.docstrings.sphinx.FieldType","title":"FieldType  <code>dataclass</code>","text":"<p>Maps directive names to parser functions.</p> <p>Methods:</p> <ul> <li> matches           \u2013            <p>Check if a line matches the field type.</p> </li> </ul>"},{"location":"reference/griffe/docstrings/sphinx/#griffe.docstrings.sphinx.FieldType.matches","title":"matches","text":"<pre><code>matches(line: str) -&gt; bool\n</code></pre> <p>Check if a line matches the field type.</p> <p>Parameters:</p> <ul> <li> line             (<code>str</code>)         \u2013          <p>Line to check against</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013          <p>True if the line matches the field type, False otherwise.</p> </li> </ul> Source code in <code>src/griffe/docstrings/sphinx.py</code> <pre><code>def matches(self, line: str) -&gt; bool:\n\"\"\"Check if a line matches the field type.\n\n    Parameters:\n        line: Line to check against\n\n    Returns:\n        True if the line matches the field type, False otherwise.\n    \"\"\"\n    return any(line.startswith(f\":{name}\") for name in self.names)\n</code></pre>"},{"location":"reference/griffe/docstrings/sphinx/#griffe.docstrings.sphinx.ParsedDirective","title":"ParsedDirective  <code>dataclass</code>","text":"<p>Directive information that has been parsed from a docstring.</p>"},{"location":"reference/griffe/docstrings/sphinx/#griffe.docstrings.sphinx.ParsedValues","title":"ParsedValues  <code>dataclass</code>","text":"<p>Values parsed from the docstring to be used to produce sections.</p>"},{"location":"reference/griffe/docstrings/sphinx/#griffe.docstrings.sphinx.parse","title":"parse","text":"<pre><code>parse(\n    docstring: Docstring, **options: Any\n) -&gt; list[DocstringSection]\n</code></pre> <p>Parse a Sphinx-styled docstring.</p> <p>Parameters:</p> <ul> <li> docstring             (<code>Docstring</code>)         \u2013          <p>The docstring to parse.</p> </li> <li> **options             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional parsing options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[DocstringSection]</code>         \u2013          <p>A list of docstring sections.</p> </li> </ul> Source code in <code>src/griffe/docstrings/sphinx.py</code> <pre><code>def parse(docstring: Docstring, **options: Any) -&gt; list[DocstringSection]:  # noqa: ARG001\n\"\"\"Parse a Sphinx-styled docstring.\n\n    Parameters:\n        docstring: The docstring to parse.\n        **options: Additional parsing options.\n\n    Returns:\n        A list of docstring sections.\n    \"\"\"\n    parsed_values = ParsedValues()\n\n    lines = docstring.lines\n    curr_line_index = 0\n\n    while curr_line_index &lt; len(lines):\n        line = lines[curr_line_index]\n        for field_type in field_types:\n            if field_type.matches(line):\n                # https://github.com/python/mypy/issues/5485\n                curr_line_index = field_type.reader(docstring, curr_line_index, parsed_values)\n                break\n        else:\n            parsed_values.description.append(line)\n\n        curr_line_index += 1\n\n    return _parsed_values_to_sections(parsed_values)\n</code></pre>"},{"location":"reference/griffe/docstrings/utils/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> utils","text":""},{"location":"reference/griffe/docstrings/utils/#griffe.docstrings.utils","title":"utils","text":"<p>This module contains utilities for docstrings parsers.</p> <p>Functions:</p> <ul> <li> parse_annotation           \u2013            <p>Parse a string into a true name or expression that can be resolved later.</p> </li> <li> warning           \u2013            <p>Create and return a warn function.</p> </li> </ul>"},{"location":"reference/griffe/docstrings/utils/#griffe.docstrings.utils.parse_annotation","title":"parse_annotation","text":"<pre><code>parse_annotation(\n    annotation: str,\n    docstring: Docstring,\n    log_level: LogLevel = LogLevel.error,\n) -&gt; str | Expr\n</code></pre> <p>Parse a string into a true name or expression that can be resolved later.</p> <p>Parameters:</p> <ul> <li> annotation             (<code>str</code>)         \u2013          <p>The annotation to parse.</p> </li> <li> docstring             (<code>Docstring</code>)         \u2013          <p>The docstring in which the annotation appears. The docstring's parent is accessed to bind a resolver to the resulting name/expression.</p> </li> <li> log_level             (<code>LogLevel</code>, default:                 <code>error</code> )         \u2013          <p>Log level to use to log a message.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str | Expr</code>         \u2013          <p>The string unchanged, or a new name or expression.</p> </li> </ul> Source code in <code>src/griffe/docstrings/utils.py</code> <pre><code>def parse_annotation(\n    annotation: str,\n    docstring: Docstring,\n    log_level: LogLevel = LogLevel.error,\n) -&gt; str | Expr:\n\"\"\"Parse a string into a true name or expression that can be resolved later.\n\n    Parameters:\n        annotation: The annotation to parse.\n        docstring: The docstring in which the annotation appears.\n            The docstring's parent is accessed to bind a resolver to the resulting name/expression.\n        log_level: Log level to use to log a message.\n\n    Returns:\n        The string unchanged, or a new name or expression.\n    \"\"\"\n    with suppress(\n        AttributeError,  # docstring has no parent that can be used to resolve names\n        SyntaxError,  # annotation contains syntax errors\n    ):\n        code = compile(annotation, mode=\"eval\", filename=\"\", flags=PyCF_ONLY_AST, optimize=2)\n        if code.body:  # type: ignore[attr-defined]\n            name_or_expr = safe_get_annotation(\n                code.body,  # type: ignore[attr-defined]\n                parent=docstring.parent,\n                log_level=log_level,\n            )\n            return name_or_expr or annotation\n    return annotation\n</code></pre>"},{"location":"reference/griffe/docstrings/utils/#griffe.docstrings.utils.warning","title":"warning","text":"<pre><code>warning(name: str) -&gt; WarningCallable\n</code></pre> <p>Create and return a warn function.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013          <p>The logger name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>WarningCallable</code>         \u2013          <p>A function used to log parsing warnings.</p> </li> </ul> <p>This function logs a warning message by prefixing it with the filepath and line number.</p> <p>Parameters of the returned function:</p> <ul> <li> docstring             (<code>Docstring</code>)         \u2013          <p>The docstring object.</p> </li> <li> offset             (<code>int</code>)         \u2013          <p>The offset in the docstring lines.</p> </li> <li> message             (<code>str</code>)         \u2013          <p>The message to log.</p> </li> </ul> Source code in <code>src/griffe/docstrings/utils.py</code> <pre><code>def warning(name: str) -&gt; WarningCallable:\n\"\"\"Create and return a warn function.\n\n    Parameters:\n        name: The logger name.\n\n    Returns:\n        A function used to log parsing warnings.\n\n    This function logs a warning message by prefixing it with the filepath and line number.\n\n    Other parameters: Parameters of the returned function:\n        docstring (Docstring): The docstring object.\n        offset (int): The offset in the docstring lines.\n        message (str): The message to log.\n    \"\"\"\n    logger = get_logger(name)\n\n    def warn(docstring: Docstring, offset: int, message: str, log_level: LogLevel = LogLevel.warning) -&gt; None:\n        try:\n            prefix = docstring.parent.relative_filepath  # type: ignore[union-attr]\n        except (AttributeError, ValueError):\n            prefix = \"&lt;module&gt;\"\n        log = getattr(logger, log_level.value)\n        log(f\"{prefix}:{(docstring.lineno or 0)+offset}: {message}\")\n\n    return warn\n</code></pre>"},{"location":"reference/griffe/extensions/","title":"Index","text":""},{"location":"reference/griffe/extensions/#griffe.extensions","title":"extensions","text":"<p>This module is the public interface to import elements from the base.</p> <p>Modules:</p> <ul> <li> base         \u2013          <p>This module contains the base classes for dealing with extensions.</p> </li> <li> hybrid         \u2013          <p>Deprecated. This extension provides an hybrid behavior while loading data.</p> </li> </ul> <p>Classes:</p> <ul> <li> Extension         \u2013          <p>Base class for Griffe extensions.</p> </li> <li> Extensions         \u2013          <p>This class helps iterating on extensions that should run at different times.</p> </li> <li> InspectorExtension         \u2013          <p>Deprecated in favor of <code>Extension</code>. The object inspector extension base class, to inherit from.</p> </li> <li> VisitorExtension         \u2013          <p>Deprecated in favor of <code>Extension</code>. The node visitor extension base class, to inherit from.</p> </li> <li> When         \u2013          <p>This enumeration contains the different times at which an extension is used.</p> </li> </ul> <p>Functions:</p> <ul> <li> load_extensions           \u2013            <p>Load configured extensions.</p> </li> </ul>"},{"location":"reference/griffe/extensions/#griffe.extensions.Extension","title":"Extension","text":"<p>Base class for Griffe extensions.</p> <p>Methods:</p> <ul> <li> generic_inspect           \u2013            <p>Extend the base generic inspection with extensions.</p> </li> <li> generic_visit           \u2013            <p>Visit children nodes.</p> </li> <li> inspect           \u2013            <p>Inspect a node.</p> </li> <li> on_attribute_instance           \u2013            <p>Run when an Attribute has been created.</p> </li> <li> on_attribute_node           \u2013            <p>Run when visiting a new attribute node during static/dynamic analysis.</p> </li> <li> on_class_instance           \u2013            <p>Run when a Class has been created.</p> </li> <li> on_class_members           \u2013            <p>Run when members of a Class have been loaded.</p> </li> <li> on_class_node           \u2013            <p>Run when visiting a new class node during static/dynamic analysis.</p> </li> <li> on_function_instance           \u2013            <p>Run when a Function has been created.</p> </li> <li> on_function_node           \u2013            <p>Run when visiting a new function node during static/dynamic analysis.</p> </li> <li> on_instance           \u2013            <p>Run when an Object has been created.</p> </li> <li> on_members           \u2013            <p>Run when members of an Object have been loaded.</p> </li> <li> on_module_instance           \u2013            <p>Run when a Module has been created.</p> </li> <li> on_module_members           \u2013            <p>Run when members of a Module have been loaded.</p> </li> <li> on_module_node           \u2013            <p>Run when visiting a new module node during static/dynamic analysis.</p> </li> <li> on_node           \u2013            <p>Run when visiting a new node during static/dynamic analysis.</p> </li> <li> visit           \u2013            <p>Visit a node.</p> </li> </ul>"},{"location":"reference/griffe/extensions/#griffe.extensions.Extension.generic_inspect","title":"generic_inspect","text":"<pre><code>generic_inspect(node: ObjectNode) -&gt; None\n</code></pre> <p>Extend the base generic inspection with extensions.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013          <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def generic_inspect(self, node: ObjectNode) -&gt; None:\n\"\"\"Extend the base generic inspection with extensions.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    for child in node.children:\n        if not child.alias_target_path:\n            self.inspect(child)\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.Extension.generic_visit","title":"generic_visit","text":"<pre><code>generic_visit(node: AST) -&gt; None\n</code></pre> <p>Visit children nodes.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST</code>)         \u2013          <p>The node to visit the children of.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def generic_visit(self, node: ast.AST) -&gt; None:\n\"\"\"Visit children nodes.\n\n    Parameters:\n        node: The node to visit the children of.\n    \"\"\"\n    for child in ast_children(node):\n        self.visit(child)\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.Extension.inspect","title":"inspect","text":"<pre><code>inspect(node: ObjectNode) -&gt; None\n</code></pre> <p>Inspect a node.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013          <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def inspect(self, node: ObjectNode) -&gt; None:\n\"\"\"Inspect a node.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    getattr(self, f\"inspect_{node.kind}\", lambda _: None)(node)\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.Extension.on_attribute_instance","title":"on_attribute_instance","text":"<pre><code>on_attribute_instance(\n    *, node: AST | ObjectNode, attr: Attribute\n) -&gt; None\n</code></pre> <p>Run when an Attribute has been created.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> <li> attr             (<code>Attribute</code>)         \u2013          <p>The attribute instance.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_attribute_instance(self, *, node: ast.AST | ObjectNode, attr: Attribute) -&gt; None:\n\"\"\"Run when an Attribute has been created.\n\n    Parameters:\n        node: The currently visited node.\n        attr: The attribute instance.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.Extension.on_attribute_node","title":"on_attribute_node","text":"<pre><code>on_attribute_node(*, node: AST | ObjectNode) -&gt; None\n</code></pre> <p>Run when visiting a new attribute node during static/dynamic analysis.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_attribute_node(self, *, node: ast.AST | ObjectNode) -&gt; None:\n\"\"\"Run when visiting a new attribute node during static/dynamic analysis.\n\n    Parameters:\n        node: The currently visited node.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.Extension.on_class_instance","title":"on_class_instance","text":"<pre><code>on_class_instance(\n    *, node: AST | ObjectNode, cls: Class\n) -&gt; None\n</code></pre> <p>Run when a Class has been created.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> <li> cls             (<code>Class</code>)         \u2013          <p>The class instance.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_class_instance(self, *, node: ast.AST | ObjectNode, cls: Class) -&gt; None:\n\"\"\"Run when a Class has been created.\n\n    Parameters:\n        node: The currently visited node.\n        cls: The class instance.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.Extension.on_class_members","title":"on_class_members","text":"<pre><code>on_class_members(\n    *, node: AST | ObjectNode, cls: Class\n) -&gt; None\n</code></pre> <p>Run when members of a Class have been loaded.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> <li> cls             (<code>Class</code>)         \u2013          <p>The class instance.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_class_members(self, *, node: ast.AST | ObjectNode, cls: Class) -&gt; None:\n\"\"\"Run when members of a Class have been loaded.\n\n    Parameters:\n        node: The currently visited node.\n        cls: The class instance.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.Extension.on_class_node","title":"on_class_node","text":"<pre><code>on_class_node(*, node: AST | ObjectNode) -&gt; None\n</code></pre> <p>Run when visiting a new class node during static/dynamic analysis.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_class_node(self, *, node: ast.AST | ObjectNode) -&gt; None:\n\"\"\"Run when visiting a new class node during static/dynamic analysis.\n\n    Parameters:\n        node: The currently visited node.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.Extension.on_function_instance","title":"on_function_instance","text":"<pre><code>on_function_instance(\n    *, node: AST | ObjectNode, func: Function\n) -&gt; None\n</code></pre> <p>Run when a Function has been created.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> <li> func             (<code>Function</code>)         \u2013          <p>The function instance.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_function_instance(self, *, node: ast.AST | ObjectNode, func: Function) -&gt; None:\n\"\"\"Run when a Function has been created.\n\n    Parameters:\n        node: The currently visited node.\n        func: The function instance.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.Extension.on_function_node","title":"on_function_node","text":"<pre><code>on_function_node(*, node: AST | ObjectNode) -&gt; None\n</code></pre> <p>Run when visiting a new function node during static/dynamic analysis.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_function_node(self, *, node: ast.AST | ObjectNode) -&gt; None:\n\"\"\"Run when visiting a new function node during static/dynamic analysis.\n\n    Parameters:\n        node: The currently visited node.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.Extension.on_instance","title":"on_instance","text":"<pre><code>on_instance(*, node: AST | ObjectNode, obj: Object) -&gt; None\n</code></pre> <p>Run when an Object has been created.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> <li> obj             (<code>Object</code>)         \u2013          <p>The object instance.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_instance(self, *, node: ast.AST | ObjectNode, obj: Object) -&gt; None:\n\"\"\"Run when an Object has been created.\n\n    Parameters:\n        node: The currently visited node.\n        obj: The object instance.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.Extension.on_members","title":"on_members","text":"<pre><code>on_members(*, node: AST | ObjectNode, obj: Object) -&gt; None\n</code></pre> <p>Run when members of an Object have been loaded.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> <li> obj             (<code>Object</code>)         \u2013          <p>The object instance.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_members(self, *, node: ast.AST | ObjectNode, obj: Object) -&gt; None:\n\"\"\"Run when members of an Object have been loaded.\n\n    Parameters:\n        node: The currently visited node.\n        obj: The object instance.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.Extension.on_module_instance","title":"on_module_instance","text":"<pre><code>on_module_instance(\n    *, node: AST | ObjectNode, mod: Module\n) -&gt; None\n</code></pre> <p>Run when a Module has been created.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> <li> mod             (<code>Module</code>)         \u2013          <p>The module instance.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_module_instance(self, *, node: ast.AST | ObjectNode, mod: Module) -&gt; None:\n\"\"\"Run when a Module has been created.\n\n    Parameters:\n        node: The currently visited node.\n        mod: The module instance.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.Extension.on_module_members","title":"on_module_members","text":"<pre><code>on_module_members(\n    *, node: AST | ObjectNode, mod: Module\n) -&gt; None\n</code></pre> <p>Run when members of a Module have been loaded.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> <li> mod             (<code>Module</code>)         \u2013          <p>The module instance.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_module_members(self, *, node: ast.AST | ObjectNode, mod: Module) -&gt; None:\n\"\"\"Run when members of a Module have been loaded.\n\n    Parameters:\n        node: The currently visited node.\n        mod: The module instance.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.Extension.on_module_node","title":"on_module_node","text":"<pre><code>on_module_node(*, node: AST | ObjectNode) -&gt; None\n</code></pre> <p>Run when visiting a new module node during static/dynamic analysis.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_module_node(self, *, node: ast.AST | ObjectNode) -&gt; None:\n\"\"\"Run when visiting a new module node during static/dynamic analysis.\n\n    Parameters:\n        node: The currently visited node.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.Extension.on_node","title":"on_node","text":"<pre><code>on_node(*, node: AST | ObjectNode) -&gt; None\n</code></pre> <p>Run when visiting a new node during static/dynamic analysis.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_node(self, *, node: ast.AST | ObjectNode) -&gt; None:\n\"\"\"Run when visiting a new node during static/dynamic analysis.\n\n    Parameters:\n        node: The currently visited node.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.Extension.visit","title":"visit","text":"<pre><code>visit(node: AST) -&gt; None\n</code></pre> <p>Visit a node.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST</code>)         \u2013          <p>The node to visit.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def visit(self, node: ast.AST) -&gt; None:\n\"\"\"Visit a node.\n\n    Parameters:\n        node: The node to visit.\n    \"\"\"\n    getattr(self, f\"visit_{ast_kind(node)}\", lambda _: None)(node)\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.Extensions","title":"Extensions","text":"<pre><code>Extensions(*extensions: ExtensionType)\n</code></pre> <p>This class helps iterating on extensions that should run at different times.</p> <p>Parameters:</p> <ul> <li> *extensions             (<code>ExtensionType</code>, default:                 <code>()</code> )         \u2013          <p>The extensions to add.</p> </li> </ul> <p>Methods:</p> <ul> <li> add           \u2013            <p>Add extensions to this container.</p> </li> <li> attach_inspector           \u2013            <p>Attach a parent inspector to the inspector extensions.</p> </li> <li> attach_visitor           \u2013            <p>Attach a parent visitor to the visitor extensions.</p> </li> <li> call           \u2013            <p>Call the extension hook for the given event.</p> </li> </ul> <p>Attributes:</p> <ul> <li> after_children_inspection             (<code>list[InspectorExtension]</code>)         \u2013          <p>Return the inspectors that run after the children inspection.</p> </li> <li> after_children_visit             (<code>list[VisitorExtension]</code>)         \u2013          <p>Return the visitors that run after the children visit.</p> </li> <li> after_inspection             (<code>list[InspectorExtension]</code>)         \u2013          <p>Return the inspectors that run after the inspection.</p> </li> <li> after_visit             (<code>list[VisitorExtension]</code>)         \u2013          <p>Return the visitors that run after the visit.</p> </li> <li> before_children_inspection             (<code>list[InspectorExtension]</code>)         \u2013          <p>Return the inspectors that run before the children inspection.</p> </li> <li> before_children_visit             (<code>list[VisitorExtension]</code>)         \u2013          <p>Return the visitors that run before the children visit.</p> </li> <li> before_inspection             (<code>list[InspectorExtension]</code>)         \u2013          <p>Return the inspectors that run before the inspection.</p> </li> <li> before_visit             (<code>list[VisitorExtension]</code>)         \u2013          <p>Return the visitors that run before the visit.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def __init__(self, *extensions: ExtensionType) -&gt; None:\n\"\"\"Initialize the extensions container.\n\n    Parameters:\n        *extensions: The extensions to add.\n    \"\"\"\n    self._visitors: dict[When, list[VisitorExtension]] = defaultdict(list)\n    self._inspectors: dict[When, list[InspectorExtension]] = defaultdict(list)\n    self._extensions: list[Extension] = []\n    self.add(*extensions)\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.Extensions.after_children_inspection","title":"after_children_inspection  <code>property</code>","text":"<pre><code>after_children_inspection: list[InspectorExtension]\n</code></pre> <p>Return the inspectors that run after the children inspection.</p> <p>Returns:</p> <ul> <li> <code>list[InspectorExtension]</code>         \u2013          <p>Inspectors.</p> </li> </ul>"},{"location":"reference/griffe/extensions/#griffe.extensions.Extensions.after_children_visit","title":"after_children_visit  <code>property</code>","text":"<pre><code>after_children_visit: list[VisitorExtension]\n</code></pre> <p>Return the visitors that run after the children visit.</p> <p>Returns:</p> <ul> <li> <code>list[VisitorExtension]</code>         \u2013          <p>Visitors.</p> </li> </ul>"},{"location":"reference/griffe/extensions/#griffe.extensions.Extensions.after_inspection","title":"after_inspection  <code>property</code>","text":"<pre><code>after_inspection: list[InspectorExtension]\n</code></pre> <p>Return the inspectors that run after the inspection.</p> <p>Returns:</p> <ul> <li> <code>list[InspectorExtension]</code>         \u2013          <p>Inspectors.</p> </li> </ul>"},{"location":"reference/griffe/extensions/#griffe.extensions.Extensions.after_visit","title":"after_visit  <code>property</code>","text":"<pre><code>after_visit: list[VisitorExtension]\n</code></pre> <p>Return the visitors that run after the visit.</p> <p>Returns:</p> <ul> <li> <code>list[VisitorExtension]</code>         \u2013          <p>Visitors.</p> </li> </ul>"},{"location":"reference/griffe/extensions/#griffe.extensions.Extensions.before_children_inspection","title":"before_children_inspection  <code>property</code>","text":"<pre><code>before_children_inspection: list[InspectorExtension]\n</code></pre> <p>Return the inspectors that run before the children inspection.</p> <p>Returns:</p> <ul> <li> <code>list[InspectorExtension]</code>         \u2013          <p>Inspectors.</p> </li> </ul>"},{"location":"reference/griffe/extensions/#griffe.extensions.Extensions.before_children_visit","title":"before_children_visit  <code>property</code>","text":"<pre><code>before_children_visit: list[VisitorExtension]\n</code></pre> <p>Return the visitors that run before the children visit.</p> <p>Returns:</p> <ul> <li> <code>list[VisitorExtension]</code>         \u2013          <p>Visitors.</p> </li> </ul>"},{"location":"reference/griffe/extensions/#griffe.extensions.Extensions.before_inspection","title":"before_inspection  <code>property</code>","text":"<pre><code>before_inspection: list[InspectorExtension]\n</code></pre> <p>Return the inspectors that run before the inspection.</p> <p>Returns:</p> <ul> <li> <code>list[InspectorExtension]</code>         \u2013          <p>Inspectors.</p> </li> </ul>"},{"location":"reference/griffe/extensions/#griffe.extensions.Extensions.before_visit","title":"before_visit  <code>property</code>","text":"<pre><code>before_visit: list[VisitorExtension]\n</code></pre> <p>Return the visitors that run before the visit.</p> <p>Returns:</p> <ul> <li> <code>list[VisitorExtension]</code>         \u2013          <p>Visitors.</p> </li> </ul>"},{"location":"reference/griffe/extensions/#griffe.extensions.Extensions.add","title":"add","text":"<pre><code>add(*extensions: ExtensionType) -&gt; None\n</code></pre> <p>Add extensions to this container.</p> <p>Parameters:</p> <ul> <li> *extensions             (<code>ExtensionType</code>, default:                 <code>()</code> )         \u2013          <p>The extensions to add.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def add(self, *extensions: ExtensionType) -&gt; None:\n\"\"\"Add extensions to this container.\n\n    Parameters:\n        *extensions: The extensions to add.\n    \"\"\"\n    for extension in extensions:\n        if isinstance(extension, VisitorExtension):\n            self._visitors[extension.when].append(extension)\n        elif isinstance(extension, InspectorExtension):\n            self._inspectors[extension.when].append(extension)\n        else:\n            self._extensions.append(extension)\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.Extensions.attach_inspector","title":"attach_inspector","text":"<pre><code>attach_inspector(parent_inspector: Inspector) -&gt; Extensions\n</code></pre> <p>Attach a parent inspector to the inspector extensions.</p> <p>Parameters:</p> <ul> <li> parent_inspector             (<code>Inspector</code>)         \u2013          <p>The parent inspector, leading the inspection.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Extensions</code>         \u2013          <p>Self, conveniently.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def attach_inspector(self, parent_inspector: Inspector) -&gt; Extensions:\n\"\"\"Attach a parent inspector to the inspector extensions.\n\n    Parameters:\n        parent_inspector: The parent inspector, leading the inspection.\n\n    Returns:\n        Self, conveniently.\n    \"\"\"\n    for when in self._inspectors:\n        for inspector in self._inspectors[when]:\n            inspector.attach(parent_inspector)\n    return self\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.Extensions.attach_visitor","title":"attach_visitor","text":"<pre><code>attach_visitor(parent_visitor: Visitor) -&gt; Extensions\n</code></pre> <p>Attach a parent visitor to the visitor extensions.</p> <p>Parameters:</p> <ul> <li> parent_visitor             (<code>Visitor</code>)         \u2013          <p>The parent visitor, leading the visit.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Extensions</code>         \u2013          <p>Self, conveniently.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def attach_visitor(self, parent_visitor: Visitor) -&gt; Extensions:\n\"\"\"Attach a parent visitor to the visitor extensions.\n\n    Parameters:\n        parent_visitor: The parent visitor, leading the visit.\n\n    Returns:\n        Self, conveniently.\n    \"\"\"\n    for when in self._visitors:\n        for visitor in self._visitors[when]:\n            visitor.attach(parent_visitor)\n    return self\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.Extensions.call","title":"call","text":"<pre><code>call(\n    event: str, *, node: AST | ObjectNode, **kwargs: Any\n) -&gt; None\n</code></pre> <p>Call the extension hook for the given event.</p> <p>Parameters:</p> <ul> <li> event             (<code>str</code>)         \u2013          <p>The trigerred event.</p> </li> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The AST or Object node.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional arguments like a Griffe object.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def call(self, event: str, *, node: ast.AST | ObjectNode, **kwargs: Any) -&gt; None:\n\"\"\"Call the extension hook for the given event.\n\n    Parameters:\n        event: The trigerred event.\n        node: The AST or Object node.\n        **kwargs: Additional arguments like a Griffe object.\n    \"\"\"\n    for extension in self._extensions:\n        getattr(extension, event)(node=node, **kwargs)\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.InspectorExtension","title":"InspectorExtension","text":"<pre><code>InspectorExtension()\n</code></pre> <p>Deprecated in favor of <code>Extension</code>. The object inspector extension base class, to inherit from.</p> <p>Methods:</p> <ul> <li> attach           \u2013            <p>Attach the parent inspector to this extension.</p> </li> <li> inspect           \u2013            <p>Inspect a node.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Initialize the inspector extension.\"\"\"\n    warnings.warn(\n        \"Inspector extensions are deprecated in favor of the new, more developer-friendly Extension. \"\n        \"See https://mkdocstrings.github.io/griffe/extensions/\",\n        DeprecationWarning,\n        stacklevel=1,\n    )\n    self.inspector: Inspector = None  # type: ignore[assignment]\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.InspectorExtension.attach","title":"attach","text":"<pre><code>attach(inspector: Inspector) -&gt; None\n</code></pre> <p>Attach the parent inspector to this extension.</p> <p>Parameters:</p> <ul> <li> inspector             (<code>Inspector</code>)         \u2013          <p>The parent inspector.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def attach(self, inspector: Inspector) -&gt; None:\n\"\"\"Attach the parent inspector to this extension.\n\n    Parameters:\n        inspector: The parent inspector.\n    \"\"\"\n    self.inspector = inspector\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.InspectorExtension.inspect","title":"inspect","text":"<pre><code>inspect(node: ObjectNode) -&gt; None\n</code></pre> <p>Inspect a node.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013          <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def inspect(self, node: ObjectNode) -&gt; None:\n\"\"\"Inspect a node.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    getattr(self, f\"inspect_{node.kind}\", lambda _: None)(node)\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.VisitorExtension","title":"VisitorExtension","text":"<pre><code>VisitorExtension()\n</code></pre> <p>Deprecated in favor of <code>Extension</code>. The node visitor extension base class, to inherit from.</p> <p>Methods:</p> <ul> <li> attach           \u2013            <p>Attach the parent visitor to this extension.</p> </li> <li> visit           \u2013            <p>Visit a node.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Initialize the visitor extension.\"\"\"\n    warnings.warn(\n        \"Visitor extensions are deprecated in favor of the new, more developer-friendly Extension. \"\n        \"See https://mkdocstrings.github.io/griffe/extensions/\",\n        DeprecationWarning,\n        stacklevel=1,\n    )\n    self.visitor: Visitor = None  # type: ignore[assignment]\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.VisitorExtension.attach","title":"attach","text":"<pre><code>attach(visitor: Visitor) -&gt; None\n</code></pre> <p>Attach the parent visitor to this extension.</p> <p>Parameters:</p> <ul> <li> visitor             (<code>Visitor</code>)         \u2013          <p>The parent visitor.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def attach(self, visitor: Visitor) -&gt; None:\n\"\"\"Attach the parent visitor to this extension.\n\n    Parameters:\n        visitor: The parent visitor.\n    \"\"\"\n    self.visitor = visitor\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.VisitorExtension.visit","title":"visit","text":"<pre><code>visit(node: AST) -&gt; None\n</code></pre> <p>Visit a node.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST</code>)         \u2013          <p>The node to visit.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def visit(self, node: ast.AST) -&gt; None:\n\"\"\"Visit a node.\n\n    Parameters:\n        node: The node to visit.\n    \"\"\"\n    getattr(self, f\"visit_{ast_kind(node)}\", lambda _: None)(node)\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.When","title":"When","text":"<p>             Bases: <code>Enum</code></p> <p>This enumeration contains the different times at which an extension is used.</p> <p>Attributes:</p> <ul> <li> before_all             (<code>int</code>)         \u2013          <p>For each node, before the visit/inspection.</p> </li> <li> before_children             (<code>int</code>)         \u2013          <p>For each node, after the visit has started, and before the children visit/inspection.</p> </li> <li> after_children             (<code>int</code>)         \u2013          <p>For each node, after the children have been visited/inspected, and before finishing the visit/inspection.</p> </li> <li> after_all             (<code>int</code>)         \u2013          <p>For each node, after the visit/inspection.</p> </li> </ul>"},{"location":"reference/griffe/extensions/#griffe.extensions.load_extensions","title":"load_extensions","text":"<pre><code>load_extensions(\n    exts: Sequence[\n        str\n        | dict[str, Any]\n        | ExtensionType\n        | type[ExtensionType]\n    ]\n) -&gt; Extensions\n</code></pre> <p>Load configured extensions.</p> <p>Parameters:</p> <ul> <li> exts             (<code>Sequence[str | dict[str, Any] | ExtensionType | type[ExtensionType]]</code>)         \u2013          <p>A sequence of extension, with potential configuration options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Extensions</code>         \u2013          <p>An extensions container.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def load_extensions(exts: Sequence[str | dict[str, Any] | ExtensionType | type[ExtensionType]]) -&gt; Extensions:\n\"\"\"Load configured extensions.\n\n    Parameters:\n        exts: A sequence of extension, with potential configuration options.\n\n    Returns:\n        An extensions container.\n    \"\"\"\n    extensions = Extensions()\n    for extension in exts:\n        ext = _load_extension(extension)\n        if isinstance(ext, list):\n            extensions.add(*ext)\n        else:\n            extensions.add(ext)\n    return extensions\n</code></pre>"},{"location":"reference/griffe/extensions/base/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> base","text":""},{"location":"reference/griffe/extensions/base/#griffe.extensions.base","title":"base","text":"<p>This module contains the base classes for dealing with extensions.</p> <p>Classes:</p> <ul> <li> Extension         \u2013          <p>Base class for Griffe extensions.</p> </li> <li> Extensions         \u2013          <p>This class helps iterating on extensions that should run at different times.</p> </li> <li> InspectorExtension         \u2013          <p>Deprecated in favor of <code>Extension</code>. The object inspector extension base class, to inherit from.</p> </li> <li> VisitorExtension         \u2013          <p>Deprecated in favor of <code>Extension</code>. The node visitor extension base class, to inherit from.</p> </li> <li> When         \u2013          <p>This enumeration contains the different times at which an extension is used.</p> </li> </ul> <p>Functions:</p> <ul> <li> load_extensions           \u2013            <p>Load configured extensions.</p> </li> </ul>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extension","title":"Extension","text":"<p>Base class for Griffe extensions.</p> <p>Methods:</p> <ul> <li> generic_inspect           \u2013            <p>Extend the base generic inspection with extensions.</p> </li> <li> generic_visit           \u2013            <p>Visit children nodes.</p> </li> <li> inspect           \u2013            <p>Inspect a node.</p> </li> <li> on_attribute_instance           \u2013            <p>Run when an Attribute has been created.</p> </li> <li> on_attribute_node           \u2013            <p>Run when visiting a new attribute node during static/dynamic analysis.</p> </li> <li> on_class_instance           \u2013            <p>Run when a Class has been created.</p> </li> <li> on_class_members           \u2013            <p>Run when members of a Class have been loaded.</p> </li> <li> on_class_node           \u2013            <p>Run when visiting a new class node during static/dynamic analysis.</p> </li> <li> on_function_instance           \u2013            <p>Run when a Function has been created.</p> </li> <li> on_function_node           \u2013            <p>Run when visiting a new function node during static/dynamic analysis.</p> </li> <li> on_instance           \u2013            <p>Run when an Object has been created.</p> </li> <li> on_members           \u2013            <p>Run when members of an Object have been loaded.</p> </li> <li> on_module_instance           \u2013            <p>Run when a Module has been created.</p> </li> <li> on_module_members           \u2013            <p>Run when members of a Module have been loaded.</p> </li> <li> on_module_node           \u2013            <p>Run when visiting a new module node during static/dynamic analysis.</p> </li> <li> on_node           \u2013            <p>Run when visiting a new node during static/dynamic analysis.</p> </li> <li> visit           \u2013            <p>Visit a node.</p> </li> </ul>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extension.generic_inspect","title":"generic_inspect","text":"<pre><code>generic_inspect(node: ObjectNode) -&gt; None\n</code></pre> <p>Extend the base generic inspection with extensions.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013          <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def generic_inspect(self, node: ObjectNode) -&gt; None:\n\"\"\"Extend the base generic inspection with extensions.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    for child in node.children:\n        if not child.alias_target_path:\n            self.inspect(child)\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extension.generic_visit","title":"generic_visit","text":"<pre><code>generic_visit(node: AST) -&gt; None\n</code></pre> <p>Visit children nodes.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST</code>)         \u2013          <p>The node to visit the children of.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def generic_visit(self, node: ast.AST) -&gt; None:\n\"\"\"Visit children nodes.\n\n    Parameters:\n        node: The node to visit the children of.\n    \"\"\"\n    for child in ast_children(node):\n        self.visit(child)\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extension.inspect","title":"inspect","text":"<pre><code>inspect(node: ObjectNode) -&gt; None\n</code></pre> <p>Inspect a node.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013          <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def inspect(self, node: ObjectNode) -&gt; None:\n\"\"\"Inspect a node.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    getattr(self, f\"inspect_{node.kind}\", lambda _: None)(node)\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extension.on_attribute_instance","title":"on_attribute_instance","text":"<pre><code>on_attribute_instance(\n    *, node: AST | ObjectNode, attr: Attribute\n) -&gt; None\n</code></pre> <p>Run when an Attribute has been created.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> <li> attr             (<code>Attribute</code>)         \u2013          <p>The attribute instance.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_attribute_instance(self, *, node: ast.AST | ObjectNode, attr: Attribute) -&gt; None:\n\"\"\"Run when an Attribute has been created.\n\n    Parameters:\n        node: The currently visited node.\n        attr: The attribute instance.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extension.on_attribute_node","title":"on_attribute_node","text":"<pre><code>on_attribute_node(*, node: AST | ObjectNode) -&gt; None\n</code></pre> <p>Run when visiting a new attribute node during static/dynamic analysis.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_attribute_node(self, *, node: ast.AST | ObjectNode) -&gt; None:\n\"\"\"Run when visiting a new attribute node during static/dynamic analysis.\n\n    Parameters:\n        node: The currently visited node.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extension.on_class_instance","title":"on_class_instance","text":"<pre><code>on_class_instance(\n    *, node: AST | ObjectNode, cls: Class\n) -&gt; None\n</code></pre> <p>Run when a Class has been created.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> <li> cls             (<code>Class</code>)         \u2013          <p>The class instance.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_class_instance(self, *, node: ast.AST | ObjectNode, cls: Class) -&gt; None:\n\"\"\"Run when a Class has been created.\n\n    Parameters:\n        node: The currently visited node.\n        cls: The class instance.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extension.on_class_members","title":"on_class_members","text":"<pre><code>on_class_members(\n    *, node: AST | ObjectNode, cls: Class\n) -&gt; None\n</code></pre> <p>Run when members of a Class have been loaded.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> <li> cls             (<code>Class</code>)         \u2013          <p>The class instance.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_class_members(self, *, node: ast.AST | ObjectNode, cls: Class) -&gt; None:\n\"\"\"Run when members of a Class have been loaded.\n\n    Parameters:\n        node: The currently visited node.\n        cls: The class instance.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extension.on_class_node","title":"on_class_node","text":"<pre><code>on_class_node(*, node: AST | ObjectNode) -&gt; None\n</code></pre> <p>Run when visiting a new class node during static/dynamic analysis.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_class_node(self, *, node: ast.AST | ObjectNode) -&gt; None:\n\"\"\"Run when visiting a new class node during static/dynamic analysis.\n\n    Parameters:\n        node: The currently visited node.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extension.on_function_instance","title":"on_function_instance","text":"<pre><code>on_function_instance(\n    *, node: AST | ObjectNode, func: Function\n) -&gt; None\n</code></pre> <p>Run when a Function has been created.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> <li> func             (<code>Function</code>)         \u2013          <p>The function instance.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_function_instance(self, *, node: ast.AST | ObjectNode, func: Function) -&gt; None:\n\"\"\"Run when a Function has been created.\n\n    Parameters:\n        node: The currently visited node.\n        func: The function instance.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extension.on_function_node","title":"on_function_node","text":"<pre><code>on_function_node(*, node: AST | ObjectNode) -&gt; None\n</code></pre> <p>Run when visiting a new function node during static/dynamic analysis.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_function_node(self, *, node: ast.AST | ObjectNode) -&gt; None:\n\"\"\"Run when visiting a new function node during static/dynamic analysis.\n\n    Parameters:\n        node: The currently visited node.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extension.on_instance","title":"on_instance","text":"<pre><code>on_instance(*, node: AST | ObjectNode, obj: Object) -&gt; None\n</code></pre> <p>Run when an Object has been created.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> <li> obj             (<code>Object</code>)         \u2013          <p>The object instance.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_instance(self, *, node: ast.AST | ObjectNode, obj: Object) -&gt; None:\n\"\"\"Run when an Object has been created.\n\n    Parameters:\n        node: The currently visited node.\n        obj: The object instance.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extension.on_members","title":"on_members","text":"<pre><code>on_members(*, node: AST | ObjectNode, obj: Object) -&gt; None\n</code></pre> <p>Run when members of an Object have been loaded.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> <li> obj             (<code>Object</code>)         \u2013          <p>The object instance.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_members(self, *, node: ast.AST | ObjectNode, obj: Object) -&gt; None:\n\"\"\"Run when members of an Object have been loaded.\n\n    Parameters:\n        node: The currently visited node.\n        obj: The object instance.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extension.on_module_instance","title":"on_module_instance","text":"<pre><code>on_module_instance(\n    *, node: AST | ObjectNode, mod: Module\n) -&gt; None\n</code></pre> <p>Run when a Module has been created.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> <li> mod             (<code>Module</code>)         \u2013          <p>The module instance.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_module_instance(self, *, node: ast.AST | ObjectNode, mod: Module) -&gt; None:\n\"\"\"Run when a Module has been created.\n\n    Parameters:\n        node: The currently visited node.\n        mod: The module instance.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extension.on_module_members","title":"on_module_members","text":"<pre><code>on_module_members(\n    *, node: AST | ObjectNode, mod: Module\n) -&gt; None\n</code></pre> <p>Run when members of a Module have been loaded.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> <li> mod             (<code>Module</code>)         \u2013          <p>The module instance.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_module_members(self, *, node: ast.AST | ObjectNode, mod: Module) -&gt; None:\n\"\"\"Run when members of a Module have been loaded.\n\n    Parameters:\n        node: The currently visited node.\n        mod: The module instance.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extension.on_module_node","title":"on_module_node","text":"<pre><code>on_module_node(*, node: AST | ObjectNode) -&gt; None\n</code></pre> <p>Run when visiting a new module node during static/dynamic analysis.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_module_node(self, *, node: ast.AST | ObjectNode) -&gt; None:\n\"\"\"Run when visiting a new module node during static/dynamic analysis.\n\n    Parameters:\n        node: The currently visited node.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extension.on_node","title":"on_node","text":"<pre><code>on_node(*, node: AST | ObjectNode) -&gt; None\n</code></pre> <p>Run when visiting a new node during static/dynamic analysis.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The currently visited node.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def on_node(self, *, node: ast.AST | ObjectNode) -&gt; None:\n\"\"\"Run when visiting a new node during static/dynamic analysis.\n\n    Parameters:\n        node: The currently visited node.\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extension.visit","title":"visit","text":"<pre><code>visit(node: AST) -&gt; None\n</code></pre> <p>Visit a node.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST</code>)         \u2013          <p>The node to visit.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def visit(self, node: ast.AST) -&gt; None:\n\"\"\"Visit a node.\n\n    Parameters:\n        node: The node to visit.\n    \"\"\"\n    getattr(self, f\"visit_{ast_kind(node)}\", lambda _: None)(node)\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extensions","title":"Extensions","text":"<pre><code>Extensions(*extensions: ExtensionType)\n</code></pre> <p>This class helps iterating on extensions that should run at different times.</p> <p>Parameters:</p> <ul> <li> *extensions             (<code>ExtensionType</code>, default:                 <code>()</code> )         \u2013          <p>The extensions to add.</p> </li> </ul> <p>Methods:</p> <ul> <li> add           \u2013            <p>Add extensions to this container.</p> </li> <li> attach_inspector           \u2013            <p>Attach a parent inspector to the inspector extensions.</p> </li> <li> attach_visitor           \u2013            <p>Attach a parent visitor to the visitor extensions.</p> </li> <li> call           \u2013            <p>Call the extension hook for the given event.</p> </li> </ul> <p>Attributes:</p> <ul> <li> after_children_inspection             (<code>list[InspectorExtension]</code>)         \u2013          <p>Return the inspectors that run after the children inspection.</p> </li> <li> after_children_visit             (<code>list[VisitorExtension]</code>)         \u2013          <p>Return the visitors that run after the children visit.</p> </li> <li> after_inspection             (<code>list[InspectorExtension]</code>)         \u2013          <p>Return the inspectors that run after the inspection.</p> </li> <li> after_visit             (<code>list[VisitorExtension]</code>)         \u2013          <p>Return the visitors that run after the visit.</p> </li> <li> before_children_inspection             (<code>list[InspectorExtension]</code>)         \u2013          <p>Return the inspectors that run before the children inspection.</p> </li> <li> before_children_visit             (<code>list[VisitorExtension]</code>)         \u2013          <p>Return the visitors that run before the children visit.</p> </li> <li> before_inspection             (<code>list[InspectorExtension]</code>)         \u2013          <p>Return the inspectors that run before the inspection.</p> </li> <li> before_visit             (<code>list[VisitorExtension]</code>)         \u2013          <p>Return the visitors that run before the visit.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def __init__(self, *extensions: ExtensionType) -&gt; None:\n\"\"\"Initialize the extensions container.\n\n    Parameters:\n        *extensions: The extensions to add.\n    \"\"\"\n    self._visitors: dict[When, list[VisitorExtension]] = defaultdict(list)\n    self._inspectors: dict[When, list[InspectorExtension]] = defaultdict(list)\n    self._extensions: list[Extension] = []\n    self.add(*extensions)\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extensions.after_children_inspection","title":"after_children_inspection  <code>property</code>","text":"<pre><code>after_children_inspection: list[InspectorExtension]\n</code></pre> <p>Return the inspectors that run after the children inspection.</p> <p>Returns:</p> <ul> <li> <code>list[InspectorExtension]</code>         \u2013          <p>Inspectors.</p> </li> </ul>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extensions.after_children_visit","title":"after_children_visit  <code>property</code>","text":"<pre><code>after_children_visit: list[VisitorExtension]\n</code></pre> <p>Return the visitors that run after the children visit.</p> <p>Returns:</p> <ul> <li> <code>list[VisitorExtension]</code>         \u2013          <p>Visitors.</p> </li> </ul>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extensions.after_inspection","title":"after_inspection  <code>property</code>","text":"<pre><code>after_inspection: list[InspectorExtension]\n</code></pre> <p>Return the inspectors that run after the inspection.</p> <p>Returns:</p> <ul> <li> <code>list[InspectorExtension]</code>         \u2013          <p>Inspectors.</p> </li> </ul>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extensions.after_visit","title":"after_visit  <code>property</code>","text":"<pre><code>after_visit: list[VisitorExtension]\n</code></pre> <p>Return the visitors that run after the visit.</p> <p>Returns:</p> <ul> <li> <code>list[VisitorExtension]</code>         \u2013          <p>Visitors.</p> </li> </ul>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extensions.before_children_inspection","title":"before_children_inspection  <code>property</code>","text":"<pre><code>before_children_inspection: list[InspectorExtension]\n</code></pre> <p>Return the inspectors that run before the children inspection.</p> <p>Returns:</p> <ul> <li> <code>list[InspectorExtension]</code>         \u2013          <p>Inspectors.</p> </li> </ul>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extensions.before_children_visit","title":"before_children_visit  <code>property</code>","text":"<pre><code>before_children_visit: list[VisitorExtension]\n</code></pre> <p>Return the visitors that run before the children visit.</p> <p>Returns:</p> <ul> <li> <code>list[VisitorExtension]</code>         \u2013          <p>Visitors.</p> </li> </ul>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extensions.before_inspection","title":"before_inspection  <code>property</code>","text":"<pre><code>before_inspection: list[InspectorExtension]\n</code></pre> <p>Return the inspectors that run before the inspection.</p> <p>Returns:</p> <ul> <li> <code>list[InspectorExtension]</code>         \u2013          <p>Inspectors.</p> </li> </ul>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extensions.before_visit","title":"before_visit  <code>property</code>","text":"<pre><code>before_visit: list[VisitorExtension]\n</code></pre> <p>Return the visitors that run before the visit.</p> <p>Returns:</p> <ul> <li> <code>list[VisitorExtension]</code>         \u2013          <p>Visitors.</p> </li> </ul>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extensions.add","title":"add","text":"<pre><code>add(*extensions: ExtensionType) -&gt; None\n</code></pre> <p>Add extensions to this container.</p> <p>Parameters:</p> <ul> <li> *extensions             (<code>ExtensionType</code>, default:                 <code>()</code> )         \u2013          <p>The extensions to add.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def add(self, *extensions: ExtensionType) -&gt; None:\n\"\"\"Add extensions to this container.\n\n    Parameters:\n        *extensions: The extensions to add.\n    \"\"\"\n    for extension in extensions:\n        if isinstance(extension, VisitorExtension):\n            self._visitors[extension.when].append(extension)\n        elif isinstance(extension, InspectorExtension):\n            self._inspectors[extension.when].append(extension)\n        else:\n            self._extensions.append(extension)\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extensions.attach_inspector","title":"attach_inspector","text":"<pre><code>attach_inspector(parent_inspector: Inspector) -&gt; Extensions\n</code></pre> <p>Attach a parent inspector to the inspector extensions.</p> <p>Parameters:</p> <ul> <li> parent_inspector             (<code>Inspector</code>)         \u2013          <p>The parent inspector, leading the inspection.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Extensions</code>         \u2013          <p>Self, conveniently.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def attach_inspector(self, parent_inspector: Inspector) -&gt; Extensions:\n\"\"\"Attach a parent inspector to the inspector extensions.\n\n    Parameters:\n        parent_inspector: The parent inspector, leading the inspection.\n\n    Returns:\n        Self, conveniently.\n    \"\"\"\n    for when in self._inspectors:\n        for inspector in self._inspectors[when]:\n            inspector.attach(parent_inspector)\n    return self\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extensions.attach_visitor","title":"attach_visitor","text":"<pre><code>attach_visitor(parent_visitor: Visitor) -&gt; Extensions\n</code></pre> <p>Attach a parent visitor to the visitor extensions.</p> <p>Parameters:</p> <ul> <li> parent_visitor             (<code>Visitor</code>)         \u2013          <p>The parent visitor, leading the visit.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Extensions</code>         \u2013          <p>Self, conveniently.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def attach_visitor(self, parent_visitor: Visitor) -&gt; Extensions:\n\"\"\"Attach a parent visitor to the visitor extensions.\n\n    Parameters:\n        parent_visitor: The parent visitor, leading the visit.\n\n    Returns:\n        Self, conveniently.\n    \"\"\"\n    for when in self._visitors:\n        for visitor in self._visitors[when]:\n            visitor.attach(parent_visitor)\n    return self\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extensions.call","title":"call","text":"<pre><code>call(\n    event: str, *, node: AST | ObjectNode, **kwargs: Any\n) -&gt; None\n</code></pre> <p>Call the extension hook for the given event.</p> <p>Parameters:</p> <ul> <li> event             (<code>str</code>)         \u2013          <p>The trigerred event.</p> </li> <li> node             (<code>AST | ObjectNode</code>)         \u2013          <p>The AST or Object node.</p> </li> <li> **kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>Additional arguments like a Griffe object.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def call(self, event: str, *, node: ast.AST | ObjectNode, **kwargs: Any) -&gt; None:\n\"\"\"Call the extension hook for the given event.\n\n    Parameters:\n        event: The trigerred event.\n        node: The AST or Object node.\n        **kwargs: Additional arguments like a Griffe object.\n    \"\"\"\n    for extension in self._extensions:\n        getattr(extension, event)(node=node, **kwargs)\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.InspectorExtension","title":"InspectorExtension","text":"<pre><code>InspectorExtension()\n</code></pre> <p>Deprecated in favor of <code>Extension</code>. The object inspector extension base class, to inherit from.</p> <p>Methods:</p> <ul> <li> attach           \u2013            <p>Attach the parent inspector to this extension.</p> </li> <li> inspect           \u2013            <p>Inspect a node.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Initialize the inspector extension.\"\"\"\n    warnings.warn(\n        \"Inspector extensions are deprecated in favor of the new, more developer-friendly Extension. \"\n        \"See https://mkdocstrings.github.io/griffe/extensions/\",\n        DeprecationWarning,\n        stacklevel=1,\n    )\n    self.inspector: Inspector = None  # type: ignore[assignment]\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.InspectorExtension.attach","title":"attach","text":"<pre><code>attach(inspector: Inspector) -&gt; None\n</code></pre> <p>Attach the parent inspector to this extension.</p> <p>Parameters:</p> <ul> <li> inspector             (<code>Inspector</code>)         \u2013          <p>The parent inspector.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def attach(self, inspector: Inspector) -&gt; None:\n\"\"\"Attach the parent inspector to this extension.\n\n    Parameters:\n        inspector: The parent inspector.\n    \"\"\"\n    self.inspector = inspector\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.InspectorExtension.inspect","title":"inspect","text":"<pre><code>inspect(node: ObjectNode) -&gt; None\n</code></pre> <p>Inspect a node.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013          <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def inspect(self, node: ObjectNode) -&gt; None:\n\"\"\"Inspect a node.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    getattr(self, f\"inspect_{node.kind}\", lambda _: None)(node)\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.VisitorExtension","title":"VisitorExtension","text":"<pre><code>VisitorExtension()\n</code></pre> <p>Deprecated in favor of <code>Extension</code>. The node visitor extension base class, to inherit from.</p> <p>Methods:</p> <ul> <li> attach           \u2013            <p>Attach the parent visitor to this extension.</p> </li> <li> visit           \u2013            <p>Visit a node.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Initialize the visitor extension.\"\"\"\n    warnings.warn(\n        \"Visitor extensions are deprecated in favor of the new, more developer-friendly Extension. \"\n        \"See https://mkdocstrings.github.io/griffe/extensions/\",\n        DeprecationWarning,\n        stacklevel=1,\n    )\n    self.visitor: Visitor = None  # type: ignore[assignment]\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.VisitorExtension.attach","title":"attach","text":"<pre><code>attach(visitor: Visitor) -&gt; None\n</code></pre> <p>Attach the parent visitor to this extension.</p> <p>Parameters:</p> <ul> <li> visitor             (<code>Visitor</code>)         \u2013          <p>The parent visitor.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def attach(self, visitor: Visitor) -&gt; None:\n\"\"\"Attach the parent visitor to this extension.\n\n    Parameters:\n        visitor: The parent visitor.\n    \"\"\"\n    self.visitor = visitor\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.VisitorExtension.visit","title":"visit","text":"<pre><code>visit(node: AST) -&gt; None\n</code></pre> <p>Visit a node.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST</code>)         \u2013          <p>The node to visit.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def visit(self, node: ast.AST) -&gt; None:\n\"\"\"Visit a node.\n\n    Parameters:\n        node: The node to visit.\n    \"\"\"\n    getattr(self, f\"visit_{ast_kind(node)}\", lambda _: None)(node)\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.When","title":"When","text":"<p>             Bases: <code>Enum</code></p> <p>This enumeration contains the different times at which an extension is used.</p> <p>Attributes:</p> <ul> <li> before_all             (<code>int</code>)         \u2013          <p>For each node, before the visit/inspection.</p> </li> <li> before_children             (<code>int</code>)         \u2013          <p>For each node, after the visit has started, and before the children visit/inspection.</p> </li> <li> after_children             (<code>int</code>)         \u2013          <p>For each node, after the children have been visited/inspected, and before finishing the visit/inspection.</p> </li> <li> after_all             (<code>int</code>)         \u2013          <p>For each node, after the visit/inspection.</p> </li> </ul>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.load_extensions","title":"load_extensions","text":"<pre><code>load_extensions(\n    exts: Sequence[\n        str\n        | dict[str, Any]\n        | ExtensionType\n        | type[ExtensionType]\n    ]\n) -&gt; Extensions\n</code></pre> <p>Load configured extensions.</p> <p>Parameters:</p> <ul> <li> exts             (<code>Sequence[str | dict[str, Any] | ExtensionType | type[ExtensionType]]</code>)         \u2013          <p>A sequence of extension, with potential configuration options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Extensions</code>         \u2013          <p>An extensions container.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def load_extensions(exts: Sequence[str | dict[str, Any] | ExtensionType | type[ExtensionType]]) -&gt; Extensions:\n\"\"\"Load configured extensions.\n\n    Parameters:\n        exts: A sequence of extension, with potential configuration options.\n\n    Returns:\n        An extensions container.\n    \"\"\"\n    extensions = Extensions()\n    for extension in exts:\n        ext = _load_extension(extension)\n        if isinstance(ext, list):\n            extensions.add(*ext)\n        else:\n            extensions.add(ext)\n    return extensions\n</code></pre>"},{"location":"reference/griffe/extensions/hybrid/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> hybrid","text":""},{"location":"reference/griffe/extensions/hybrid/#griffe.extensions.hybrid","title":"hybrid","text":"<p>Deprecated. This extension provides an hybrid behavior while loading data.</p> <p>Classes:</p> <ul> <li> HybridExtension         \u2013          <p>Inspect during a visit.</p> </li> </ul>"},{"location":"reference/griffe/extensions/hybrid/#griffe.extensions.hybrid.HybridExtension","title":"HybridExtension","text":"<pre><code>HybridExtension(\n    extensions: Sequence[\n        str\n        | dict[str, Any]\n        | InspectorExtension\n        | type[InspectorExtension]\n    ],\n    object_paths: Sequence[str | Pattern] | None = None,\n)\n</code></pre> <p>             Bases: <code>VisitorExtension</code></p> <p>Inspect during a visit.</p> <p>This extension accepts the name of another extension (an inspector) and runs it appropriately. It allows to inspect objects after having visited them, so as to extract more data.</p> <p>Indeed, during the visit, an object might be seen as a simple attribute (assignment), when in fact it's a function or a class dynamically constructed. In this case, inspecting it will provide the desired data.</p> <p>Parameters:</p> <ul> <li> extensions             (<code>Sequence[str | dict[str, Any] | InspectorExtension | type[InspectorExtension]]</code>)         \u2013          <p>The names or configurations of other inspector extensions.</p> </li> <li> object_paths             (<code>Sequence[str | Pattern] | None</code>, default:                 <code>None</code> )         \u2013          <p>Optional list of regular expressions to match against objects paths, to select which objects to inspect.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ExtensionError</code>           \u2013          <p>When the passed extension is not an inspector extension.</p> </li> </ul> <p>Methods:</p> <ul> </ul> Source code in <code>src/griffe/extensions/hybrid.py</code> <pre><code>def __init__(\n    self,\n    extensions: Sequence[str | dict[str, Any] | InspectorExtension | type[InspectorExtension]],\n    object_paths: Sequence[str | Pattern] | None = None,\n) -&gt; None:\n\"\"\"Initialize the extension.\n\n    Parameters:\n        extensions: The names or configurations of other inspector extensions.\n        object_paths: Optional list of regular expressions to match against objects paths,\n            to select which objects to inspect.\n\n    Raises:\n        ExtensionError: When the passed extension is not an inspector extension.\n    \"\"\"\n    self._extensions: list[InspectorExtension] = [_load_extension(ext) for ext in extensions]  # type: ignore[misc]\n    for extension in self._extensions:\n        if not isinstance(extension, InspectorExtension):\n            raise ExtensionError(\n                f\"Extension '{extension}' is not an inspector extension. \"\n                \"The 'hybrid' extension only accepts inspector extensions. \"\n                \"If you want to use a visitor extension, just add it normally \"\n                \"to your extensions configuration, without using 'hybrid'.\",\n            )\n    self.object_paths = [re.compile(op) if isinstance(op, str) else op for op in object_paths or []]\n    super().__init__()\n</code></pre>"},{"location":"coverage/","title":"Coverage report","text":""}]}